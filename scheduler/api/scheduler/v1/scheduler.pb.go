// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto

package scheduler

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type JobsRequest struct {
	// If not specified or "", all projects' jobs are returned.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Cursor  string `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// page_size is currently not implemented and is ignored.
	PageSize             int32    `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobsRequest) Reset()         { *m = JobsRequest{} }
func (m *JobsRequest) String() string { return proto.CompactTextString(m) }
func (*JobsRequest) ProtoMessage()    {}
func (*JobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{0}
}

func (m *JobsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobsRequest.Unmarshal(m, b)
}
func (m *JobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobsRequest.Marshal(b, m, deterministic)
}
func (m *JobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobsRequest.Merge(m, src)
}
func (m *JobsRequest) XXX_Size() int {
	return xxx_messageInfo_JobsRequest.Size(m)
}
func (m *JobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobsRequest proto.InternalMessageInfo

func (m *JobsRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *JobsRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *JobsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type JobsReply struct {
	Jobs                 []*Job   `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	NextCursor           string   `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobsReply) Reset()         { *m = JobsReply{} }
func (m *JobsReply) String() string { return proto.CompactTextString(m) }
func (*JobsReply) ProtoMessage()    {}
func (*JobsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{1}
}

func (m *JobsReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobsReply.Unmarshal(m, b)
}
func (m *JobsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobsReply.Marshal(b, m, deterministic)
}
func (m *JobsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobsReply.Merge(m, src)
}
func (m *JobsReply) XXX_Size() int {
	return xxx_messageInfo_JobsReply.Size(m)
}
func (m *JobsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_JobsReply.DiscardUnknown(m)
}

var xxx_messageInfo_JobsReply proto.InternalMessageInfo

func (m *JobsReply) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *JobsReply) GetNextCursor() string {
	if m != nil {
		return m.NextCursor
	}
	return ""
}

type InvocationsRequest struct {
	JobRef *JobRef `protobuf:"bytes,1,opt,name=job_ref,json=jobRef,proto3" json:"job_ref,omitempty"`
	Cursor string  `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// page_size defaults to 50 which is maximum.
	PageSize             int32    `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvocationsRequest) Reset()         { *m = InvocationsRequest{} }
func (m *InvocationsRequest) String() string { return proto.CompactTextString(m) }
func (*InvocationsRequest) ProtoMessage()    {}
func (*InvocationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{2}
}

func (m *InvocationsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InvocationsRequest.Unmarshal(m, b)
}
func (m *InvocationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InvocationsRequest.Marshal(b, m, deterministic)
}
func (m *InvocationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvocationsRequest.Merge(m, src)
}
func (m *InvocationsRequest) XXX_Size() int {
	return xxx_messageInfo_InvocationsRequest.Size(m)
}
func (m *InvocationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InvocationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InvocationsRequest proto.InternalMessageInfo

func (m *InvocationsRequest) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *InvocationsRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *InvocationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type InvocationsReply struct {
	Invocations          []*Invocation `protobuf:"bytes,1,rep,name=invocations,proto3" json:"invocations,omitempty"`
	NextCursor           string        `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InvocationsReply) Reset()         { *m = InvocationsReply{} }
func (m *InvocationsReply) String() string { return proto.CompactTextString(m) }
func (*InvocationsReply) ProtoMessage()    {}
func (*InvocationsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{3}
}

func (m *InvocationsReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InvocationsReply.Unmarshal(m, b)
}
func (m *InvocationsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InvocationsReply.Marshal(b, m, deterministic)
}
func (m *InvocationsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvocationsReply.Merge(m, src)
}
func (m *InvocationsReply) XXX_Size() int {
	return xxx_messageInfo_InvocationsReply.Size(m)
}
func (m *InvocationsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InvocationsReply.DiscardUnknown(m)
}

var xxx_messageInfo_InvocationsReply proto.InternalMessageInfo

func (m *InvocationsReply) GetInvocations() []*Invocation {
	if m != nil {
		return m.Invocations
	}
	return nil
}

func (m *InvocationsReply) GetNextCursor() string {
	if m != nil {
		return m.NextCursor
	}
	return ""
}

type EmitTriggersRequest struct {
	// A trigger and jobs it should be delivered to.
	//
	// Order is important. Triggers that are listed earlier are considered older.
	Batches []*EmitTriggersRequest_Batch `protobuf:"bytes,1,rep,name=batches,proto3" json:"batches,omitempty"`
	// An optional timestamp to use as trigger creation time, as unix timestamp in
	// microseconds. Assigned by the server by default. If given, must be within
	// +-15 min of the current time.
	//
	// Under some conditions triggers are ordered by timestamp of when they are
	// created. By allowing the client to specify this timestamp, we make
	// EmitTrigger RPC idempotent: if EmitTrigger call fails midway, the caller
	// can retry it providing exact same timestamp to get the correct final order
	// of the triggers.
	Timestamp            int64    `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmitTriggersRequest) Reset()         { *m = EmitTriggersRequest{} }
func (m *EmitTriggersRequest) String() string { return proto.CompactTextString(m) }
func (*EmitTriggersRequest) ProtoMessage()    {}
func (*EmitTriggersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{4}
}

func (m *EmitTriggersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitTriggersRequest.Unmarshal(m, b)
}
func (m *EmitTriggersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitTriggersRequest.Marshal(b, m, deterministic)
}
func (m *EmitTriggersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitTriggersRequest.Merge(m, src)
}
func (m *EmitTriggersRequest) XXX_Size() int {
	return xxx_messageInfo_EmitTriggersRequest.Size(m)
}
func (m *EmitTriggersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitTriggersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EmitTriggersRequest proto.InternalMessageInfo

func (m *EmitTriggersRequest) GetBatches() []*EmitTriggersRequest_Batch {
	if m != nil {
		return m.Batches
	}
	return nil
}

func (m *EmitTriggersRequest) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type EmitTriggersRequest_Batch struct {
	Trigger              *Trigger  `protobuf:"bytes,1,opt,name=trigger,proto3" json:"trigger,omitempty"`
	Jobs                 []*JobRef `protobuf:"bytes,2,rep,name=jobs,proto3" json:"jobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *EmitTriggersRequest_Batch) Reset()         { *m = EmitTriggersRequest_Batch{} }
func (m *EmitTriggersRequest_Batch) String() string { return proto.CompactTextString(m) }
func (*EmitTriggersRequest_Batch) ProtoMessage()    {}
func (*EmitTriggersRequest_Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{4, 0}
}

func (m *EmitTriggersRequest_Batch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitTriggersRequest_Batch.Unmarshal(m, b)
}
func (m *EmitTriggersRequest_Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitTriggersRequest_Batch.Marshal(b, m, deterministic)
}
func (m *EmitTriggersRequest_Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitTriggersRequest_Batch.Merge(m, src)
}
func (m *EmitTriggersRequest_Batch) XXX_Size() int {
	return xxx_messageInfo_EmitTriggersRequest_Batch.Size(m)
}
func (m *EmitTriggersRequest_Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitTriggersRequest_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_EmitTriggersRequest_Batch proto.InternalMessageInfo

func (m *EmitTriggersRequest_Batch) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *EmitTriggersRequest_Batch) GetJobs() []*JobRef {
	if m != nil {
		return m.Jobs
	}
	return nil
}

// JobRef uniquely identifies a job.
type JobRef struct {
	Project              string   `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Job                  string   `protobuf:"bytes,2,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobRef) Reset()         { *m = JobRef{} }
func (m *JobRef) String() string { return proto.CompactTextString(m) }
func (*JobRef) ProtoMessage()    {}
func (*JobRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{5}
}

func (m *JobRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobRef.Unmarshal(m, b)
}
func (m *JobRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobRef.Marshal(b, m, deterministic)
}
func (m *JobRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRef.Merge(m, src)
}
func (m *JobRef) XXX_Size() int {
	return xxx_messageInfo_JobRef.Size(m)
}
func (m *JobRef) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRef.DiscardUnknown(m)
}

var xxx_messageInfo_JobRef proto.InternalMessageInfo

func (m *JobRef) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *JobRef) GetJob() string {
	if m != nil {
		return m.Job
	}
	return ""
}

// InvocationRef uniquely identifies an invocation of a job.
type InvocationRef struct {
	JobRef *JobRef `protobuf:"bytes,1,opt,name=job_ref,json=jobRef,proto3" json:"job_ref,omitempty"`
	// invocation_id is a unique integer among all invocations for a given job.
	// However, there could be invocations with the same invocation_id but
	// belonging to different jobs.
	InvocationId         int64    `protobuf:"varint,2,opt,name=invocation_id,json=invocationId,proto3" json:"invocation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvocationRef) Reset()         { *m = InvocationRef{} }
func (m *InvocationRef) String() string { return proto.CompactTextString(m) }
func (*InvocationRef) ProtoMessage()    {}
func (*InvocationRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{6}
}

func (m *InvocationRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InvocationRef.Unmarshal(m, b)
}
func (m *InvocationRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InvocationRef.Marshal(b, m, deterministic)
}
func (m *InvocationRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvocationRef.Merge(m, src)
}
func (m *InvocationRef) XXX_Size() int {
	return xxx_messageInfo_InvocationRef.Size(m)
}
func (m *InvocationRef) XXX_DiscardUnknown() {
	xxx_messageInfo_InvocationRef.DiscardUnknown(m)
}

var xxx_messageInfo_InvocationRef proto.InternalMessageInfo

func (m *InvocationRef) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *InvocationRef) GetInvocationId() int64 {
	if m != nil {
		return m.InvocationId
	}
	return 0
}

// Job descibes currently configured job.
type Job struct {
	JobRef               *JobRef   `protobuf:"bytes,1,opt,name=job_ref,json=jobRef,proto3" json:"job_ref,omitempty"`
	Schedule             string    `protobuf:"bytes,2,opt,name=schedule,proto3" json:"schedule,omitempty"`
	State                *JobState `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Paused               bool      `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{7}
}

func (m *Job) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Job.Unmarshal(m, b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return xxx_messageInfo_Job.Size(m)
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *Job) GetSchedule() string {
	if m != nil {
		return m.Schedule
	}
	return ""
}

func (m *Job) GetState() *JobState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Job) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

// JobState describes current Job state as one of these strings:
//   "DISABLED"
//   "PAUSED"
//   "RUNNING"
//   "SCHEDULED"
//   "WAITING"
type JobState struct {
	UiStatus             string   `protobuf:"bytes,1,opt,name=ui_status,json=uiStatus,proto3" json:"ui_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobState) Reset()         { *m = JobState{} }
func (m *JobState) String() string { return proto.CompactTextString(m) }
func (*JobState) ProtoMessage()    {}
func (*JobState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{8}
}

func (m *JobState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobState.Unmarshal(m, b)
}
func (m *JobState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobState.Marshal(b, m, deterministic)
}
func (m *JobState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobState.Merge(m, src)
}
func (m *JobState) XXX_Size() int {
	return xxx_messageInfo_JobState.Size(m)
}
func (m *JobState) XXX_DiscardUnknown() {
	xxx_messageInfo_JobState.DiscardUnknown(m)
}

var xxx_messageInfo_JobState proto.InternalMessageInfo

func (m *JobState) GetUiStatus() string {
	if m != nil {
		return m.UiStatus
	}
	return ""
}

// Invocation describes properties of one job execution.
type Invocation struct {
	InvocationRef *InvocationRef `protobuf:"bytes,1,opt,name=invocation_ref,json=invocationRef,proto3" json:"invocation_ref,omitempty"`
	// start_ts is unix timestamp in microseconds.
	StartedTs int64 `protobuf:"varint,2,opt,name=started_ts,json=startedTs,proto3" json:"started_ts,omitempty"`
	// finished_ts is unix timestamp in microseconds. Set only if final is true.
	FinishedTs int64 `protobuf:"varint,3,opt,name=finished_ts,json=finishedTs,proto3" json:"finished_ts,omitempty"`
	// triggered_by is an identity ("kind:value") which is specified only if
	// invocation was triggered by not the scheduler service itself.
	TriggeredBy string `protobuf:"bytes,4,opt,name=triggered_by,json=triggeredBy,proto3" json:"triggered_by,omitempty"`
	// Latest status of a job.
	Status string `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	// If true, this invocation properties are final and won't be changed.
	Final bool `protobuf:"varint,6,opt,name=final,proto3" json:"final,omitempty"`
	// config_revision pins project/job config version according to which this
	// invocation was created.
	ConfigRevision string `protobuf:"bytes,7,opt,name=config_revision,json=configRevision,proto3" json:"config_revision,omitempty"`
	// view_url points to human readable page for a given invocation if available.
	ViewUrl              string   `protobuf:"bytes,8,opt,name=view_url,json=viewUrl,proto3" json:"view_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Invocation) Reset()         { *m = Invocation{} }
func (m *Invocation) String() string { return proto.CompactTextString(m) }
func (*Invocation) ProtoMessage()    {}
func (*Invocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e96332fbbddc17fa, []int{9}
}

func (m *Invocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Invocation.Unmarshal(m, b)
}
func (m *Invocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Invocation.Marshal(b, m, deterministic)
}
func (m *Invocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Invocation.Merge(m, src)
}
func (m *Invocation) XXX_Size() int {
	return xxx_messageInfo_Invocation.Size(m)
}
func (m *Invocation) XXX_DiscardUnknown() {
	xxx_messageInfo_Invocation.DiscardUnknown(m)
}

var xxx_messageInfo_Invocation proto.InternalMessageInfo

func (m *Invocation) GetInvocationRef() *InvocationRef {
	if m != nil {
		return m.InvocationRef
	}
	return nil
}

func (m *Invocation) GetStartedTs() int64 {
	if m != nil {
		return m.StartedTs
	}
	return 0
}

func (m *Invocation) GetFinishedTs() int64 {
	if m != nil {
		return m.FinishedTs
	}
	return 0
}

func (m *Invocation) GetTriggeredBy() string {
	if m != nil {
		return m.TriggeredBy
	}
	return ""
}

func (m *Invocation) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Invocation) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *Invocation) GetConfigRevision() string {
	if m != nil {
		return m.ConfigRevision
	}
	return ""
}

func (m *Invocation) GetViewUrl() string {
	if m != nil {
		return m.ViewUrl
	}
	return ""
}

func init() {
	proto.RegisterType((*JobsRequest)(nil), "scheduler.JobsRequest")
	proto.RegisterType((*JobsReply)(nil), "scheduler.JobsReply")
	proto.RegisterType((*InvocationsRequest)(nil), "scheduler.InvocationsRequest")
	proto.RegisterType((*InvocationsReply)(nil), "scheduler.InvocationsReply")
	proto.RegisterType((*EmitTriggersRequest)(nil), "scheduler.EmitTriggersRequest")
	proto.RegisterType((*EmitTriggersRequest_Batch)(nil), "scheduler.EmitTriggersRequest.Batch")
	proto.RegisterType((*JobRef)(nil), "scheduler.JobRef")
	proto.RegisterType((*InvocationRef)(nil), "scheduler.InvocationRef")
	proto.RegisterType((*Job)(nil), "scheduler.Job")
	proto.RegisterType((*JobState)(nil), "scheduler.JobState")
	proto.RegisterType((*Invocation)(nil), "scheduler.Invocation")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto", fileDescriptor_e96332fbbddc17fa)
}

var fileDescriptor_e96332fbbddc17fa = []byte{
	// 753 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdf, 0x52, 0xeb, 0x44,
	0x1c, 0x9e, 0x52, 0xda, 0x26, 0xbf, 0x42, 0xc1, 0x05, 0x99, 0x58, 0x44, 0x6b, 0xd4, 0xa1, 0x3a,
	0x4e, 0x3a, 0x56, 0x91, 0x3b, 0x50, 0x18, 0x64, 0x60, 0xbc, 0x60, 0x52, 0xbc, 0x63, 0x26, 0x26,
	0xe9, 0x26, 0xdd, 0x4e, 0xda, 0x8d, 0xd9, 0x4d, 0xb5, 0xbc, 0x80, 0xb7, 0x3e, 0x83, 0x6f, 0xe4,
	0x1b, 0x9d, 0xd9, 0xcd, 0xa6, 0x49, 0x0f, 0x2d, 0xe7, 0xf4, 0x5c, 0xb5, 0xdf, 0xf7, 0xfb, 0x97,
	0xef, 0xb7, 0x5f, 0x36, 0x70, 0x19, 0x52, 0xcb, 0x1f, 0x25, 0x74, 0x42, 0xd2, 0x89, 0x45, 0x93,
	0xb0, 0x17, 0xa5, 0x3e, 0xe9, 0x31, 0x7f, 0x84, 0x87, 0x69, 0x84, 0x93, 0x9e, 0x1b, 0x97, 0xd1,
	0xec, 0xfb, 0x02, 0x58, 0x71, 0x42, 0x39, 0x45, 0xfa, 0x82, 0x68, 0x1f, 0x87, 0x94, 0x86, 0x11,
	0xee, 0xc9, 0x80, 0x97, 0x06, 0x3d, 0x3c, 0x89, 0xf9, 0x3c, 0xcb, 0x6b, 0x5f, 0x6c, 0x3a, 0x88,
	0x27, 0x24, 0x0c, 0x71, 0xc2, 0xb2, 0x7a, 0xf3, 0x09, 0x9a, 0xf7, 0xd4, 0x63, 0x36, 0xfe, 0x33,
	0xc5, 0x8c, 0x23, 0x03, 0x1a, 0x71, 0x42, 0xc7, 0xd8, 0xe7, 0x46, 0xa5, 0x53, 0xe9, 0xea, 0x76,
	0x0e, 0xd1, 0x11, 0xd4, 0xfd, 0x34, 0x61, 0x34, 0x31, 0xb6, 0x64, 0x40, 0x21, 0x74, 0x0c, 0x7a,
	0xec, 0x86, 0xd8, 0x61, 0xe4, 0x19, 0x1b, 0xd5, 0x4e, 0xa5, 0x5b, 0xb3, 0x35, 0x41, 0x0c, 0xc8,
	0x33, 0x36, 0x1f, 0x40, 0xcf, 0xba, 0xc7, 0xd1, 0x1c, 0x99, 0xb0, 0x3d, 0xa6, 0x1e, 0x33, 0x2a,
	0x9d, 0x6a, 0xb7, 0xd9, 0x6f, 0x59, 0x85, 0xe4, 0x7b, 0xea, 0xd9, 0x32, 0x86, 0x3e, 0x87, 0xe6,
	0x14, 0xff, 0xcd, 0x9d, 0xa5, 0x51, 0x20, 0xa8, 0x6b, 0xc9, 0x98, 0x29, 0xa0, 0xbb, 0xe9, 0x8c,
	0xfa, 0x2e, 0x27, 0x74, 0xba, 0x78, 0xec, 0x6f, 0xa1, 0x31, 0xa6, 0x9e, 0x93, 0xe0, 0x40, 0x3e,
	0x76, 0xb3, 0xff, 0xd1, 0x5b, 0xdd, 0x71, 0x60, 0xd7, 0xc7, 0xf2, 0xf7, 0xc3, 0x84, 0x44, 0xb0,
	0xbf, 0x34, 0x56, 0xe8, 0x39, 0x87, 0x26, 0x29, 0x38, 0x25, 0xeb, 0xe3, 0xd2, 0xe0, 0xa2, 0xc2,
	0x2e, 0x67, 0xbe, 0x5b, 0xe4, 0xff, 0x15, 0x38, 0xb8, 0x99, 0x10, 0xfe, 0xa8, 0xce, 0x2a, 0x97,
	0x79, 0x01, 0x0d, 0xcf, 0xe5, 0xfe, 0x08, 0xe7, 0xd3, 0xbe, 0x2a, 0x4d, 0x5b, 0x51, 0x60, 0x5d,
	0x89, 0x6c, 0x3b, 0x2f, 0x42, 0x9f, 0x82, 0xce, 0xc9, 0x04, 0x33, 0xee, 0x4e, 0x62, 0x39, 0xb6,
	0x6a, 0x17, 0x44, 0xfb, 0x09, 0x6a, 0x32, 0x1f, 0x7d, 0x07, 0x0d, 0xe5, 0x12, 0xb5, 0x4d, 0x54,
	0x1a, 0xa3, 0x46, 0xd8, 0x79, 0x0a, 0xfa, 0x5a, 0x1d, 0xeb, 0x96, 0x7c, 0xa2, 0x15, 0x8b, 0x97,
	0x61, 0xf3, 0x47, 0xa8, 0x67, 0xf8, 0x15, 0x8f, 0xed, 0x43, 0x75, 0x4c, 0x3d, 0xb5, 0x10, 0xf1,
	0xd7, 0xfc, 0x03, 0x76, 0x4b, 0x5b, 0xc4, 0xc1, 0x46, 0x27, 0xfd, 0x25, 0xec, 0x16, 0x6b, 0x77,
	0xc8, 0x50, 0x49, 0xde, 0x29, 0xc8, 0xbb, 0xa1, 0xf9, 0x6f, 0x05, 0xaa, 0xf7, 0xd4, 0xdb, 0xa8,
	0x71, 0x1b, 0xb4, 0x3c, 0xa6, 0x1e, 0x76, 0x81, 0xd1, 0x37, 0x50, 0x63, 0xdc, 0xe5, 0x99, 0x85,
	0x9a, 0xfd, 0x83, 0xe5, 0x2e, 0x03, 0x11, 0xb2, 0xb3, 0x0c, 0xe1, 0xc4, 0xd8, 0x4d, 0x19, 0x1e,
	0x1a, 0xdb, 0x9d, 0x4a, 0x57, 0xb3, 0x15, 0x32, 0x4f, 0x41, 0xcb, 0x53, 0x85, 0x2b, 0x53, 0xe2,
	0x88, 0xfc, 0x94, 0xa9, 0x75, 0x69, 0x29, 0x19, 0x48, 0x6c, 0xfe, 0xb7, 0x05, 0x50, 0xac, 0x07,
	0x5d, 0x42, 0xab, 0xa4, 0xb7, 0x50, 0x62, 0xac, 0xf6, 0x24, 0x0e, 0xec, 0xd2, 0x7e, 0x84, 0xae,
	0x13, 0x00, 0xc6, 0xdd, 0x84, 0xe3, 0xa1, 0xc3, 0x59, 0x6e, 0x10, 0xc5, 0x3c, 0x4a, 0xdf, 0x06,
	0x64, 0x4a, 0xd8, 0x28, 0x8b, 0x57, 0x65, 0x1c, 0x72, 0xea, 0x91, 0xa1, 0x2f, 0x60, 0x47, 0xb9,
	0x02, 0x0f, 0x1d, 0x6f, 0x2e, 0x65, 0xe9, 0x76, 0x73, 0xc1, 0x5d, 0xcd, 0x85, 0x66, 0x25, 0xa6,
	0x96, 0xbd, 0x7d, 0x19, 0x42, 0x87, 0x50, 0x0b, 0xc8, 0xd4, 0x8d, 0x8c, 0xba, 0x5c, 0x45, 0x06,
	0xd0, 0x29, 0xec, 0xf9, 0x74, 0x1a, 0x90, 0xd0, 0x49, 0xf0, 0x8c, 0x30, 0x42, 0xa7, 0x46, 0x43,
	0x96, 0xb5, 0x32, 0xda, 0x56, 0x2c, 0xfa, 0x04, 0xb4, 0x19, 0xc1, 0x7f, 0x39, 0x69, 0x12, 0x19,
	0x5a, 0x66, 0x2a, 0x81, 0x7f, 0x4f, 0xa2, 0xfe, 0x3f, 0xdb, 0xa0, 0x0f, 0x72, 0xfd, 0xe8, 0x1c,
	0x1a, 0xb7, 0x98, 0x8b, 0x4b, 0x09, 0x1d, 0x2d, 0x1f, 0x4d, 0xfe, 0xd2, 0xb4, 0x0f, 0x5f, 0xf0,
	0xe2, 0x6d, 0xff, 0x0d, 0x5a, 0xb7, 0x98, 0x97, 0x2e, 0x01, 0x74, 0xb2, 0x72, 0xad, 0x8b, 0x36,
	0xc7, 0xeb, 0xc2, 0xa2, 0xdb, 0xcf, 0xb0, 0xbb, 0xd4, 0x0d, 0xad, 0x3d, 0xa3, 0xf6, 0xea, 0x1b,
	0x05, 0x9d, 0x81, 0xf6, 0x20, 0xec, 0x22, 0xbc, 0xfb, 0xd2, 0xaa, 0xed, 0x23, 0x2b, 0xfb, 0x6a,
	0x58, 0xf9, 0x57, 0xc3, 0xba, 0x11, 0x5f, 0x0d, 0xf4, 0x13, 0xe8, 0x36, 0x66, 0xe9, 0x64, 0xd3,
	0xba, 0x33, 0xd0, 0x7e, 0xf1, 0x68, 0xc2, 0x37, 0x2c, 0xbb, 0x86, 0x3d, 0x59, 0xf6, 0x5e, 0x4a,
	0xd7, 0x35, 0xf9, 0x15, 0x76, 0xca, 0x97, 0x1b, 0xfa, 0xec, 0xf5, 0x5b, 0x6f, 0x5d, 0x1f, 0xaf,
	0x2e, 0xf1, 0x0f, 0x6f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x27, 0x58, 0xb2, 0x46, 0x9d, 0x07, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchedulerClient interface {
	// GetJobs fetches all jobs satisfying JobsRequest and visibility ACLs.
	// If JobsRequest.project is specified but the project doesn't exist, empty
	// list of Jobs is returned.
	GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error)
	// GetInvocations fetches invocations of a given job, most recent first.
	GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error)
	// GetInvocation fetches a single invocation.
	GetInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*Invocation, error)
	// PauseJob will prevent automatic triggering of a job. Manual triggering such
	// as through this API is still allowed. Any pending or running invocations
	// are still executed. PauseJob does nothing if job is already paused.
	//
	// Requires OWNER Job permission.
	PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error)
	// ResumeJob resumes paused job. ResumeJob does nothing if job is not paused.
	//
	// Requires OWNER Job permission.
	ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error)
	// AbortJob resets the job to scheduled state, aborting a currently pending or
	// running invocation if any.
	//
	// Note, that this is similar to AbortInvocation except that AbortInvocation
	// requires invocation ID and doesn't ensure that the invocation aborted is
	// actually latest triggered for the job.
	//
	// Requires OWNER Job permission.
	AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error)
	// AbortInvocation aborts a given job invocation.
	// If an invocation is final, AbortInvocation does nothing.
	//
	// If you want to abort a specific hung invocation, use this request instead
	// of AbortJob.
	//
	// Requires OWNER Job permission.
	AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*empty.Empty, error)
	// EmitTriggers puts one or more triggers into pending trigger queues of the
	// specified jobs.
	//
	// This eventually causes jobs to start executing. The scheduler may merge
	// multiple triggers into one job execution, based on how the job is
	// configured.
	//
	// If at least one job doesn't exist or the caller has no permission to
	// trigger it, the entire request is aborted. Otherwise, the request is NOT
	// transactional: if it fails midway (e.g by returning internal server error),
	// some triggers may have been submitted and some may not. It is safe to retry
	// the call, supplying the same trigger IDs. Triggers with the same IDs will
	// be deduplicated. See Trigger message for more details.
	//
	// Requires TRIGGERER Job permission.
	EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}
type schedulerPRPCClient struct {
	client *prpc.Client
}

func NewSchedulerPRPCClient(client *prpc.Client) SchedulerClient {
	return &schedulerPRPCClient{client}
}

func (c *schedulerPRPCClient) GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error) {
	out := new(JobsReply)
	err := c.client.Call(ctx, "scheduler.Scheduler", "GetJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error) {
	out := new(InvocationsReply)
	err := c.client.Call(ctx, "scheduler.Scheduler", "GetInvocations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) GetInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*Invocation, error) {
	out := new(Invocation)
	err := c.client.Call(ctx, "scheduler.Scheduler", "GetInvocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "PauseJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "ResumeJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "AbortJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "AbortInvocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "EmitTriggers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error) {
	out := new(JobsReply)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/GetJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error) {
	out := new(InvocationsReply)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/GetInvocations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*Invocation, error) {
	out := new(Invocation)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/GetInvocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/PauseJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/ResumeJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/AbortJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/AbortInvocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/scheduler.Scheduler/EmitTriggers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerServer is the server API for Scheduler service.
type SchedulerServer interface {
	// GetJobs fetches all jobs satisfying JobsRequest and visibility ACLs.
	// If JobsRequest.project is specified but the project doesn't exist, empty
	// list of Jobs is returned.
	GetJobs(context.Context, *JobsRequest) (*JobsReply, error)
	// GetInvocations fetches invocations of a given job, most recent first.
	GetInvocations(context.Context, *InvocationsRequest) (*InvocationsReply, error)
	// GetInvocation fetches a single invocation.
	GetInvocation(context.Context, *InvocationRef) (*Invocation, error)
	// PauseJob will prevent automatic triggering of a job. Manual triggering such
	// as through this API is still allowed. Any pending or running invocations
	// are still executed. PauseJob does nothing if job is already paused.
	//
	// Requires OWNER Job permission.
	PauseJob(context.Context, *JobRef) (*empty.Empty, error)
	// ResumeJob resumes paused job. ResumeJob does nothing if job is not paused.
	//
	// Requires OWNER Job permission.
	ResumeJob(context.Context, *JobRef) (*empty.Empty, error)
	// AbortJob resets the job to scheduled state, aborting a currently pending or
	// running invocation if any.
	//
	// Note, that this is similar to AbortInvocation except that AbortInvocation
	// requires invocation ID and doesn't ensure that the invocation aborted is
	// actually latest triggered for the job.
	//
	// Requires OWNER Job permission.
	AbortJob(context.Context, *JobRef) (*empty.Empty, error)
	// AbortInvocation aborts a given job invocation.
	// If an invocation is final, AbortInvocation does nothing.
	//
	// If you want to abort a specific hung invocation, use this request instead
	// of AbortJob.
	//
	// Requires OWNER Job permission.
	AbortInvocation(context.Context, *InvocationRef) (*empty.Empty, error)
	// EmitTriggers puts one or more triggers into pending trigger queues of the
	// specified jobs.
	//
	// This eventually causes jobs to start executing. The scheduler may merge
	// multiple triggers into one job execution, based on how the job is
	// configured.
	//
	// If at least one job doesn't exist or the caller has no permission to
	// trigger it, the entire request is aborted. Otherwise, the request is NOT
	// transactional: if it fails midway (e.g by returning internal server error),
	// some triggers may have been submitted and some may not. It is safe to retry
	// the call, supplying the same trigger IDs. Triggers with the same IDs will
	// be deduplicated. See Trigger message for more details.
	//
	// Requires TRIGGERER Job permission.
	EmitTriggers(context.Context, *EmitTriggersRequest) (*empty.Empty, error)
}

func RegisterSchedulerServer(s prpc.Registrar, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_GetJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).GetJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/GetJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).GetJobs(ctx, req.(*JobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_GetInvocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).GetInvocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/GetInvocations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).GetInvocations(ctx, req.(*InvocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_GetInvocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvocationRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).GetInvocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/GetInvocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).GetInvocation(ctx, req.(*InvocationRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_PauseJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).PauseJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/PauseJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).PauseJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ResumeJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ResumeJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/ResumeJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ResumeJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_AbortJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).AbortJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/AbortJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).AbortJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_AbortInvocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvocationRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).AbortInvocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/AbortInvocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).AbortInvocation(ctx, req.(*InvocationRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_EmitTriggers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmitTriggersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).EmitTriggers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/EmitTriggers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).EmitTriggers(ctx, req.(*EmitTriggersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scheduler.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJobs",
			Handler:    _Scheduler_GetJobs_Handler,
		},
		{
			MethodName: "GetInvocations",
			Handler:    _Scheduler_GetInvocations_Handler,
		},
		{
			MethodName: "GetInvocation",
			Handler:    _Scheduler_GetInvocation_Handler,
		},
		{
			MethodName: "PauseJob",
			Handler:    _Scheduler_PauseJob_Handler,
		},
		{
			MethodName: "ResumeJob",
			Handler:    _Scheduler_ResumeJob_Handler,
		},
		{
			MethodName: "AbortJob",
			Handler:    _Scheduler_AbortJob_Handler,
		},
		{
			MethodName: "AbortInvocation",
			Handler:    _Scheduler_AbortInvocation_Handler,
		},
		{
			MethodName: "EmitTriggers",
			Handler:    _Scheduler_EmitTriggers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto",
}
