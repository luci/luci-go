// Copyright 2018 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ensure

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"go.chromium.org/luci/common/testing/ftt"
	"go.chromium.org/luci/common/testing/truth/assert"
	"go.chromium.org/luci/common/testing/truth/should"

	"go.chromium.org/luci/cipd/common"
)

func TestVersionsFile(t *testing.T) {
	t.Parallel()

	const (
		iid1 = "11111joOfFfFcq7fHCKAIrU34oeFAT174Bf8eHMajMUC"
		iid2 = "22222joOfFfFcq7fHCKAIrU34oeFAT174Bf8eHMajMUC"
	)

	ftt.Run("Setter/getter", t, func(t *ftt.Test) {
		v := VersionsFile{}

		_, err := v.ResolveVersion("pkg", "ver")
		assert.Loosely(t, err, should.ErrLike("not in the versions file"))

		assert.Loosely(t, v.AddVersion("pkg", "ver", iid1), should.BeNil)
		assert.Loosely(t, v.AddVersion("pkg", iid1, iid1), should.BeNil) // noop
		assert.Loosely(t, v, should.HaveLength(1))

		pin, err := v.ResolveVersion("pkg", "ver")
		assert.Loosely(t, err, should.BeNil)
		assert.Loosely(t, pin, should.Match(common.Pin{
			PackageName: "pkg",
			InstanceID:  iid1,
		}))

		pin, err = v.ResolveVersion("other-pkg", iid1)
		assert.Loosely(t, err, should.BeNil)
		assert.Loosely(t, pin, should.Match(common.Pin{
			PackageName: "other-pkg",
			InstanceID:  iid1,
		}))
	})

	ftt.Run("AddVersion errors", t, func(t *ftt.Test) {
		v := VersionsFile{}

		assert.Loosely(t, v.AddVersion("???", "ver", iid1), should.ErrLike("invalid package name"))
		assert.Loosely(t, v.AddVersion("pkg", "???", iid1), should.ErrLike("bad version"))
		assert.Loosely(t, v.AddVersion("pkg", "ver", "not-id"), should.ErrLike("not a valid package instance ID"))
		assert.Loosely(t, v.AddVersion("pkg", iid1, iid2), should.ErrLike("should resolve into that ID"))
	})

	ftt.Run("Equal", t, func(t *ftt.Test) {
		v1 := VersionsFile{
			{"pkg1", "ver1"}: iid1,
			{"pkg1", "ver2"}: iid2,
		}
		v2 := VersionsFile{
			{"pkg1", "ver1"}: iid1,
			{"pkg1", "ver2"}: iid1,
		}
		v3 := VersionsFile{
			{"pkg1", "ver1"}: iid1,
		}

		assert.Loosely(t, v1.Equal(v1), should.BeTrue)
		assert.Loosely(t, v1.Equal(v2), should.BeFalse)
		assert.Loosely(t, v1.Equal(v3), should.BeFalse)
	})

	ftt.Run("Serialization and successful parsing", t, func(t *ftt.Test) {
		testVersion := VersionsFile{
			{"pkg1", "ver1"}:      iid1,
			{"pkg1", "ver2"}:      iid1,
			{"pkg2", "tag:works"}: iid2,
		}

		expectedSerialization := fmt.Sprintf(`# This file is auto-generated by 'cipd ensure-file-resolve'.
# Do not modify manually. All changes will be overwritten.

pkg1
	ver1
	%s

pkg1
	ver2
	%s

pkg2
	tag:works
	%s
`, iid1, iid1, iid2)

		t.Run("Serialization", func(t *ftt.Test) {
			b := bytes.Buffer{}
			assert.Loosely(t, testVersion.Serialize(&b), should.BeNil)
			assert.Loosely(t, b.String(), should.Equal(expectedSerialization))
		})

		t.Run("Parsing success", func(t *ftt.Test) {
			v, err := ParseVersionsFile(strings.NewReader(expectedSerialization))
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, v, should.Match(testVersion))
		})

		t.Run("Parsing empty", func(t *ftt.Test) {
			v, err := ParseVersionsFile(strings.NewReader(""))
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, v, should.Match(VersionsFile{}))
		})

		t.Run("Parsing one", func(t *ftt.Test) {
			v, err := ParseVersionsFile(strings.NewReader(fmt.Sprintf("pkg\nver\n%s", iid1)))
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, v, should.Match(VersionsFile{
				{"pkg", "ver"}: iid1,
			}))
		})

		t.Run("Many new lines", func(t *ftt.Test) {
			v, err := ParseVersionsFile(strings.NewReader(
				fmt.Sprintf("pkg\nver1\n%s\n\n\npkg\nver2\n%s", iid1, iid2)))
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, v, should.Match(VersionsFile{
				{"pkg", "ver1"}: iid1,
				{"pkg", "ver2"}: iid2,
			}))
		})
	})

	ftt.Run("Parsing errors", t, func(t *ftt.Test) {
		p := func(text string, args ...any) error {
			v, err := ParseVersionsFile(strings.NewReader(fmt.Sprintf(text, args...)))
			assert.Loosely(t, err, should.NotBeNil)
			assert.Loosely(t, v, should.BeNil)
			return err
		}

		t.Run("Bad format of identifiers", func(t *ftt.Test) {
			assert.Loosely(t, p("???\nver\n%s", iid1), should.ErrLike(
				"failed to parse versions file (line 1): invalid package name"))

			assert.Loosely(t, p("pkg\n???\n%s", iid1), should.ErrLike(
				"failed to parse versions file (line 2): bad version"))

			assert.Loosely(t, p("pkg\nver\nnotid"), should.ErrLike(
				"failed to parse versions file (line 3): not a valid package instance ID"))
		})

		t.Run("Unexpected empty line", func(t *ftt.Test) {
			assert.Loosely(t, p("pkg\n\nver\n%s\n", iid1), should.ErrLike(
				"failed to parse versions file (line 2): expecting a version name, not a new line"))

			assert.Loosely(t, p("pkg\nver\n\n%s\n", iid1), should.ErrLike(
				"failed to parse versions file (line 3): expecting an instance ID, not a new line"))
		})

		t.Run("Unexpected EOF", func(t *ftt.Test) {
			assert.Loosely(t, p("pkg\n"), should.ErrLike(
				"failed to parse versions file (line 1): unexpected EOF, expecting a package version"))

			assert.Loosely(t, p("pkg\nver\n"), should.ErrLike(
				"failed to parse versions file (line 2): unexpected EOF, expecting an instance ID"))
		})

		t.Run("Unexpected line after the triple", func(t *ftt.Test) {
			assert.Loosely(t, p("pkg\nver\n%s\nsomething", iid1), should.ErrLike(
				"failed to parse versions file (line 4): expecting an empty line between each version definition triple"))
		})
	})
}
