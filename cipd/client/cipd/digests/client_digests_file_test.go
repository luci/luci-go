// Copyright 2018 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package digests

import (
	"bytes"
	"strings"
	"testing"

	"go.chromium.org/luci/common/testing/ftt"
	"go.chromium.org/luci/common/testing/truth/assert"
	"go.chromium.org/luci/common/testing/truth/should"

	caspb "go.chromium.org/luci/cipd/api/cipd/v1/caspb"
)

func TestClientDigestsFile(t *testing.T) {
	t.Parallel()

	sha1 := func(char string) *caspb.ObjectRef {
		return &caspb.ObjectRef{
			HashAlgo:  caspb.HashAlgo_SHA1,
			HexDigest: strings.Repeat(char, 40),
		}
	}

	sha256 := func(char string) *caspb.ObjectRef {
		return &caspb.ObjectRef{
			HashAlgo:  caspb.HashAlgo_SHA256,
			HexDigest: strings.Repeat(char, 64),
		}
	}

	ftt.Run("Works", t, func(t *ftt.Test) {
		df := ClientDigestsFile{}

		df.AddClientRef("linux-amd64", sha1("a"))
		df.AddClientRef("linux-amd64", sha256("b"))
		df.AddClientRef("windows-amd64", sha1("c"))

		assert.Loosely(t, df.ClientRef("linux-amd64"), should.Resemble(sha256("b")))
		assert.Loosely(t, df.ClientRef("windows-amd64"), should.Resemble(sha1("c")))
		assert.Loosely(t, df.ClientRef("unknown"), should.BeNil)

		assert.Loosely(t, df.Contains("linux-amd64", sha1("a")), should.BeTrue)
		assert.Loosely(t, df.Contains("linux-amd64", sha256("b")), should.BeTrue)
		assert.Loosely(t, df.Contains("linux-amd64", sha1("c")), should.BeFalse)
		assert.Loosely(t, df.Contains("unknown", sha1("a")), should.BeFalse)
	})

	ftt.Run("Errors in AddClientRef", t, func(t *ftt.Test) {
		df := ClientDigestsFile{}

		assert.Loosely(t, df.AddClientRef("linux-amd64", &caspb.ObjectRef{
			HashAlgo:  12345,
			HexDigest: "aaaa",
		}), should.ErrLike("unsupported unknown hash algorithm"))

		df.AddClientRef("linux-amd64", sha1("a"))
		assert.Loosely(t, df.AddClientRef("linux-amd64", sha1("a")), should.ErrLike("has already been added"))
	})

	ftt.Run("Equal", t, func(t *ftt.Test) {
		df1 := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"a", sha1("a")}, {"b", sha1("b")},
			},
		}
		df2 := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"b", sha1("b")}, {"a", sha1("a")},
			},
		}
		df3 := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"a", sha1("a")},
			},
		}
		df4 := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"a", sha1("b")},
			},
		}

		assert.Loosely(t, df1.Equal(&df1), should.BeTrue)
		assert.Loosely(t, df1.Equal(&df2), should.BeFalse)
		assert.Loosely(t, df1.Equal(&df3), should.BeFalse)
		assert.Loosely(t, df3.Equal(&df4), should.BeFalse)
	})

	ftt.Run("Sort", t, func(t *ftt.Test) {
		df := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"windows-amd64", sha1("a")},
				{"linux-amd64", sha1("b")},
				{"linux-amd64", sha256("c")},
			},
		}
		df.Sort()
		assert.Loosely(t, df, should.Resemble(ClientDigestsFile{
			entries: []clientDigestEntry{
				{"linux-amd64", sha256("c")},
				{"linux-amd64", sha1("b")},
				{"windows-amd64", sha1("a")},
			},
		}))
	})

	ftt.Run("Serialization", t, func(t *ftt.Test) {
		df := ClientDigestsFile{
			entries: []clientDigestEntry{
				{"windows-amd64", sha1("a")},
				{"linux-amd64", sha1("b")},
				{"linux-amd64", sha256("c")},
			},
		}
		buf := bytes.Buffer{}
		assert.Loosely(t, df.Serialize(&buf, "tag:val", "cipd_client_version"), should.BeNil)
		assert.Loosely(t, buf.String(), should.Equal(strings.Join([]string{
			`# This file was generated by`,
			`#`,
			`#  cipd selfupdate-roll -version-file cipd_client_version \`,
			`#      -version tag:val`,
			`#`,
			`# Do not modify manually. All changes will be overwritten.`,
			`# Use 'cipd selfupdate-roll ...' to modify.`,
			``,
			`windows-amd64  sha1    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`,
			`linux-amd64    sha1    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb`,
			`linux-amd64    sha256  cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc`,
			``,
		}, "\n")))
	})

	ftt.Run("Parsing success", t, func(t *ftt.Test) {
		df, err := ParseClientDigestsFile(strings.NewReader(strings.Join([]string{
			"# Comment",
			"linux-amd64	sha256	cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc",
			"",
			" # Another comment",
			"linux-amd64  unknown  bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
			"linux-amd64	sha1  bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
			"windows-amd64	sha1	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
		}, "\n")))
		assert.Loosely(t, err, should.BeNil)
		assert.Loosely(t, df, should.Resemble(&ClientDigestsFile{
			entries: []clientDigestEntry{
				{"linux-amd64", sha256("c")},
				{"linux-amd64", sha1("b")},
				{"windows-amd64", sha1("a")},
			},
		}))
	})

	ftt.Run("Parsing errors", t, func(t *ftt.Test) {
		call := func(lines ...string) error {
			df, err := ParseClientDigestsFile(strings.NewReader(strings.Join(lines, "\n")))
			assert.Loosely(t, err, should.NotBeNil)
			assert.Loosely(t, df, should.BeNil)
			return err
		}

		assert.Loosely(t, call("linux-amd64 sha1"), should.ErrLike("must have format"))
		assert.Loosely(t, call("linux-amd64 sha256 aaaaaa"), should.ErrLike("invalid SHA256 digest"))
		assert.Loosely(t, call(
			"linux-amd64 sha1 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
			"linux-amd64 sha1 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
		), should.ErrLike("has already been added"))
	})
}
