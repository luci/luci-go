// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/cipd/api/cipd/v1/repo.proto

package api

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_struct "github.com/golang/protobuf/ptypes/struct"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Roles used in package prefix ACLs.
//
// A user can have one or more such roles for a package prefix. They get
// inherited by all subprefixes.
type Role int32

const (
	Role_ROLE_UNSPECIFIED Role = 0
	// Readers can fetch package instances and package metadata (e.g. list of
	// instances, all tags, all refs), but not prefix metadata (e.g. ACLs).
	Role_READER Role = 1
	// Writers can do everything that readers can, plus create new packages,
	// upload package instances, attach tags, move refs.
	Role_WRITER Role = 2
	// Owners can do everything that writers can, plus read prefix metadata for
	// all parent prefixes and all subprefixes, and modify prefix metadata for
	// all subprefixes.
	Role_OWNER Role = 3
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "READER",
	2: "WRITER",
	3: "OWNER",
}

var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"READER":           1,
	"WRITER":           2,
	"OWNER":            3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{0}
}

// RegistrationStatus is part of RegisterInstance RPC response.
type RegistrationStatus int32

const (
	RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED RegistrationStatus = 0
	RegistrationStatus_REGISTERED                      RegistrationStatus = 1
	RegistrationStatus_ALREADY_REGISTERED              RegistrationStatus = 2
	RegistrationStatus_NOT_UPLOADED                    RegistrationStatus = 3
)

var RegistrationStatus_name = map[int32]string{
	0: "REGISTRATION_STATUS_UNSPECIFIED",
	1: "REGISTERED",
	2: "ALREADY_REGISTERED",
	3: "NOT_UPLOADED",
}

var RegistrationStatus_value = map[string]int32{
	"REGISTRATION_STATUS_UNSPECIFIED": 0,
	"REGISTERED":                      1,
	"ALREADY_REGISTERED":              2,
	"NOT_UPLOADED":                    3,
}

func (x RegistrationStatus) String() string {
	return proto.EnumName(RegistrationStatus_name, int32(x))
}

func (RegistrationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{1}
}

type Processor_State int32

const (
	Processor_STATE_UNSPECIFIED Processor_State = 0
	Processor_PENDING           Processor_State = 1
	Processor_SUCCEEDED         Processor_State = 2
	Processor_FAILED            Processor_State = 3
)

var Processor_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "PENDING",
	2: "SUCCEEDED",
	3: "FAILED",
}

var Processor_State_value = map[string]int32{
	"STATE_UNSPECIFIED": 0,
	"PENDING":           1,
	"SUCCEEDED":         2,
	"FAILED":            3,
}

func (x Processor_State) String() string {
	return proto.EnumName(Processor_State_name, int32(x))
}

func (Processor_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{22, 0}
}

type PrefixRequest struct {
	// A prefix within the repository, e.g. "a/b/c".
	Prefix               string   `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrefixRequest) Reset()         { *m = PrefixRequest{} }
func (m *PrefixRequest) String() string { return proto.CompactTextString(m) }
func (*PrefixRequest) ProtoMessage()    {}
func (*PrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{0}
}

func (m *PrefixRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixRequest.Unmarshal(m, b)
}
func (m *PrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixRequest.Marshal(b, m, deterministic)
}
func (m *PrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixRequest.Merge(m, src)
}
func (m *PrefixRequest) XXX_Size() int {
	return xxx_messageInfo_PrefixRequest.Size(m)
}
func (m *PrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixRequest proto.InternalMessageInfo

func (m *PrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// PrefixMetadata is metadata defined at some concrete package prefix.
//
// It applies to this prefix and all subprefixes, recursively.
type PrefixMetadata struct {
	// Prefix this metadata is defined at, e.g. "a/b/c".
	//
	// Note: there's no metadata at the root, so prefix must never be "".
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// An opaque string that identifies a particular version of this metadata.
	//
	// Used by UpdatePrefixMetadata to prevent an accidental overwrite of changes.
	Fingerprint string `protobuf:"bytes,2,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	// When the metadata was modified the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Identity string of whoever modified the metadata the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateUser string `protobuf:"bytes,4,opt,name=update_user,json=updateUser,proto3" json:"update_user,omitempty"`
	// ACLs that apply to this prefix and all subprefixes, as a mapping from
	// a role to a list of users and groups that have it.
	Acls                 []*PrefixMetadata_ACL `protobuf:"bytes,5,rep,name=acls,proto3" json:"acls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PrefixMetadata) Reset()         { *m = PrefixMetadata{} }
func (m *PrefixMetadata) String() string { return proto.CompactTextString(m) }
func (*PrefixMetadata) ProtoMessage()    {}
func (*PrefixMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{1}
}

func (m *PrefixMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixMetadata.Unmarshal(m, b)
}
func (m *PrefixMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixMetadata.Marshal(b, m, deterministic)
}
func (m *PrefixMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMetadata.Merge(m, src)
}
func (m *PrefixMetadata) XXX_Size() int {
	return xxx_messageInfo_PrefixMetadata.Size(m)
}
func (m *PrefixMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMetadata proto.InternalMessageInfo

func (m *PrefixMetadata) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *PrefixMetadata) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *PrefixMetadata) GetUpdateTime() *timestamp.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *PrefixMetadata) GetUpdateUser() string {
	if m != nil {
		return m.UpdateUser
	}
	return ""
}

func (m *PrefixMetadata) GetAcls() []*PrefixMetadata_ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

type PrefixMetadata_ACL struct {
	// Role that this ACL describes.
	Role Role `protobuf:"varint,1,opt,name=role,proto3,enum=cipd.Role" json:"role,omitempty"`
	// Users and groups that have the specified role.
	//
	// Each entry has a form "<kind>:<value>", e.g "group:..." or "user:...".
	Principals           []string `protobuf:"bytes,2,rep,name=principals,proto3" json:"principals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrefixMetadata_ACL) Reset()         { *m = PrefixMetadata_ACL{} }
func (m *PrefixMetadata_ACL) String() string { return proto.CompactTextString(m) }
func (*PrefixMetadata_ACL) ProtoMessage()    {}
func (*PrefixMetadata_ACL) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{1, 0}
}

func (m *PrefixMetadata_ACL) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixMetadata_ACL.Unmarshal(m, b)
}
func (m *PrefixMetadata_ACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixMetadata_ACL.Marshal(b, m, deterministic)
}
func (m *PrefixMetadata_ACL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMetadata_ACL.Merge(m, src)
}
func (m *PrefixMetadata_ACL) XXX_Size() int {
	return xxx_messageInfo_PrefixMetadata_ACL.Size(m)
}
func (m *PrefixMetadata_ACL) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMetadata_ACL.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMetadata_ACL proto.InternalMessageInfo

func (m *PrefixMetadata_ACL) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

func (m *PrefixMetadata_ACL) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

type InheritedPrefixMetadata struct {
	// Per-prefix metadata that applies to a prefix, ordered by prefix length.
	//
	// For example, when requesting metadata for prefix "a/b/c/d" the reply may
	// contain entries for "a", "a/b", "a/b/c/d" (in that order, with "a/b/c"
	// skipped in this example as not having any metadata attached).
	PerPrefixMetadata    []*PrefixMetadata `protobuf:"bytes,1,rep,name=per_prefix_metadata,json=perPrefixMetadata,proto3" json:"per_prefix_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InheritedPrefixMetadata) Reset()         { *m = InheritedPrefixMetadata{} }
func (m *InheritedPrefixMetadata) String() string { return proto.CompactTextString(m) }
func (*InheritedPrefixMetadata) ProtoMessage()    {}
func (*InheritedPrefixMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{2}
}

func (m *InheritedPrefixMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InheritedPrefixMetadata.Unmarshal(m, b)
}
func (m *InheritedPrefixMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InheritedPrefixMetadata.Marshal(b, m, deterministic)
}
func (m *InheritedPrefixMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InheritedPrefixMetadata.Merge(m, src)
}
func (m *InheritedPrefixMetadata) XXX_Size() int {
	return xxx_messageInfo_InheritedPrefixMetadata.Size(m)
}
func (m *InheritedPrefixMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_InheritedPrefixMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_InheritedPrefixMetadata proto.InternalMessageInfo

func (m *InheritedPrefixMetadata) GetPerPrefixMetadata() []*PrefixMetadata {
	if m != nil {
		return m.PerPrefixMetadata
	}
	return nil
}

type RolesInPrefixResponse struct {
	// Unordered set or roles the caller has in the requested prefix.
	Roles                []*RolesInPrefixResponse_RoleInPrefix `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *RolesInPrefixResponse) Reset()         { *m = RolesInPrefixResponse{} }
func (m *RolesInPrefixResponse) String() string { return proto.CompactTextString(m) }
func (*RolesInPrefixResponse) ProtoMessage()    {}
func (*RolesInPrefixResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{3}
}

func (m *RolesInPrefixResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RolesInPrefixResponse.Unmarshal(m, b)
}
func (m *RolesInPrefixResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RolesInPrefixResponse.Marshal(b, m, deterministic)
}
func (m *RolesInPrefixResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RolesInPrefixResponse.Merge(m, src)
}
func (m *RolesInPrefixResponse) XXX_Size() int {
	return xxx_messageInfo_RolesInPrefixResponse.Size(m)
}
func (m *RolesInPrefixResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RolesInPrefixResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RolesInPrefixResponse proto.InternalMessageInfo

func (m *RolesInPrefixResponse) GetRoles() []*RolesInPrefixResponse_RoleInPrefix {
	if m != nil {
		return m.Roles
	}
	return nil
}

type RolesInPrefixResponse_RoleInPrefix struct {
	Role                 Role     `protobuf:"varint,1,opt,name=role,proto3,enum=cipd.Role" json:"role,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RolesInPrefixResponse_RoleInPrefix) Reset()         { *m = RolesInPrefixResponse_RoleInPrefix{} }
func (m *RolesInPrefixResponse_RoleInPrefix) String() string { return proto.CompactTextString(m) }
func (*RolesInPrefixResponse_RoleInPrefix) ProtoMessage()    {}
func (*RolesInPrefixResponse_RoleInPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{3, 0}
}

func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Unmarshal(m, b)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Marshal(b, m, deterministic)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Merge(m, src)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Size() int {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Size(m)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix proto.InternalMessageInfo

func (m *RolesInPrefixResponse_RoleInPrefix) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

type ListPrefixRequest struct {
	// A prefix within the repository to list, e.g. "a/b/c". Empty prefix is also
	// accepted: it means "root of the repository".
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// If false, list only direct descendants of the prefix, otherwise all.
	Recursive bool `protobuf:"varint,2,opt,name=recursive,proto3" json:"recursive,omitempty"`
	// If true, include hidden packages in the result.
	IncludeHidden        bool     `protobuf:"varint,3,opt,name=include_hidden,json=includeHidden,proto3" json:"include_hidden,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPrefixRequest) Reset()         { *m = ListPrefixRequest{} }
func (m *ListPrefixRequest) String() string { return proto.CompactTextString(m) }
func (*ListPrefixRequest) ProtoMessage()    {}
func (*ListPrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{4}
}

func (m *ListPrefixRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPrefixRequest.Unmarshal(m, b)
}
func (m *ListPrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPrefixRequest.Marshal(b, m, deterministic)
}
func (m *ListPrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPrefixRequest.Merge(m, src)
}
func (m *ListPrefixRequest) XXX_Size() int {
	return xxx_messageInfo_ListPrefixRequest.Size(m)
}
func (m *ListPrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPrefixRequest proto.InternalMessageInfo

func (m *ListPrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListPrefixRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *ListPrefixRequest) GetIncludeHidden() bool {
	if m != nil {
		return m.IncludeHidden
	}
	return false
}

type ListPrefixResponse struct {
	// Lexicographically sorted list of full packages names.
	Packages []string `protobuf:"bytes,1,rep,name=packages,proto3" json:"packages,omitempty"`
	// Lexicographically sorted list of child prefixes (without trailing '/').
	Prefixes             []string `protobuf:"bytes,2,rep,name=prefixes,proto3" json:"prefixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPrefixResponse) Reset()         { *m = ListPrefixResponse{} }
func (m *ListPrefixResponse) String() string { return proto.CompactTextString(m) }
func (*ListPrefixResponse) ProtoMessage()    {}
func (*ListPrefixResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{5}
}

func (m *ListPrefixResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPrefixResponse.Unmarshal(m, b)
}
func (m *ListPrefixResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPrefixResponse.Marshal(b, m, deterministic)
}
func (m *ListPrefixResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPrefixResponse.Merge(m, src)
}
func (m *ListPrefixResponse) XXX_Size() int {
	return xxx_messageInfo_ListPrefixResponse.Size(m)
}
func (m *ListPrefixResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPrefixResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPrefixResponse proto.InternalMessageInfo

func (m *ListPrefixResponse) GetPackages() []string {
	if m != nil {
		return m.Packages
	}
	return nil
}

func (m *ListPrefixResponse) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

// PackageRequest names a package and nothing else.
type PackageRequest struct {
	Package              string   `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PackageRequest) Reset()         { *m = PackageRequest{} }
func (m *PackageRequest) String() string { return proto.CompactTextString(m) }
func (*PackageRequest) ProtoMessage()    {}
func (*PackageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{6}
}

func (m *PackageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PackageRequest.Unmarshal(m, b)
}
func (m *PackageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PackageRequest.Marshal(b, m, deterministic)
}
func (m *PackageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageRequest.Merge(m, src)
}
func (m *PackageRequest) XXX_Size() int {
	return xxx_messageInfo_PackageRequest.Size(m)
}
func (m *PackageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PackageRequest proto.InternalMessageInfo

func (m *PackageRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

// Instance is a pointer to an instance of some package.
type Instance struct {
	// A name of the package, e.g. "a/b/c/d".
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// A reference to the instance file in the storage.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	// User who registered the instance (output only).
	RegisteredBy string `protobuf:"bytes,3,opt,name=registered_by,json=registeredBy,proto3" json:"registered_by,omitempty"`
	// When the instance was registered (output only).
	RegisteredTs         *timestamp.Timestamp `protobuf:"bytes,4,opt,name=registered_ts,json=registeredTs,proto3" json:"registered_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{7}
}

func (m *Instance) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Instance.Unmarshal(m, b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
}
func (m *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(m, src)
}
func (m *Instance) XXX_Size() int {
	return xxx_messageInfo_Instance.Size(m)
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

func (m *Instance) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Instance) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Instance) GetRegisteredBy() string {
	if m != nil {
		return m.RegisteredBy
	}
	return ""
}

func (m *Instance) GetRegisteredTs() *timestamp.Timestamp {
	if m != nil {
		return m.RegisteredTs
	}
	return nil
}

type RegisterInstanceResponse struct {
	// Outcome of the operation, see the enum for possibilities.
	//
	// Defines what other fields are present.
	Status RegistrationStatus `protobuf:"varint,1,opt,name=status,proto3,enum=cipd.RegistrationStatus" json:"status,omitempty"`
	// For statuses REGISTERED and ALREADY_REGISTERED contains details about the
	// instance. Not set for NOT_UPLOADED status.
	Instance *Instance `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	// For status NOT_UPLOADED contains a new upload operation that can be used
	// together with Storage service to upload the instance file. Not set for
	// other statuses.
	UploadOp             *UploadOperation `protobuf:"bytes,3,opt,name=upload_op,json=uploadOp,proto3" json:"upload_op,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RegisterInstanceResponse) Reset()         { *m = RegisterInstanceResponse{} }
func (m *RegisterInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterInstanceResponse) ProtoMessage()    {}
func (*RegisterInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{8}
}

func (m *RegisterInstanceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterInstanceResponse.Unmarshal(m, b)
}
func (m *RegisterInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterInstanceResponse.Marshal(b, m, deterministic)
}
func (m *RegisterInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterInstanceResponse.Merge(m, src)
}
func (m *RegisterInstanceResponse) XXX_Size() int {
	return xxx_messageInfo_RegisterInstanceResponse.Size(m)
}
func (m *RegisterInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterInstanceResponse proto.InternalMessageInfo

func (m *RegisterInstanceResponse) GetStatus() RegistrationStatus {
	if m != nil {
		return m.Status
	}
	return RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED
}

func (m *RegisterInstanceResponse) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *RegisterInstanceResponse) GetUploadOp() *UploadOperation {
	if m != nil {
		return m.UploadOp
	}
	return nil
}

type ListInstancesRequest struct {
	// Name of a package to list instances of.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// Number of instances to return on one page, default is 100.
	PageSize int32 `protobuf:"varint,20,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Value of 'next_page_token' from the previous response.
	//
	// Can be used to resume fetching.
	PageToken            string   `protobuf:"bytes,21,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListInstancesRequest) Reset()         { *m = ListInstancesRequest{} }
func (m *ListInstancesRequest) String() string { return proto.CompactTextString(m) }
func (*ListInstancesRequest) ProtoMessage()    {}
func (*ListInstancesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{9}
}

func (m *ListInstancesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListInstancesRequest.Unmarshal(m, b)
}
func (m *ListInstancesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListInstancesRequest.Marshal(b, m, deterministic)
}
func (m *ListInstancesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInstancesRequest.Merge(m, src)
}
func (m *ListInstancesRequest) XXX_Size() int {
	return xxx_messageInfo_ListInstancesRequest.Size(m)
}
func (m *ListInstancesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInstancesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListInstancesRequest proto.InternalMessageInfo

func (m *ListInstancesRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *ListInstancesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListInstancesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ListInstancesResponse struct {
	// Package instances, sorted by registration time, most recent first.
	Instances []*Instance `protobuf:"bytes,1,rep,name=instances,proto3" json:"instances,omitempty"`
	// Value to pass as 'page_token' in ListInstancesRequest to resume fetching or
	// empty string if there's no more results.
	NextPageToken        string   `protobuf:"bytes,20,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListInstancesResponse) Reset()         { *m = ListInstancesResponse{} }
func (m *ListInstancesResponse) String() string { return proto.CompactTextString(m) }
func (*ListInstancesResponse) ProtoMessage()    {}
func (*ListInstancesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{10}
}

func (m *ListInstancesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListInstancesResponse.Unmarshal(m, b)
}
func (m *ListInstancesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListInstancesResponse.Marshal(b, m, deterministic)
}
func (m *ListInstancesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInstancesResponse.Merge(m, src)
}
func (m *ListInstancesResponse) XXX_Size() int {
	return xxx_messageInfo_ListInstancesResponse.Size(m)
}
func (m *ListInstancesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInstancesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListInstancesResponse proto.InternalMessageInfo

func (m *ListInstancesResponse) GetInstances() []*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *ListInstancesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type SearchInstancesRequest struct {
	// Name of a package to query instances of (required).
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// Tags to look for (the found instances have ALL these tags attached).
	//
	// Due to internal limitations, the query is most efficient only when it
	// specifies one tag to filter by. All additional tags are checked in a
	// separate step after the initial query. For that reason when searching for
	// multiple tags it is better to specify the most limiting tags first.
	Tags []*Tag `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	// Number of instances to return on one page, default is 100.
	PageSize int32 `protobuf:"varint,20,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Value of 'next_page_token' from the previous response.
	//
	// Can be used to resume fetching.
	PageToken            string   `protobuf:"bytes,21,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchInstancesRequest) Reset()         { *m = SearchInstancesRequest{} }
func (m *SearchInstancesRequest) String() string { return proto.CompactTextString(m) }
func (*SearchInstancesRequest) ProtoMessage()    {}
func (*SearchInstancesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{11}
}

func (m *SearchInstancesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchInstancesRequest.Unmarshal(m, b)
}
func (m *SearchInstancesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchInstancesRequest.Marshal(b, m, deterministic)
}
func (m *SearchInstancesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchInstancesRequest.Merge(m, src)
}
func (m *SearchInstancesRequest) XXX_Size() int {
	return xxx_messageInfo_SearchInstancesRequest.Size(m)
}
func (m *SearchInstancesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchInstancesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchInstancesRequest proto.InternalMessageInfo

func (m *SearchInstancesRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *SearchInstancesRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SearchInstancesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *SearchInstancesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type SearchInstancesResponse struct {
	// Package instances, sorted by registration time, most recent first.
	Instances []*Instance `protobuf:"bytes,1,rep,name=instances,proto3" json:"instances,omitempty"`
	// Value to pass as 'page_token' in SearchInstancesRequest to resume fetching
	// or empty string if there's no more results.
	NextPageToken        string   `protobuf:"bytes,20,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchInstancesResponse) Reset()         { *m = SearchInstancesResponse{} }
func (m *SearchInstancesResponse) String() string { return proto.CompactTextString(m) }
func (*SearchInstancesResponse) ProtoMessage()    {}
func (*SearchInstancesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{12}
}

func (m *SearchInstancesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchInstancesResponse.Unmarshal(m, b)
}
func (m *SearchInstancesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchInstancesResponse.Marshal(b, m, deterministic)
}
func (m *SearchInstancesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchInstancesResponse.Merge(m, src)
}
func (m *SearchInstancesResponse) XXX_Size() int {
	return xxx_messageInfo_SearchInstancesResponse.Size(m)
}
func (m *SearchInstancesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchInstancesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchInstancesResponse proto.InternalMessageInfo

func (m *SearchInstancesResponse) GetInstances() []*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *SearchInstancesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Ref is a mutable named pointer to some package instance that can be used
// as a version identifier.
type Ref struct {
	// Name of the ref, e.g. "latest".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name of the package where the ref is defined.
	Package string `protobuf:"bytes,2,opt,name=package,proto3" json:"package,omitempty"`
	// A package instance the ref is pointing to.
	Instance *ObjectRef `protobuf:"bytes,3,opt,name=instance,proto3" json:"instance,omitempty"`
	// User who modified this ref the last time (output only).
	ModifiedBy string `protobuf:"bytes,4,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by,omitempty"`
	// When the ref was modified the last time (output only).
	ModifiedTs           *timestamp.Timestamp `protobuf:"bytes,5,opt,name=modified_ts,json=modifiedTs,proto3" json:"modified_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Ref) Reset()         { *m = Ref{} }
func (m *Ref) String() string { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()    {}
func (*Ref) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{13}
}

func (m *Ref) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ref.Unmarshal(m, b)
}
func (m *Ref) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ref.Marshal(b, m, deterministic)
}
func (m *Ref) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ref.Merge(m, src)
}
func (m *Ref) XXX_Size() int {
	return xxx_messageInfo_Ref.Size(m)
}
func (m *Ref) XXX_DiscardUnknown() {
	xxx_messageInfo_Ref.DiscardUnknown(m)
}

var xxx_messageInfo_Ref proto.InternalMessageInfo

func (m *Ref) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ref) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Ref) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Ref) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *Ref) GetModifiedTs() *timestamp.Timestamp {
	if m != nil {
		return m.ModifiedTs
	}
	return nil
}

type DeleteRefRequest struct {
	// Name of the ref, e.g. "latest".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name of the package where the ref is defined.
	Package              string   `protobuf:"bytes,2,opt,name=package,proto3" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRefRequest) Reset()         { *m = DeleteRefRequest{} }
func (m *DeleteRefRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRefRequest) ProtoMessage()    {}
func (*DeleteRefRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{14}
}

func (m *DeleteRefRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteRefRequest.Unmarshal(m, b)
}
func (m *DeleteRefRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteRefRequest.Marshal(b, m, deterministic)
}
func (m *DeleteRefRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRefRequest.Merge(m, src)
}
func (m *DeleteRefRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteRefRequest.Size(m)
}
func (m *DeleteRefRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRefRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRefRequest proto.InternalMessageInfo

func (m *DeleteRefRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteRefRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

type ListRefsRequest struct {
	// Name of a package to list refs of.
	Package              string   `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRefsRequest) Reset()         { *m = ListRefsRequest{} }
func (m *ListRefsRequest) String() string { return proto.CompactTextString(m) }
func (*ListRefsRequest) ProtoMessage()    {}
func (*ListRefsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{15}
}

func (m *ListRefsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRefsRequest.Unmarshal(m, b)
}
func (m *ListRefsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRefsRequest.Marshal(b, m, deterministic)
}
func (m *ListRefsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRefsRequest.Merge(m, src)
}
func (m *ListRefsRequest) XXX_Size() int {
	return xxx_messageInfo_ListRefsRequest.Size(m)
}
func (m *ListRefsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRefsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRefsRequest proto.InternalMessageInfo

func (m *ListRefsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

type ListRefsResponse struct {
	// Package refs, sorted by modification time, most recently touched first.
	Refs                 []*Ref   `protobuf:"bytes,1,rep,name=refs,proto3" json:"refs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRefsResponse) Reset()         { *m = ListRefsResponse{} }
func (m *ListRefsResponse) String() string { return proto.CompactTextString(m) }
func (*ListRefsResponse) ProtoMessage()    {}
func (*ListRefsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{16}
}

func (m *ListRefsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRefsResponse.Unmarshal(m, b)
}
func (m *ListRefsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRefsResponse.Marshal(b, m, deterministic)
}
func (m *ListRefsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRefsResponse.Merge(m, src)
}
func (m *ListRefsResponse) XXX_Size() int {
	return xxx_messageInfo_ListRefsResponse.Size(m)
}
func (m *ListRefsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRefsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRefsResponse proto.InternalMessageInfo

func (m *ListRefsResponse) GetRefs() []*Ref {
	if m != nil {
		return m.Refs
	}
	return nil
}

// Tag is a key:value pair attached to some instance.
//
// Keys don't have to be unique, only the full pair should. For example,
// it is fine to have "version:1" and "version:2" tags attached to the same
// instance.
//
// The total length of the tag (as "key:value" pair) should be less that 400
// bytes.
type Tag struct {
	// Key should be a lowercase identifier-like string ([a-z0-9_\-]+).
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value can be an arbitrary string.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// User that attached this tag (output only).
	AttachedBy string `protobuf:"bytes,3,opt,name=attached_by,json=attachedBy,proto3" json:"attached_by,omitempty"`
	// When the tag was attached (output only).
	AttachedTs           *timestamp.Timestamp `protobuf:"bytes,4,opt,name=attached_ts,json=attachedTs,proto3" json:"attached_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{17}
}

func (m *Tag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tag.Unmarshal(m, b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return xxx_messageInfo_Tag.Size(m)
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Tag) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Tag) GetAttachedBy() string {
	if m != nil {
		return m.AttachedBy
	}
	return ""
}

func (m *Tag) GetAttachedTs() *timestamp.Timestamp {
	if m != nil {
		return m.AttachedTs
	}
	return nil
}

type AttachTagsRequest struct {
	// The package that holds the instance we attach tags to.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The instance we attach tags to.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	// One or more tags to attach (order doesn't matter).
	Tags                 []*Tag   `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachTagsRequest) Reset()         { *m = AttachTagsRequest{} }
func (m *AttachTagsRequest) String() string { return proto.CompactTextString(m) }
func (*AttachTagsRequest) ProtoMessage()    {}
func (*AttachTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{18}
}

func (m *AttachTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachTagsRequest.Unmarshal(m, b)
}
func (m *AttachTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachTagsRequest.Marshal(b, m, deterministic)
}
func (m *AttachTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachTagsRequest.Merge(m, src)
}
func (m *AttachTagsRequest) XXX_Size() int {
	return xxx_messageInfo_AttachTagsRequest.Size(m)
}
func (m *AttachTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachTagsRequest proto.InternalMessageInfo

func (m *AttachTagsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *AttachTagsRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *AttachTagsRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type DetachTagsRequest struct {
	// The package that holds the instance we detach tags from.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The instance we detach tags from.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	// One or more tags to detach (order doesn't matter).
	Tags                 []*Tag   `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachTagsRequest) Reset()         { *m = DetachTagsRequest{} }
func (m *DetachTagsRequest) String() string { return proto.CompactTextString(m) }
func (*DetachTagsRequest) ProtoMessage()    {}
func (*DetachTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{19}
}

func (m *DetachTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachTagsRequest.Unmarshal(m, b)
}
func (m *DetachTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachTagsRequest.Marshal(b, m, deterministic)
}
func (m *DetachTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachTagsRequest.Merge(m, src)
}
func (m *DetachTagsRequest) XXX_Size() int {
	return xxx_messageInfo_DetachTagsRequest.Size(m)
}
func (m *DetachTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachTagsRequest proto.InternalMessageInfo

func (m *DetachTagsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *DetachTagsRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *DetachTagsRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ResolveVersionRequest struct {
	// The package that contains the instance we are resolving version of.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The version string to resolve, see ResolveVersion for details.
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveVersionRequest) Reset()         { *m = ResolveVersionRequest{} }
func (m *ResolveVersionRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveVersionRequest) ProtoMessage()    {}
func (*ResolveVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{20}
}

func (m *ResolveVersionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResolveVersionRequest.Unmarshal(m, b)
}
func (m *ResolveVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResolveVersionRequest.Marshal(b, m, deterministic)
}
func (m *ResolveVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveVersionRequest.Merge(m, src)
}
func (m *ResolveVersionRequest) XXX_Size() int {
	return xxx_messageInfo_ResolveVersionRequest.Size(m)
}
func (m *ResolveVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveVersionRequest proto.InternalMessageInfo

func (m *ResolveVersionRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *ResolveVersionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type GetInstanceURLRequest struct {
	// The package that holds the instance we want to get URL of.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The instance we want to get URL of.
	Instance             *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetInstanceURLRequest) Reset()         { *m = GetInstanceURLRequest{} }
func (m *GetInstanceURLRequest) String() string { return proto.CompactTextString(m) }
func (*GetInstanceURLRequest) ProtoMessage()    {}
func (*GetInstanceURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{21}
}

func (m *GetInstanceURLRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInstanceURLRequest.Unmarshal(m, b)
}
func (m *GetInstanceURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInstanceURLRequest.Marshal(b, m, deterministic)
}
func (m *GetInstanceURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInstanceURLRequest.Merge(m, src)
}
func (m *GetInstanceURLRequest) XXX_Size() int {
	return xxx_messageInfo_GetInstanceURLRequest.Size(m)
}
func (m *GetInstanceURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInstanceURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInstanceURLRequest proto.InternalMessageInfo

func (m *GetInstanceURLRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *GetInstanceURLRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

// Processor describes a state of some post-registration processing step
// performed on an instance.
type Processor struct {
	// Internal identifier of the processor, e.g. "cipd_client_binary:v1"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The state of this processor, see the enum.
	State Processor_State `protobuf:"varint,2,opt,name=state,proto3,enum=cipd.Processor_State" json:"state,omitempty"`
	// When the processor finished running (successfully or not).
	FinishedTs *timestamp.Timestamp `protobuf:"bytes,3,opt,name=finished_ts,json=finishedTs,proto3" json:"finished_ts,omitempty"`
	// For SUCCEEDED state, result of the processing.
	Result *_struct.Struct `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
	// For FAILED state, the error message.
	Error                string   `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Processor) Reset()         { *m = Processor{} }
func (m *Processor) String() string { return proto.CompactTextString(m) }
func (*Processor) ProtoMessage()    {}
func (*Processor) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{22}
}

func (m *Processor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Processor.Unmarshal(m, b)
}
func (m *Processor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Processor.Marshal(b, m, deterministic)
}
func (m *Processor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Processor.Merge(m, src)
}
func (m *Processor) XXX_Size() int {
	return xxx_messageInfo_Processor.Size(m)
}
func (m *Processor) XXX_DiscardUnknown() {
	xxx_messageInfo_Processor.DiscardUnknown(m)
}

var xxx_messageInfo_Processor proto.InternalMessageInfo

func (m *Processor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Processor) GetState() Processor_State {
	if m != nil {
		return m.State
	}
	return Processor_STATE_UNSPECIFIED
}

func (m *Processor) GetFinishedTs() *timestamp.Timestamp {
	if m != nil {
		return m.FinishedTs
	}
	return nil
}

func (m *Processor) GetResult() *_struct.Struct {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Processor) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type DescribeInstanceRequest struct {
	// The package that holds the instance we want to get the info for.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The instance we want to get the info for.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	// Whether the response should include "refs" field.
	DescribeRefs bool `protobuf:"varint,3,opt,name=describe_refs,json=describeRefs,proto3" json:"describe_refs,omitempty"`
	// Whether the response should include "tags" field.
	DescribeTags bool `protobuf:"varint,4,opt,name=describe_tags,json=describeTags,proto3" json:"describe_tags,omitempty"`
	// Whether the response should include "processors" field.
	DescribeProcessors   bool     `protobuf:"varint,5,opt,name=describe_processors,json=describeProcessors,proto3" json:"describe_processors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DescribeInstanceRequest) Reset()         { *m = DescribeInstanceRequest{} }
func (m *DescribeInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*DescribeInstanceRequest) ProtoMessage()    {}
func (*DescribeInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{23}
}

func (m *DescribeInstanceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeInstanceRequest.Unmarshal(m, b)
}
func (m *DescribeInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeInstanceRequest.Marshal(b, m, deterministic)
}
func (m *DescribeInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeInstanceRequest.Merge(m, src)
}
func (m *DescribeInstanceRequest) XXX_Size() int {
	return xxx_messageInfo_DescribeInstanceRequest.Size(m)
}
func (m *DescribeInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeInstanceRequest proto.InternalMessageInfo

func (m *DescribeInstanceRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *DescribeInstanceRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *DescribeInstanceRequest) GetDescribeRefs() bool {
	if m != nil {
		return m.DescribeRefs
	}
	return false
}

func (m *DescribeInstanceRequest) GetDescribeTags() bool {
	if m != nil {
		return m.DescribeTags
	}
	return false
}

func (m *DescribeInstanceRequest) GetDescribeProcessors() bool {
	if m != nil {
		return m.DescribeProcessors
	}
	return false
}

type DescribeInstanceResponse struct {
	// The instance with all output fields filled in.
	Instance *Instance `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
	// Refs pointing to the instance, sorted by modification time, most recent
	// first.
	//
	// Present only if the request has describe_refs == true.
	Refs []*Ref `protobuf:"bytes,2,rep,name=refs,proto3" json:"refs,omitempty"`
	// Tags attached to the instance, sorted by the tag key first, and then
	// by the timestamp (most recent first).
	//
	// Present only if the request has describe_tags == true.
	Tags []*Tag `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty"`
	// State of the processors that handled the instance (if any), sorted by their
	// ID.
	//
	// Present only if the request has describe_processors == true.
	Processors           []*Processor `protobuf:"bytes,4,rep,name=processors,proto3" json:"processors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DescribeInstanceResponse) Reset()         { *m = DescribeInstanceResponse{} }
func (m *DescribeInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*DescribeInstanceResponse) ProtoMessage()    {}
func (*DescribeInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{24}
}

func (m *DescribeInstanceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeInstanceResponse.Unmarshal(m, b)
}
func (m *DescribeInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeInstanceResponse.Marshal(b, m, deterministic)
}
func (m *DescribeInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeInstanceResponse.Merge(m, src)
}
func (m *DescribeInstanceResponse) XXX_Size() int {
	return xxx_messageInfo_DescribeInstanceResponse.Size(m)
}
func (m *DescribeInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeInstanceResponse proto.InternalMessageInfo

func (m *DescribeInstanceResponse) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *DescribeInstanceResponse) GetRefs() []*Ref {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *DescribeInstanceResponse) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DescribeInstanceResponse) GetProcessors() []*Processor {
	if m != nil {
		return m.Processors
	}
	return nil
}

type DescribeClientRequest struct {
	// The CIPD client package we want to get info about.
	//
	// For example 'infra/tools/cipd/linux-amd64'.
	Package string `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// The client instance we want to get the info about.
	Instance             *ObjectRef `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DescribeClientRequest) Reset()         { *m = DescribeClientRequest{} }
func (m *DescribeClientRequest) String() string { return proto.CompactTextString(m) }
func (*DescribeClientRequest) ProtoMessage()    {}
func (*DescribeClientRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{25}
}

func (m *DescribeClientRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeClientRequest.Unmarshal(m, b)
}
func (m *DescribeClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeClientRequest.Marshal(b, m, deterministic)
}
func (m *DescribeClientRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeClientRequest.Merge(m, src)
}
func (m *DescribeClientRequest) XXX_Size() int {
	return xxx_messageInfo_DescribeClientRequest.Size(m)
}
func (m *DescribeClientRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeClientRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeClientRequest proto.InternalMessageInfo

func (m *DescribeClientRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *DescribeClientRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

type DescribeClientResponse struct {
	// The instance with all output fields filled in.
	Instance *Instance `protobuf:"bytes,1,opt,name=instance,proto3" json:"instance,omitempty"`
	// Reference to the extracted client binary in the storage.
	//
	// The hash algo here always matches the algo used when uploading the client
	// package file.
	//
	// Clients should expect to find an algo here that they do not support (if
	// the server was updated to support a better algo). They should pick the best
	// algo they support from client_ref_aliases list and use it for validation.
	//
	// Thus this field is mostly FYI.
	ClientRef *ObjectRef `protobuf:"bytes,2,opt,name=client_ref,json=clientRef,proto3" json:"client_ref,omitempty"`
	// Signed URL pointing to the extracted client binary in the storage.
	ClientBinary *ObjectURL `protobuf:"bytes,3,opt,name=client_binary,json=clientBinary,proto3" json:"client_binary,omitempty"`
	// Size of the client binary in bytes.
	ClientSize int64 `protobuf:"varint,4,opt,name=client_size,json=clientSize,proto3" json:"client_size,omitempty"`
	// SHA1 digest of the client binary (as hex string).
	//
	// Used only by old clients and present here for backward compatibility
	// reasons.
	//
	// Newer clients must verify one of client_ref_aliases instead.
	LegacySha1 string `protobuf:"bytes,5,opt,name=legacy_sha1,json=legacySha1,proto3" json:"legacy_sha1,omitempty"`
	// Contains hashes of the client binary calculated using ALL algos supported
	// by the server at the time the client package was uploaded.
	//
	// The callers that want to verify the client binary hash should pick the best
	// algo they understand.
	//
	// The list at least includes 'client_ref' itself and SHA1 hash (matching
	// legacy_sha1). The order is undefined.
	ClientRefAliases     []*ObjectRef `protobuf:"bytes,6,rep,name=client_ref_aliases,json=clientRefAliases,proto3" json:"client_ref_aliases,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DescribeClientResponse) Reset()         { *m = DescribeClientResponse{} }
func (m *DescribeClientResponse) String() string { return proto.CompactTextString(m) }
func (*DescribeClientResponse) ProtoMessage()    {}
func (*DescribeClientResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70efefd016927455, []int{26}
}

func (m *DescribeClientResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeClientResponse.Unmarshal(m, b)
}
func (m *DescribeClientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeClientResponse.Marshal(b, m, deterministic)
}
func (m *DescribeClientResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeClientResponse.Merge(m, src)
}
func (m *DescribeClientResponse) XXX_Size() int {
	return xxx_messageInfo_DescribeClientResponse.Size(m)
}
func (m *DescribeClientResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeClientResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeClientResponse proto.InternalMessageInfo

func (m *DescribeClientResponse) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *DescribeClientResponse) GetClientRef() *ObjectRef {
	if m != nil {
		return m.ClientRef
	}
	return nil
}

func (m *DescribeClientResponse) GetClientBinary() *ObjectURL {
	if m != nil {
		return m.ClientBinary
	}
	return nil
}

func (m *DescribeClientResponse) GetClientSize() int64 {
	if m != nil {
		return m.ClientSize
	}
	return 0
}

func (m *DescribeClientResponse) GetLegacySha1() string {
	if m != nil {
		return m.LegacySha1
	}
	return ""
}

func (m *DescribeClientResponse) GetClientRefAliases() []*ObjectRef {
	if m != nil {
		return m.ClientRefAliases
	}
	return nil
}

func init() {
	proto.RegisterEnum("cipd.Role", Role_name, Role_value)
	proto.RegisterEnum("cipd.RegistrationStatus", RegistrationStatus_name, RegistrationStatus_value)
	proto.RegisterEnum("cipd.Processor_State", Processor_State_name, Processor_State_value)
	proto.RegisterType((*PrefixRequest)(nil), "cipd.PrefixRequest")
	proto.RegisterType((*PrefixMetadata)(nil), "cipd.PrefixMetadata")
	proto.RegisterType((*PrefixMetadata_ACL)(nil), "cipd.PrefixMetadata.ACL")
	proto.RegisterType((*InheritedPrefixMetadata)(nil), "cipd.InheritedPrefixMetadata")
	proto.RegisterType((*RolesInPrefixResponse)(nil), "cipd.RolesInPrefixResponse")
	proto.RegisterType((*RolesInPrefixResponse_RoleInPrefix)(nil), "cipd.RolesInPrefixResponse.RoleInPrefix")
	proto.RegisterType((*ListPrefixRequest)(nil), "cipd.ListPrefixRequest")
	proto.RegisterType((*ListPrefixResponse)(nil), "cipd.ListPrefixResponse")
	proto.RegisterType((*PackageRequest)(nil), "cipd.PackageRequest")
	proto.RegisterType((*Instance)(nil), "cipd.Instance")
	proto.RegisterType((*RegisterInstanceResponse)(nil), "cipd.RegisterInstanceResponse")
	proto.RegisterType((*ListInstancesRequest)(nil), "cipd.ListInstancesRequest")
	proto.RegisterType((*ListInstancesResponse)(nil), "cipd.ListInstancesResponse")
	proto.RegisterType((*SearchInstancesRequest)(nil), "cipd.SearchInstancesRequest")
	proto.RegisterType((*SearchInstancesResponse)(nil), "cipd.SearchInstancesResponse")
	proto.RegisterType((*Ref)(nil), "cipd.Ref")
	proto.RegisterType((*DeleteRefRequest)(nil), "cipd.DeleteRefRequest")
	proto.RegisterType((*ListRefsRequest)(nil), "cipd.ListRefsRequest")
	proto.RegisterType((*ListRefsResponse)(nil), "cipd.ListRefsResponse")
	proto.RegisterType((*Tag)(nil), "cipd.Tag")
	proto.RegisterType((*AttachTagsRequest)(nil), "cipd.AttachTagsRequest")
	proto.RegisterType((*DetachTagsRequest)(nil), "cipd.DetachTagsRequest")
	proto.RegisterType((*ResolveVersionRequest)(nil), "cipd.ResolveVersionRequest")
	proto.RegisterType((*GetInstanceURLRequest)(nil), "cipd.GetInstanceURLRequest")
	proto.RegisterType((*Processor)(nil), "cipd.Processor")
	proto.RegisterType((*DescribeInstanceRequest)(nil), "cipd.DescribeInstanceRequest")
	proto.RegisterType((*DescribeInstanceResponse)(nil), "cipd.DescribeInstanceResponse")
	proto.RegisterType((*DescribeClientRequest)(nil), "cipd.DescribeClientRequest")
	proto.RegisterType((*DescribeClientResponse)(nil), "cipd.DescribeClientResponse")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/cipd/api/cipd/v1/repo.proto", fileDescriptor_70efefd016927455)
}

var fileDescriptor_70efefd016927455 = []byte{
	// 1744 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcd, 0x6e, 0x1b, 0xc9,
	0x11, 0x0e, 0x7f, 0x24, 0x8b, 0x45, 0x91, 0xa2, 0xda, 0xfa, 0x21, 0x68, 0xcb, 0x12, 0xc6, 0x48,
	0x22, 0xd8, 0x0b, 0x72, 0xad, 0xe4, 0x12, 0x18, 0xb6, 0x43, 0x89, 0x63, 0x99, 0x58, 0x46, 0x52,
	0x9a, 0x64, 0x16, 0xc9, 0x21, 0x44, 0x6b, 0xd8, 0xa4, 0x26, 0x26, 0x67, 0x26, 0xd3, 0x4d, 0x61,
	0xb9, 0x2f, 0x90, 0x43, 0x90, 0x5b, 0xae, 0x79, 0x82, 0xe4, 0x1a, 0xe4, 0x96, 0x6b, 0x1e, 0x22,
	0x2f, 0x13, 0xf4, 0xdf, 0x90, 0x1c, 0x0e, 0x25, 0x79, 0xd7, 0xc1, 0xde, 0x66, 0xbe, 0xfe, 0xaa,
	0xab, 0xaa, 0xbb, 0xaa, 0xba, 0x0a, 0xbe, 0x1c, 0xfa, 0x55, 0xe7, 0x26, 0xf4, 0xc7, 0xee, 0x64,
	0x5c, 0xf5, 0xc3, 0x61, 0x6d, 0x34, 0x71, 0xdc, 0x9a, 0xe3, 0x06, 0xfd, 0x1a, 0x09, 0xf4, 0xc7,
	0xed, 0xab, 0x5a, 0x48, 0x03, 0xbf, 0x1a, 0x84, 0x3e, 0xf7, 0x51, 0x56, 0x60, 0x95, 0x27, 0x43,
	0xdf, 0x1f, 0x8e, 0x68, 0x4d, 0x62, 0xd7, 0x93, 0x41, 0x8d, 0x8e, 0x03, 0x3e, 0x55, 0x94, 0xca,
	0xd3, 0xf8, 0x22, 0xe3, 0xe1, 0xc4, 0xe1, 0x7a, 0xf5, 0x30, 0xbe, 0xca, 0xdd, 0x31, 0x65, 0x9c,
	0x8c, 0x03, 0x4d, 0xa8, 0x3d, 0xcc, 0x26, 0x87, 0x30, 0x25, 0x60, 0xfd, 0x14, 0x0a, 0x57, 0x21,
	0x1d, 0xb8, 0xdf, 0x60, 0xfa, 0xc7, 0x09, 0x65, 0x1c, 0xed, 0xc1, 0x7a, 0x20, 0x81, 0x72, 0xea,
	0x28, 0x75, 0x9c, 0xc3, 0xfa, 0xcf, 0xfa, 0x5b, 0x1a, 0x8a, 0x8a, 0xf9, 0x2b, 0xca, 0x49, 0x9f,
	0x70, 0xb2, 0x8a, 0x8a, 0x8e, 0x20, 0x3f, 0x70, 0xbd, 0x21, 0x0d, 0x83, 0xd0, 0xf5, 0x78, 0x39,
	0x2d, 0x17, 0xe7, 0x21, 0xf4, 0x1a, 0xf2, 0x93, 0xa0, 0x4f, 0x38, 0xed, 0x09, 0x07, 0xca, 0x99,
	0xa3, 0xd4, 0x71, 0xfe, 0xa4, 0x52, 0x55, 0xde, 0x55, 0x8d, 0x77, 0xd5, 0x8e, 0xf1, 0x0e, 0x83,
	0xa2, 0x0b, 0x00, 0x1d, 0x46, 0xc2, 0x13, 0x46, 0xc3, 0x72, 0x56, 0x6e, 0xaf, 0x09, 0x5d, 0x46,
	0x43, 0xf4, 0x05, 0x64, 0x89, 0x33, 0x62, 0xe5, 0xb5, 0xa3, 0xcc, 0x71, 0xfe, 0xa4, 0x5c, 0x15,
	0x5e, 0x57, 0x17, 0x6d, 0xaf, 0xd6, 0xcf, 0x5a, 0x58, 0xb2, 0x2a, 0x36, 0x64, 0xea, 0x67, 0x2d,
	0xf4, 0x0c, 0xb2, 0xa1, 0x3f, 0xa2, 0xd2, 0x95, 0xe2, 0x09, 0x28, 0x21, 0xec, 0x8f, 0x28, 0x96,
	0x38, 0x7a, 0x06, 0x20, 0x6c, 0x77, 0xdc, 0x80, 0x8c, 0x58, 0x39, 0x7d, 0x94, 0x11, 0x4a, 0x67,
	0x88, 0xd5, 0x83, 0xfd, 0xa6, 0x77, 0x43, 0x43, 0x97, 0xd3, 0x7e, 0xec, 0x9c, 0x1a, 0xf0, 0x38,
	0xa0, 0x61, 0x4f, 0x9d, 0x4e, 0x6f, 0xac, 0xe1, 0x72, 0x4a, 0x9a, 0xb7, 0x93, 0x64, 0x1e, 0xde,
	0x0e, 0x68, 0xb8, 0x08, 0x59, 0x7f, 0x4a, 0xc1, 0xae, 0xb0, 0x87, 0x35, 0x3d, 0x73, 0x63, 0x2c,
	0xf0, 0x3d, 0x46, 0xd1, 0x5b, 0x58, 0x13, 0x26, 0x32, 0xbd, 0xe3, 0xf1, 0xcc, 0xf6, 0x25, 0xae,
	0x44, 0x23, 0x50, 0x89, 0x55, 0xaa, 0xb0, 0x39, 0x0f, 0xdf, 0x77, 0x14, 0x56, 0x00, 0xdb, 0x2d,
	0x97, 0xf1, 0x07, 0xc5, 0x0d, 0x7a, 0x0a, 0xb9, 0x90, 0x3a, 0x93, 0x90, 0xb9, 0xb7, 0x54, 0x86,
	0xc2, 0x06, 0x9e, 0x01, 0xe8, 0xc7, 0x50, 0x74, 0x3d, 0x67, 0x34, 0xe9, 0xd3, 0xde, 0x8d, 0xdb,
	0xef, 0x53, 0x4f, 0xc6, 0xc2, 0x06, 0x2e, 0x68, 0xf4, 0x83, 0x04, 0xad, 0x16, 0xa0, 0x79, 0x8d,
	0xda, 0xef, 0x0a, 0x6c, 0x04, 0xc4, 0xf9, 0x48, 0x86, 0xda, 0xf5, 0x1c, 0x8e, 0xfe, 0xe5, 0x9a,
	0x64, 0x53, 0x73, 0x59, 0xd1, 0xbf, 0xf5, 0x02, 0x8a, 0x57, 0x8a, 0x67, 0x8c, 0x2f, 0xc3, 0x23,
	0x2d, 0xa9, 0xad, 0x37, 0xbf, 0xd6, 0xbf, 0x52, 0xb0, 0xd1, 0xf4, 0x18, 0x27, 0x9e, 0x43, 0x57,
	0xd3, 0xd0, 0x4b, 0xd8, 0x70, 0x35, 0x4b, 0x3a, 0x99, 0x3f, 0xd9, 0x52, 0xc7, 0x76, 0x79, 0xfd,
	0x07, 0xea, 0x70, 0x4c, 0x07, 0x38, 0x22, 0xa0, 0xe7, 0x50, 0x08, 0xe9, 0xd0, 0x65, 0x9c, 0x86,
	0xb4, 0xdf, 0xbb, 0x9e, 0x4a, 0x9f, 0x73, 0x78, 0x73, 0x06, 0x9e, 0x4e, 0xd1, 0xbb, 0x05, 0x12,
	0x67, 0x32, 0xce, 0xef, 0x4e, 0x92, 0xb9, 0x0d, 0x3a, 0xcc, 0xfa, 0x47, 0x0a, 0xca, 0x58, 0x03,
	0xc6, 0x83, 0xe8, 0xe8, 0xbe, 0x84, 0x75, 0xc6, 0x09, 0x9f, 0x30, 0x7d, 0xc9, 0x3a, 0x49, 0x14,
	0x3f, 0x24, 0xdc, 0xf5, 0xbd, 0xb6, 0x5c, 0xc7, 0x9a, 0x87, 0x5e, 0x2c, 0x79, 0x58, 0x54, 0x32,
	0xd1, 0xde, 0x33, 0x07, 0x4f, 0x20, 0x37, 0x09, 0x46, 0x3e, 0xe9, 0xf7, 0xfc, 0x40, 0x27, 0xf7,
	0xae, 0x22, 0x77, 0x25, 0x7c, 0x19, 0x50, 0xa5, 0x03, 0x6f, 0x4c, 0x34, 0x60, 0x8d, 0x60, 0x47,
	0x5c, 0xb1, 0xd9, 0x8d, 0xdd, 0x7b, 0x35, 0xe8, 0x09, 0xe4, 0x02, 0x32, 0xa4, 0x3d, 0xe6, 0x7e,
	0x4b, 0xcb, 0x3b, 0x47, 0xa9, 0xe3, 0x35, 0x71, 0xff, 0x43, 0xda, 0x76, 0xbf, 0xa5, 0xe8, 0x00,
	0x40, 0x2e, 0x72, 0xff, 0x23, 0xf5, 0xca, 0xbb, 0x52, 0x52, 0xd2, 0x3b, 0x02, 0xb0, 0xc6, 0xb0,
	0x1b, 0xd3, 0xa6, 0x0f, 0xe6, 0x0b, 0xc8, 0x19, 0x37, 0x4c, 0x3e, 0xc5, 0xfd, 0x9c, 0x11, 0xd0,
	0x4f, 0x60, 0xcb, 0xa3, 0xdf, 0xf0, 0xde, 0x9c, 0xaa, 0x1d, 0xa9, 0xaa, 0x20, 0xe0, 0xab, 0x48,
	0xdd, 0x5f, 0x52, 0xb0, 0xd7, 0xa6, 0x24, 0x74, 0x6e, 0x3e, 0xc1, 0xbf, 0x03, 0xc8, 0x72, 0x32,
	0x54, 0xe1, 0x9b, 0x3f, 0xc9, 0x29, 0x2b, 0x3a, 0x64, 0x88, 0x25, 0xfc, 0xbd, 0xdc, 0xf7, 0x61,
	0x7f, 0xc9, 0x9c, 0xff, 0xeb, 0x01, 0xfc, 0x3b, 0x05, 0x19, 0x4c, 0x07, 0x08, 0x41, 0xd6, 0x23,
	0x63, 0xe3, 0xaa, 0xfc, 0x9e, 0x3f, 0x81, 0xf4, 0xea, 0xac, 0xca, 0xdc, 0x97, 0x55, 0x87, 0x90,
	0x1f, 0xfb, 0x7d, 0x77, 0xe0, 0xaa, 0x9c, 0xd2, 0xcf, 0x82, 0x81, 0x4e, 0xa7, 0xe2, 0xd1, 0x89,
	0x08, 0x5c, 0xbc, 0x0e, 0xf7, 0x3e, 0x3a, 0x86, 0xde, 0x61, 0xd6, 0x2f, 0xa1, 0xd4, 0xa0, 0x23,
	0xca, 0xa9, 0x50, 0xaa, 0xaf, 0xee, 0x93, 0x9c, 0xb1, 0x5e, 0xc2, 0x96, 0x08, 0x39, 0x4c, 0x07,
	0xf7, 0xdf, 0xbd, 0xf5, 0x0a, 0x4a, 0x33, 0xb2, 0xbe, 0x99, 0x03, 0xc8, 0x86, 0x74, 0x60, 0x2e,
	0x25, 0x67, 0x32, 0x76, 0x80, 0x25, 0x6c, 0xfd, 0x39, 0x05, 0x99, 0x0e, 0x19, 0xa2, 0x12, 0x64,
	0x3e, 0xd2, 0xa9, 0xde, 0x50, 0x7c, 0xa2, 0x1d, 0x58, 0xbb, 0x25, 0xa3, 0x89, 0xb1, 0x48, 0xfd,
	0x88, 0xf3, 0x22, 0x9c, 0x13, 0xe7, 0x66, 0xbe, 0x06, 0x81, 0x81, 0xd4, 0x79, 0x45, 0x84, 0x07,
	0xd5, 0x9f, 0x48, 0xb8, 0xc3, 0xac, 0x29, 0x6c, 0xd7, 0xe5, 0x5f, 0x87, 0x0c, 0x1f, 0x10, 0xeb,
	0x9f, 0x54, 0x3f, 0x4d, 0x62, 0x64, 0x12, 0x13, 0x43, 0xa8, 0x6e, 0xd0, 0x1f, 0x46, 0xf5, 0x57,
	0xb0, 0x8b, 0x29, 0xf3, 0x47, 0xb7, 0xf4, 0x37, 0x34, 0x64, 0xa2, 0xc0, 0xdd, 0xab, 0xbe, 0x0c,
	0x8f, 0x6e, 0x15, 0xd7, 0x04, 0x8c, 0xfe, 0xb5, 0x7e, 0x0f, 0xbb, 0xe7, 0x34, 0x2a, 0x51, 0x5d,
	0xdc, 0xfa, 0xbc, 0xbe, 0x58, 0x7f, 0x4d, 0x43, 0xee, 0x2a, 0xf4, 0x1d, 0xca, 0x98, 0x1f, 0xa2,
	0x22, 0xa4, 0xdd, 0xbe, 0xde, 0x2f, 0xed, 0xf6, 0xd1, 0x4b, 0x58, 0x13, 0x95, 0x5f, 0xed, 0x53,
	0x34, 0xf5, 0x3b, 0xe2, 0x57, 0xc5, 0xf3, 0x40, 0xb1, 0xe2, 0x88, 0x50, 0x19, 0xb8, 0x9e, 0xcb,
	0x74, 0xa8, 0x3c, 0xa0, 0x9f, 0x33, 0xf4, 0x0e, 0x43, 0x35, 0x58, 0x0f, 0x29, 0x9b, 0x8c, 0xb8,
	0x0e, 0xb1, 0xfd, 0x25, 0xb9, 0xb6, 0xec, 0x81, 0xb1, 0xa6, 0x89, 0x78, 0xa6, 0x61, 0xe8, 0x87,
	0x32, 0x85, 0x73, 0x58, 0xfd, 0x58, 0xef, 0x61, 0x4d, 0xda, 0x84, 0x76, 0x61, 0xbb, 0xdd, 0xa9,
	0x77, 0xec, 0x5e, 0xf7, 0xa2, 0x7d, 0x65, 0x9f, 0x35, 0xdf, 0x37, 0xed, 0x46, 0xe9, 0x47, 0x28,
	0x0f, 0x8f, 0xae, 0xec, 0x8b, 0x46, 0xf3, 0xe2, 0xbc, 0x94, 0x42, 0x05, 0xc8, 0xb5, 0xbb, 0x67,
	0x67, 0xb6, 0xdd, 0xb0, 0x1b, 0xa5, 0x34, 0x02, 0x58, 0x7f, 0x5f, 0x6f, 0xb6, 0xec, 0x46, 0x29,
	0x63, 0xfd, 0x37, 0x05, 0xfb, 0x0d, 0xca, 0x9c, 0xd0, 0xbd, 0xa6, 0xb3, 0x77, 0xf3, 0xb3, 0x46,
	0xd1, 0x73, 0x28, 0xf4, 0xb5, 0x86, 0x9e, 0x4c, 0x69, 0xd5, 0xf4, 0x6c, 0x1a, 0x50, 0xa4, 0xfd,
	0x02, 0x49, 0xc6, 0x5c, 0x76, 0x91, 0x24, 0xa2, 0x1b, 0xd5, 0xe0, 0x71, 0x44, 0x0a, 0xcc, 0xdd,
	0xa8, 0xda, 0xb6, 0x81, 0x91, 0x59, 0x8a, 0x6e, 0x8d, 0x59, 0xff, 0x4c, 0x41, 0x79, 0xd9, 0x3b,
	0x5d, 0x61, 0xe6, 0xdf, 0xf8, 0xd4, 0x3d, 0x6f, 0xbc, 0xa9, 0x46, 0xe9, 0xc4, 0x6a, 0x74, 0x4f,
	0xa2, 0xa0, 0x9a, 0xe8, 0xa6, 0x23, 0x73, 0xb3, 0x92, 0xb4, 0x15, 0x0b, 0x31, 0x3c, 0x47, 0x11,
	0xc9, 0x60, 0xcc, 0x3e, 0x1b, 0xb9, 0xd4, 0xe3, 0x9f, 0x39, 0x19, 0xfe, 0x9e, 0x86, 0xbd, 0xb8,
	0x82, 0xef, 0x70, 0x2a, 0x55, 0x00, 0x47, 0x4a, 0x8b, 0x7b, 0x5d, 0xa5, 0x35, 0xe7, 0x68, 0x05,
	0x03, 0xf4, 0x73, 0x28, 0x68, 0xfe, 0xb5, 0xeb, 0x91, 0x70, 0x9a, 0xf4, 0xcc, 0x89, 0xcc, 0xdf,
	0x54, 0xac, 0x53, 0x49, 0x12, 0xa5, 0x5b, 0x4b, 0xc9, 0xc7, 0x5f, 0x04, 0x46, 0x06, 0x6b, 0xc5,
	0xf2, 0xf9, 0x3f, 0x84, 0xfc, 0x88, 0x0e, 0x89, 0x33, 0xed, 0xb1, 0x1b, 0xf2, 0x4a, 0xe7, 0x09,
	0x28, 0xa8, 0x7d, 0x43, 0x5e, 0xa1, 0x37, 0x80, 0x66, 0x76, 0xf6, 0xc8, 0xc8, 0x25, 0x8c, 0xb2,
	0xf2, 0xfa, 0xfc, 0x3d, 0xcc, 0xec, 0x2d, 0x45, 0xf6, 0xd6, 0x15, 0xf1, 0xc5, 0x3b, 0xc8, 0x8a,
	0x79, 0x00, 0xed, 0x40, 0x09, 0x5f, 0xb6, 0xe2, 0x99, 0x06, 0xb0, 0x8e, 0xed, 0x7a, 0xc3, 0xc6,
	0xa5, 0x94, 0xf8, 0xfe, 0x1a, 0x37, 0x3b, 0x36, 0x2e, 0xa5, 0x51, 0x0e, 0xd6, 0x2e, 0xbf, 0xbe,
	0xb0, 0x71, 0x29, 0xf3, 0x82, 0x01, 0x5a, 0xee, 0x35, 0xd1, 0x73, 0x38, 0xc4, 0xf6, 0x79, 0xb3,
	0xdd, 0xc1, 0xf5, 0x4e, 0xf3, 0xf2, 0xa2, 0x27, 0xd2, 0xb8, 0xdb, 0x8e, 0xed, 0x5e, 0x04, 0x50,
	0x24, 0x1b, 0xdb, 0x8d, 0x52, 0x0a, 0xed, 0x01, 0xaa, 0xb7, 0x84, 0xbe, 0xdf, 0xf6, 0xe6, 0xf0,
	0x34, 0x2a, 0xc1, 0xe6, 0xc5, 0x65, 0xa7, 0xd7, 0xbd, 0x6a, 0x5d, 0xd6, 0x45, 0x96, 0x67, 0x4e,
	0xfe, 0x03, 0x00, 0x98, 0x06, 0x3e, 0x73, 0xb9, 0x1f, 0x4e, 0xd1, 0x5b, 0xd8, 0x3e, 0xa7, 0x3c,
	0x36, 0xab, 0x3d, 0x9e, 0x1f, 0xc7, 0x74, 0x8c, 0x55, 0x12, 0x67, 0x34, 0x74, 0x05, 0x15, 0x59,
	0x9f, 0x93, 0x87, 0xbe, 0xc4, 0x8d, 0x0e, 0x4c, 0xe0, 0x24, 0xcb, 0x9c, 0xc2, 0x4e, 0x57, 0x8e,
	0xb1, 0x31, 0x3c, 0x51, 0xff, 0x0a, 0xab, 0x1a, 0x50, 0x3a, 0xa7, 0x7c, 0x61, 0xf8, 0x4b, 0xb6,
	0xe5, 0xc9, 0x1d, 0x63, 0x22, 0x7a, 0x07, 0x30, 0x1b, 0xb8, 0xd0, 0xbe, 0xa2, 0x2e, 0x0d, 0x7d,
	0x95, 0xf2, 0xf2, 0x82, 0xde, 0xe0, 0x35, 0xe4, 0x3f, 0xb8, 0x7d, 0xaa, 0xe7, 0xac, 0xc8, 0x83,
	0x85, 0xb1, 0xab, 0xb2, 0xb7, 0x54, 0xe9, 0xed, 0x71, 0xc0, 0xa7, 0xe8, 0x0d, 0x14, 0xba, 0xde,
	0xcd, 0xf7, 0x11, 0x57, 0xbd, 0xda, 0x77, 0x13, 0x3f, 0x85, 0x52, 0x7c, 0x6e, 0x42, 0xb1, 0x8c,
	0xaf, 0x3c, 0x9b, 0x9f, 0x97, 0x12, 0xe6, 0xab, 0x0f, 0x50, 0x58, 0x98, 0x2f, 0x50, 0x65, 0x76,
	0x52, 0xf1, 0x11, 0xc0, 0xdc, 0x44, 0xf2, 0x40, 0x72, 0x01, 0x5b, 0xb1, 0x56, 0x1d, 0x3d, 0x55,
	0xfc, 0xe4, 0x81, 0xc2, 0xc4, 0xd8, 0xaa, 0xfe, 0xbe, 0x0a, 0xb9, 0xb3, 0x90, 0x12, 0xd9, 0xc8,
	0xa2, 0x59, 0xd9, 0x5e, 0x79, 0x1a, 0xaf, 0x21, 0x17, 0x35, 0xbe, 0x68, 0x4f, 0xf1, 0xe3, 0x9d,
	0xf0, 0x4a, 0xe1, 0x5f, 0xc0, 0x86, 0x69, 0x63, 0xd1, 0xee, 0xcc, 0xcb, 0xb9, 0x1e, 0xb8, 0xb2,
	0x17, 0x87, 0xb5, 0x9d, 0x6f, 0x00, 0x66, 0x0d, 0xa4, 0x89, 0xc0, 0xa5, 0x96, 0xf2, 0x8e, 0x18,
	0x80, 0x59, 0x13, 0x68, 0xc4, 0x97, 0xda, 0xc2, 0x3b, 0xc4, 0x8b, 0x8b, 0x8d, 0x1c, 0x32, 0xe9,
	0x92, 0xd4, 0xde, 0x55, 0x62, 0xe1, 0x81, 0xde, 0x42, 0x71, 0xb1, 0x75, 0x33, 0xe2, 0x89, 0x0d,
	0x5d, 0x25, 0x5e, 0xee, 0xd1, 0xaf, 0xc5, 0xb4, 0xb1, 0xf8, 0x48, 0xa3, 0x03, 0xe3, 0x43, 0x62,
	0x6b, 0x62, 0x22, 0x72, 0xe5, 0xdb, 0xfe, 0x15, 0x14, 0x17, 0xdf, 0x37, 0x63, 0x52, 0xe2, 0xb3,
	0x5a, 0x79, 0x9a, 0xbc, 0xa8, 0x36, 0x3b, 0x5d, 0xfb, 0x5d, 0x86, 0x04, 0xee, 0xf5, 0xba, 0x3c,
	0xb5, 0x9f, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x82, 0x63, 0xe5, 0x0a, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RepositoryClient is the client API for Repository service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RepositoryClient interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires OWNER access (since it returns
	// a lot of detailed information), GetRolesInPrefix can be called by anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   * {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   * {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// DeletePackage removes the package (along with all its instances, tags, refs
	// etc) from the repository.
	//
	// There's no undo. Once the package is deleted, it is gone forever.
	//
	// This operation has a potential to break various pinned historical CIPD
	// ensure files and thus should not be used casually, only in extreme cases.
	// Consider just hiding the package instead of deleting it.
	//
	// For the reasons above, the operation requires admin access: only owners of
	// the repository root can delete packages.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a root owner.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeletePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// Returns package instances that have all given tags attached.
	//
	// Queries only instances of some particular package (i.e. this is not a
	// global query).
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	SearchInstances(ctx context.Context, in *SearchInstancesRequest, opts ...grpc.CallOption) (*SearchInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   * A string-encoded instance ID, e.g. "abcdef....".
	//   * A ref name, e.g. "latest".
	//   * A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such package or version.
	//   FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error)
	// Produces a signed URL that can be used to fetch the package instance file.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such instance.
	GetInstanceURL(ctx context.Context, in *GetInstanceURLRequest, opts ...grpc.CallOption) (*ObjectURL, error)
	// Returns information about a package instance.
	//
	// Depending on fields set in the request, returns details such as when the
	// instance was registered and by whom, refs pointing to it, tags attached to
	// it, state of all processors that handled it (if any).
	//
	// May also be used as a simple instance presence check, if all describe_*
	// fields in the request are false. If the request succeeds, then the
	// instance exists.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the instance doesn't exist.
	DescribeInstance(ctx context.Context, in *DescribeInstanceRequest, opts ...grpc.CallOption) (*DescribeInstanceResponse, error)
	// Returns information about a CIPD client package.
	//
	// Used by the client self-update procedure.
	//
	// Returns:
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	DescribeClient(ctx context.Context, in *DescribeClientRequest, opts ...grpc.CallOption) (*DescribeClientResponse, error)
}
type repositoryPRPCClient struct {
	client *prpc.Client
}

func NewRepositoryPRPCClient(client *prpc.Client) RepositoryClient {
	return &repositoryPRPCClient{client}
}

func (c *repositoryPRPCClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetInheritedPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "UpdatePrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	out := new(RolesInPrefixResponse)
	err := c.client.Call(ctx, "cipd.Repository", "GetRolesInPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error) {
	out := new(ListPrefixResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "HidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "UnhidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DeletePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "DeletePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.client.Call(ctx, "cipd.Repository", "RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) SearchInstances(ctx context.Context, in *SearchInstancesRequest, opts ...grpc.CallOption) (*SearchInstancesResponse, error) {
	out := new(SearchInstancesResponse)
	err := c.client.Call(ctx, "cipd.Repository", "SearchInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "CreateRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "DeleteRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error) {
	out := new(ListRefsResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListRefs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "AttachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "DetachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.client.Call(ctx, "cipd.Repository", "ResolveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetInstanceURL(ctx context.Context, in *GetInstanceURLRequest, opts ...grpc.CallOption) (*ObjectURL, error) {
	out := new(ObjectURL)
	err := c.client.Call(ctx, "cipd.Repository", "GetInstanceURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DescribeInstance(ctx context.Context, in *DescribeInstanceRequest, opts ...grpc.CallOption) (*DescribeInstanceResponse, error) {
	out := new(DescribeInstanceResponse)
	err := c.client.Call(ctx, "cipd.Repository", "DescribeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DescribeClient(ctx context.Context, in *DescribeClientRequest, opts ...grpc.CallOption) (*DescribeClientResponse, error) {
	out := new(DescribeClientResponse)
	err := c.client.Call(ctx, "cipd.Repository", "DescribeClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type repositoryClient struct {
	cc *grpc.ClientConn
}

func NewRepositoryClient(cc *grpc.ClientConn) RepositoryClient {
	return &repositoryClient{cc}
}

func (c *repositoryClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetInheritedPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/UpdatePrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	out := new(RolesInPrefixResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetRolesInPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error) {
	out := new(ListPrefixResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/HidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/UnhidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DeletePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DeletePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) SearchInstances(ctx context.Context, in *SearchInstancesRequest, opts ...grpc.CallOption) (*SearchInstancesResponse, error) {
	out := new(SearchInstancesResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/SearchInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/CreateRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DeleteRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error) {
	out := new(ListRefsResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListRefs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/AttachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DetachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ResolveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInstanceURL(ctx context.Context, in *GetInstanceURLRequest, opts ...grpc.CallOption) (*ObjectURL, error) {
	out := new(ObjectURL)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetInstanceURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DescribeInstance(ctx context.Context, in *DescribeInstanceRequest, opts ...grpc.CallOption) (*DescribeInstanceResponse, error) {
	out := new(DescribeInstanceResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DescribeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DescribeClient(ctx context.Context, in *DescribeClientRequest, opts ...grpc.CallOption) (*DescribeClientResponse, error) {
	out := new(DescribeClientResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DescribeClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RepositoryServer is the server API for Repository service.
type RepositoryServer interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(context.Context, *PrefixRequest) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(context.Context, *PrefixRequest) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(context.Context, *PrefixMetadata) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires OWNER access (since it returns
	// a lot of detailed information), GetRolesInPrefix can be called by anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(context.Context, *PrefixRequest) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   * {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   * {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(context.Context, *ListPrefixRequest) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(context.Context, *PackageRequest) (*empty.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(context.Context, *PackageRequest) (*empty.Empty, error)
	// DeletePackage removes the package (along with all its instances, tags, refs
	// etc) from the repository.
	//
	// There's no undo. Once the package is deleted, it is gone forever.
	//
	// This operation has a potential to break various pinned historical CIPD
	// ensure files and thus should not be used casually, only in extreme cases.
	// Consider just hiding the package instead of deleting it.
	//
	// For the reasons above, the operation requires admin access: only owners of
	// the repository root can delete packages.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a root owner.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeletePackage(context.Context, *PackageRequest) (*empty.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(context.Context, *Instance) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// Returns package instances that have all given tags attached.
	//
	// Queries only instances of some particular package (i.e. this is not a
	// global query).
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	SearchInstances(context.Context, *SearchInstancesRequest) (*SearchInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	CreateRef(context.Context, *Ref) (*empty.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeleteRef(context.Context, *DeleteRefRequest) (*empty.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	ListRefs(context.Context, *ListRefsRequest) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	AttachTags(context.Context, *AttachTagsRequest) (*empty.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(context.Context, *DetachTagsRequest) (*empty.Empty, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   * A string-encoded instance ID, e.g. "abcdef....".
	//   * A ref name, e.g. "latest".
	//   * A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such package or version.
	//   FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(context.Context, *ResolveVersionRequest) (*Instance, error)
	// Produces a signed URL that can be used to fetch the package instance file.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such instance.
	GetInstanceURL(context.Context, *GetInstanceURLRequest) (*ObjectURL, error)
	// Returns information about a package instance.
	//
	// Depending on fields set in the request, returns details such as when the
	// instance was registered and by whom, refs pointing to it, tags attached to
	// it, state of all processors that handled it (if any).
	//
	// May also be used as a simple instance presence check, if all describe_*
	// fields in the request are false. If the request succeeds, then the
	// instance exists.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the instance doesn't exist.
	DescribeInstance(context.Context, *DescribeInstanceRequest) (*DescribeInstanceResponse, error)
	// Returns information about a CIPD client package.
	//
	// Used by the client self-update procedure.
	//
	// Returns:
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	DescribeClient(context.Context, *DescribeClientRequest) (*DescribeClientResponse, error)
}

// UnimplementedRepositoryServer can be embedded to have forward compatible implementations.
type UnimplementedRepositoryServer struct {
}

func (*UnimplementedRepositoryServer) GetPrefixMetadata(ctx context.Context, req *PrefixRequest) (*PrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrefixMetadata not implemented")
}
func (*UnimplementedRepositoryServer) GetInheritedPrefixMetadata(ctx context.Context, req *PrefixRequest) (*InheritedPrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInheritedPrefixMetadata not implemented")
}
func (*UnimplementedRepositoryServer) UpdatePrefixMetadata(ctx context.Context, req *PrefixMetadata) (*PrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrefixMetadata not implemented")
}
func (*UnimplementedRepositoryServer) GetRolesInPrefix(ctx context.Context, req *PrefixRequest) (*RolesInPrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolesInPrefix not implemented")
}
func (*UnimplementedRepositoryServer) ListPrefix(ctx context.Context, req *ListPrefixRequest) (*ListPrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrefix not implemented")
}
func (*UnimplementedRepositoryServer) HidePackage(ctx context.Context, req *PackageRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HidePackage not implemented")
}
func (*UnimplementedRepositoryServer) UnhidePackage(ctx context.Context, req *PackageRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnhidePackage not implemented")
}
func (*UnimplementedRepositoryServer) DeletePackage(ctx context.Context, req *PackageRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePackage not implemented")
}
func (*UnimplementedRepositoryServer) RegisterInstance(ctx context.Context, req *Instance) (*RegisterInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterInstance not implemented")
}
func (*UnimplementedRepositoryServer) ListInstances(ctx context.Context, req *ListInstancesRequest) (*ListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (*UnimplementedRepositoryServer) SearchInstances(ctx context.Context, req *SearchInstancesRequest) (*SearchInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchInstances not implemented")
}
func (*UnimplementedRepositoryServer) CreateRef(ctx context.Context, req *Ref) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRef not implemented")
}
func (*UnimplementedRepositoryServer) DeleteRef(ctx context.Context, req *DeleteRefRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRef not implemented")
}
func (*UnimplementedRepositoryServer) ListRefs(ctx context.Context, req *ListRefsRequest) (*ListRefsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRefs not implemented")
}
func (*UnimplementedRepositoryServer) AttachTags(ctx context.Context, req *AttachTagsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachTags not implemented")
}
func (*UnimplementedRepositoryServer) DetachTags(ctx context.Context, req *DetachTagsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachTags not implemented")
}
func (*UnimplementedRepositoryServer) ResolveVersion(ctx context.Context, req *ResolveVersionRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveVersion not implemented")
}
func (*UnimplementedRepositoryServer) GetInstanceURL(ctx context.Context, req *GetInstanceURLRequest) (*ObjectURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceURL not implemented")
}
func (*UnimplementedRepositoryServer) DescribeInstance(ctx context.Context, req *DescribeInstanceRequest) (*DescribeInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeInstance not implemented")
}
func (*UnimplementedRepositoryServer) DescribeClient(ctx context.Context, req *DescribeClientRequest) (*DescribeClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeClient not implemented")
}

func RegisterRepositoryServer(s prpc.Registrar, srv RepositoryServer) {
	s.RegisterService(&_Repository_serviceDesc, srv)
}

func _Repository_GetPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInheritedPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetInheritedPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UpdatePrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/UpdatePrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, req.(*PrefixMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetRolesInPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetRolesInPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListPrefix(ctx, req.(*ListPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_HidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).HidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/HidePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).HidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UnhidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UnhidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/UnhidePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UnhidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DeletePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DeletePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DeletePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DeletePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Instance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/RegisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).RegisterInstance(ctx, req.(*Instance))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_SearchInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).SearchInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/SearchInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).SearchInstances(ctx, req.(*SearchInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_CreateRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).CreateRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/CreateRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).CreateRef(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DeleteRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DeleteRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DeleteRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DeleteRef(ctx, req.(*DeleteRefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListRefs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListRefs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListRefs(ctx, req.(*ListRefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_AttachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).AttachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/AttachTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).AttachTags(ctx, req.(*AttachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DetachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DetachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DetachTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DetachTags(ctx, req.(*DetachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ResolveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ResolveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ResolveVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ResolveVersion(ctx, req.(*ResolveVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInstanceURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInstanceURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetInstanceURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInstanceURL(ctx, req.(*GetInstanceURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DescribeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DescribeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DescribeInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DescribeInstance(ctx, req.(*DescribeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DescribeClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DescribeClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DescribeClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DescribeClient(ctx, req.(*DescribeClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Repository_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cipd.Repository",
	HandlerType: (*RepositoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrefixMetadata",
			Handler:    _Repository_GetPrefixMetadata_Handler,
		},
		{
			MethodName: "GetInheritedPrefixMetadata",
			Handler:    _Repository_GetInheritedPrefixMetadata_Handler,
		},
		{
			MethodName: "UpdatePrefixMetadata",
			Handler:    _Repository_UpdatePrefixMetadata_Handler,
		},
		{
			MethodName: "GetRolesInPrefix",
			Handler:    _Repository_GetRolesInPrefix_Handler,
		},
		{
			MethodName: "ListPrefix",
			Handler:    _Repository_ListPrefix_Handler,
		},
		{
			MethodName: "HidePackage",
			Handler:    _Repository_HidePackage_Handler,
		},
		{
			MethodName: "UnhidePackage",
			Handler:    _Repository_UnhidePackage_Handler,
		},
		{
			MethodName: "DeletePackage",
			Handler:    _Repository_DeletePackage_Handler,
		},
		{
			MethodName: "RegisterInstance",
			Handler:    _Repository_RegisterInstance_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _Repository_ListInstances_Handler,
		},
		{
			MethodName: "SearchInstances",
			Handler:    _Repository_SearchInstances_Handler,
		},
		{
			MethodName: "CreateRef",
			Handler:    _Repository_CreateRef_Handler,
		},
		{
			MethodName: "DeleteRef",
			Handler:    _Repository_DeleteRef_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Repository_ListRefs_Handler,
		},
		{
			MethodName: "AttachTags",
			Handler:    _Repository_AttachTags_Handler,
		},
		{
			MethodName: "DetachTags",
			Handler:    _Repository_DetachTags_Handler,
		},
		{
			MethodName: "ResolveVersion",
			Handler:    _Repository_ResolveVersion_Handler,
		},
		{
			MethodName: "GetInstanceURL",
			Handler:    _Repository_GetInstanceURL_Handler,
		},
		{
			MethodName: "DescribeInstance",
			Handler:    _Repository_DescribeInstance_Handler,
		},
		{
			MethodName: "DescribeClient",
			Handler:    _Repository_DescribeClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/cipd/api/cipd/v1/repo.proto",
}
