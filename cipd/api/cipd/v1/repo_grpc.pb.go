// Copyright 2017 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: go.chromium.org/luci/cipd/api/cipd/v1/repo.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Repository_GetPrefixMetadata_FullMethodName          = "/cipd.Repository/GetPrefixMetadata"
	Repository_GetInheritedPrefixMetadata_FullMethodName = "/cipd.Repository/GetInheritedPrefixMetadata"
	Repository_UpdatePrefixMetadata_FullMethodName       = "/cipd.Repository/UpdatePrefixMetadata"
	Repository_GetRolesInPrefix_FullMethodName           = "/cipd.Repository/GetRolesInPrefix"
	Repository_GetRolesInPrefixOnBehalfOf_FullMethodName = "/cipd.Repository/GetRolesInPrefixOnBehalfOf"
	Repository_ListPrefix_FullMethodName                 = "/cipd.Repository/ListPrefix"
	Repository_HidePackage_FullMethodName                = "/cipd.Repository/HidePackage"
	Repository_UnhidePackage_FullMethodName              = "/cipd.Repository/UnhidePackage"
	Repository_DeletePackage_FullMethodName              = "/cipd.Repository/DeletePackage"
	Repository_RegisterInstance_FullMethodName           = "/cipd.Repository/RegisterInstance"
	Repository_ListInstances_FullMethodName              = "/cipd.Repository/ListInstances"
	Repository_SearchInstances_FullMethodName            = "/cipd.Repository/SearchInstances"
	Repository_CreateRef_FullMethodName                  = "/cipd.Repository/CreateRef"
	Repository_DeleteRef_FullMethodName                  = "/cipd.Repository/DeleteRef"
	Repository_ListRefs_FullMethodName                   = "/cipd.Repository/ListRefs"
	Repository_AttachTags_FullMethodName                 = "/cipd.Repository/AttachTags"
	Repository_DetachTags_FullMethodName                 = "/cipd.Repository/DetachTags"
	Repository_AttachMetadata_FullMethodName             = "/cipd.Repository/AttachMetadata"
	Repository_DetachMetadata_FullMethodName             = "/cipd.Repository/DetachMetadata"
	Repository_ListMetadata_FullMethodName               = "/cipd.Repository/ListMetadata"
	Repository_ResolveVersion_FullMethodName             = "/cipd.Repository/ResolveVersion"
	Repository_GetInstanceURL_FullMethodName             = "/cipd.Repository/GetInstanceURL"
	Repository_DescribeInstance_FullMethodName           = "/cipd.Repository/DescribeInstance"
	Repository_DescribeClient_FullMethodName             = "/cipd.Repository/DescribeClient"
	Repository_DescribeBootstrapBundle_FullMethodName    = "/cipd.Repository/DescribeBootstrapBundle"
)

// RepositoryClient is the client API for Repository service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Manages CIPD packages and their associated metadata.
//
// A package is a named collection of one or more versions of a group of files.
// A package should typically be used for a single software component or
// dataset, not a conglomeration. A package instance is a concrete incarnation
// of a such version: it is a real file, and it is identified by its SHA256 (or
// SHA1 for older packages) digest, represented by ObjectRef proto in the
// protocol.
//
// A particular serialization of ObjectRef proto into a string is referred to
// as "instance ID" and it is used to identify package instances (mostly in
// the interface exposed by the CIPD command line client, but also in
// ResolveVersion RPC):
//   - For legacy reasons SHA1 digests are encoded with lowercase hex encoding,
//     which always results in 40 char ASCII strings).
//   - Other digests are encoded using base64(digest + []byte{ref.HashAlgo}),
//     where 'base64' is URL-safe and unpadded and '+' is concatenation.
//     For SHA256 digests this results in 44 char ASCII strings that end with C.
//
// Instance files themselves are zip archives with some additional metadata.
// They are produced and consumed by cipd CLI client, and the backend mostly
// doesn't care about their internal structure.
//
// Package names look like rootless file system paths (e.g. "a/b/c"). The
// identifier of a package is always the full path. There's no notion of
// "relative paths", or "..", or any other similar constructs. The name of the
// last path component has no intrinsic significance either, though it is often
// used to denote a platform the package is intended for. For example
// "infra/tools/cipd/linux-amd64" package is intended for Linux running on amd64
// architecture. This is just a convention, and it is not enforced nor
// understood by the backend.
//
// Each element of the package namespace (known as "package path prefix" or just
// "prefix") can have some metadata attached to it. Currently it includes only
// an access control list (ACL) that specifies what roles are granted to what
// users for the given prefix and all packages underneath it.
//
// For example, granting READER role to user@example.com in ACL associated with
// prefix "a/b/c" gives user@example.com permission to read all package
// instances of "a/b/c" and any packages below it (e.g. "a/b/c/d"). See Role
// enum for list of roles.
//
// There's no finer permission granularity inside the package itself, e.g. it is
// not possible to allow to read some particular package instance, without
// allowing to read all instances of the package.
type RepositoryClient interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, or be in a special global "cipd-prefixes-viewers" group,
	// otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, or be in a special global "cipd-prefixes-viewers" group,
	// otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires special permissions (since it
	// returns a lot of detailed information), GetRolesInPrefix can be called by
	// anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error)
	// Returns a set of roles a specific identity has in the given prefix.
	//
	// This works the same way as GetRolesInPrefix, except:
	//   - The caller requires the same permission as GetPrefixMetadata.
	//   - Uses PrefixRequestOnBehalfOf.identity, rather than the caller's
	//     identity, for determining the returned Roles.
	GetRolesInPrefixOnBehalfOf(ctx context.Context, in *PrefixRequestOnBehalfOf, opts ...grpc.CallOption) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   - {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   - {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeletePackage removes the package (along with all its instances, tags, refs
	// etc) from the repository.
	//
	// There's no undo. Once the package is deleted, it is gone forever.
	//
	// This operation has a potential to break various pinned historical CIPD
	// ensure files and thus should not be used casually, only in extreme cases.
	// Consider just hiding the package instead of deleting it.
	//
	// For the reasons above, the operation requires admin access: only owners of
	// the repository root can delete packages.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a root owner.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	DeletePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//  1. Attempt to register a package instance by calling RegisterInstance.
	//  2. On NOT_UPLOADED status, upload the package data and finalize the
	//     upload operation using Storage RPC service and upload_op from the
	//     response.
	//  3. Once the upload operation is finalized, call RegisterInstance again,
	//     it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// Returns package instances that have all given tags attached.
	//
	// Queries only instances of some particular package (i.e. this is not a
	// global query).
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	SearchInstances(ctx context.Context, in *SearchInstancesRequest, opts ...grpc.CallOption) (*SearchInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Attaches one or more metadata entries to an instance.
	//
	// An instance metadata entry is a key-value pair, where the key is a
	// lowercase string and the value is an arbitrary blob up to 512 Kb in size.
	//
	// A single key can have multiple different values associated with it.
	// Completely identical key-value pairs are deduplicated: attaching already
	// attached metadata is a noop. Thus all metadata of an instance is a
	// multimap, where a key maps to a set of unique values.
	//
	// A metadata entry is identified by its fingerprint: a hash of concatenated
	// key and value (see InstanceMetadata message for details). It can be used,
	// for example, to point to an entry to detach in DetachMetadata.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	AttachMetadata(ctx context.Context, in *AttachMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detaches one or more metadata entries if they were attached.
	//
	// Entries are identified by their fingerprints. They can either be calculated
	// from a key-value pair by the client (see InstanceMetadata message for
	// details), by the server (if InstanceMetadata messages inside
	// DetachMetadataRequest have 'key' and 'value' populated, but not
	// 'fingerprint') or taken from some existing InstanceMetadata message (e.g.
	// from inside a ListMetadataResponse).
	//
	// Detaching metadata that doesn't exist is a noop.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	DetachMetadata(ctx context.Context, in *DetachMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Lists metadata entries attached to an instance.
	//
	// Either returns all metadata or only entries with requested keys. The list
	// is sorted by the registration time of metadata entries (the most recent
	// first).
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	ListMetadata(ctx context.Context, in *ListMetadataRequest, opts ...grpc.CallOption) (*ListMetadataResponse, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   - A string-encoded instance ID, e.g. "abcdef....".
	//   - A ref name, e.g. "latest".
	//   - A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if there's no such package or version.
	//	FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error)
	// Produces a signed URL that can be used to fetch the package instance file.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if there's no such instance.
	GetInstanceURL(ctx context.Context, in *GetInstanceURLRequest, opts ...grpc.CallOption) (*ObjectURL, error)
	// Returns information about a package instance.
	//
	// Depending on fields set in the request, returns details such as when the
	// instance was registered and by whom, refs pointing to it, tags attached to
	// it, state of all processors that handled it (if any).
	//
	// May also be used as a simple instance presence check, if all describe_*
	// fields in the request are false. If the request succeeds, then the
	// instance exists.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the instance doesn't exist.
	DescribeInstance(ctx context.Context, in *DescribeInstanceRequest, opts ...grpc.CallOption) (*DescribeInstanceResponse, error)
	// Returns information about a CIPD client package.
	//
	// Used by the client self-update procedure.
	//
	// Returns:
	//
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	DescribeClient(ctx context.Context, in *DescribeClientRequest, opts ...grpc.CallOption) (*DescribeClientResponse, error)
	// Returns information about binaries extracted from bootstrap packages under
	// some prefix.
	//
	// This is a niche functionality used by some LUCI systems.
	//
	// Unlike other RPC methods here, it operates with a bunch of packages at
	// once. Errors that relate to a particular package instance (instead of the
	// request as a whole) are returned as google.rpc.Status inside the
	// corresponding BootstrapFile entry in DescribeBootstrapBundleResponse.
	// Possible statuses communicated that way:
	//
	//	NOT_FOUND if the requested version of the package doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed or it is not
	//	    a bootstrap package at all.
	//	ABORTED if the instance has failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	//
	// NOTE: The CIPD package server implements a REST endpoint which can be used
	// to retrieve the contents of bootstrap packages:
	//
	//	GET /bootstrap/<package>/+/<version>
	//
	// which will serve a 302 redirect to a signed url for the `file` contents.
	//
	// Returns:
	//
	//	OK if the request was accepted and (perhaps partially) processed.
	//	NOT_FOUND if none of the requested instances exist.
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	DescribeBootstrapBundle(ctx context.Context, in *DescribeBootstrapBundleRequest, opts ...grpc.CallOption) (*DescribeBootstrapBundleResponse, error)
}

type repositoryClient struct {
	cc grpc.ClientConnInterface
}

func NewRepositoryClient(cc grpc.ClientConnInterface) RepositoryClient {
	return &repositoryClient{cc}
}

func (c *repositoryClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, Repository_GetPrefixMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InheritedPrefixMetadata)
	err := c.cc.Invoke(ctx, Repository_GetInheritedPrefixMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, Repository_UpdatePrefixMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RolesInPrefixResponse)
	err := c.cc.Invoke(ctx, Repository_GetRolesInPrefix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetRolesInPrefixOnBehalfOf(ctx context.Context, in *PrefixRequestOnBehalfOf, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RolesInPrefixResponse)
	err := c.cc.Invoke(ctx, Repository_GetRolesInPrefixOnBehalfOf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPrefixResponse)
	err := c.cc.Invoke(ctx, Repository_ListPrefix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_HidePackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_UnhidePackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DeletePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_DeletePackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterInstanceResponse)
	err := c.cc.Invoke(ctx, Repository_RegisterInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, Repository_ListInstances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) SearchInstances(ctx context.Context, in *SearchInstancesRequest, opts ...grpc.CallOption) (*SearchInstancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchInstancesResponse)
	err := c.cc.Invoke(ctx, Repository_SearchInstances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_CreateRef_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_DeleteRef_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRefsResponse)
	err := c.cc.Invoke(ctx, Repository_ListRefs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_AttachTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_DetachTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) AttachMetadata(ctx context.Context, in *AttachMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_AttachMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DetachMetadata(ctx context.Context, in *DetachMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Repository_DetachMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListMetadata(ctx context.Context, in *ListMetadataRequest, opts ...grpc.CallOption) (*ListMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMetadataResponse)
	err := c.cc.Invoke(ctx, Repository_ListMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Instance)
	err := c.cc.Invoke(ctx, Repository_ResolveVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInstanceURL(ctx context.Context, in *GetInstanceURLRequest, opts ...grpc.CallOption) (*ObjectURL, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ObjectURL)
	err := c.cc.Invoke(ctx, Repository_GetInstanceURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DescribeInstance(ctx context.Context, in *DescribeInstanceRequest, opts ...grpc.CallOption) (*DescribeInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeInstanceResponse)
	err := c.cc.Invoke(ctx, Repository_DescribeInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DescribeClient(ctx context.Context, in *DescribeClientRequest, opts ...grpc.CallOption) (*DescribeClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeClientResponse)
	err := c.cc.Invoke(ctx, Repository_DescribeClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DescribeBootstrapBundle(ctx context.Context, in *DescribeBootstrapBundleRequest, opts ...grpc.CallOption) (*DescribeBootstrapBundleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeBootstrapBundleResponse)
	err := c.cc.Invoke(ctx, Repository_DescribeBootstrapBundle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RepositoryServer is the server API for Repository service.
// All implementations must embed UnimplementedRepositoryServer
// for forward compatibility.
//
// Manages CIPD packages and their associated metadata.
//
// A package is a named collection of one or more versions of a group of files.
// A package should typically be used for a single software component or
// dataset, not a conglomeration. A package instance is a concrete incarnation
// of a such version: it is a real file, and it is identified by its SHA256 (or
// SHA1 for older packages) digest, represented by ObjectRef proto in the
// protocol.
//
// A particular serialization of ObjectRef proto into a string is referred to
// as "instance ID" and it is used to identify package instances (mostly in
// the interface exposed by the CIPD command line client, but also in
// ResolveVersion RPC):
//   - For legacy reasons SHA1 digests are encoded with lowercase hex encoding,
//     which always results in 40 char ASCII strings).
//   - Other digests are encoded using base64(digest + []byte{ref.HashAlgo}),
//     where 'base64' is URL-safe and unpadded and '+' is concatenation.
//     For SHA256 digests this results in 44 char ASCII strings that end with C.
//
// Instance files themselves are zip archives with some additional metadata.
// They are produced and consumed by cipd CLI client, and the backend mostly
// doesn't care about their internal structure.
//
// Package names look like rootless file system paths (e.g. "a/b/c"). The
// identifier of a package is always the full path. There's no notion of
// "relative paths", or "..", or any other similar constructs. The name of the
// last path component has no intrinsic significance either, though it is often
// used to denote a platform the package is intended for. For example
// "infra/tools/cipd/linux-amd64" package is intended for Linux running on amd64
// architecture. This is just a convention, and it is not enforced nor
// understood by the backend.
//
// Each element of the package namespace (known as "package path prefix" or just
// "prefix") can have some metadata attached to it. Currently it includes only
// an access control list (ACL) that specifies what roles are granted to what
// users for the given prefix and all packages underneath it.
//
// For example, granting READER role to user@example.com in ACL associated with
// prefix "a/b/c" gives user@example.com permission to read all package
// instances of "a/b/c" and any packages below it (e.g. "a/b/c/d"). See Role
// enum for list of roles.
//
// There's no finer permission granularity inside the package itself, e.g. it is
// not possible to allow to read some particular package instance, without
// allowing to read all instances of the package.
type RepositoryServer interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, or be in a special global "cipd-prefixes-viewers" group,
	// otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(context.Context, *PrefixRequest) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, or be in a special global "cipd-prefixes-viewers" group,
	// otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(context.Context, *PrefixRequest) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(context.Context, *PrefixMetadata) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires special permissions (since it
	// returns a lot of detailed information), GetRolesInPrefix can be called by
	// anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(context.Context, *PrefixRequest) (*RolesInPrefixResponse, error)
	// Returns a set of roles a specific identity has in the given prefix.
	//
	// This works the same way as GetRolesInPrefix, except:
	//   - The caller requires the same permission as GetPrefixMetadata.
	//   - Uses PrefixRequestOnBehalfOf.identity, rather than the caller's
	//     identity, for determining the returned Roles.
	GetRolesInPrefixOnBehalfOf(context.Context, *PrefixRequestOnBehalfOf) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   - {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   - {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(context.Context, *ListPrefixRequest) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(context.Context, *PackageRequest) (*emptypb.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(context.Context, *PackageRequest) (*emptypb.Empty, error)
	// DeletePackage removes the package (along with all its instances, tags, refs
	// etc) from the repository.
	//
	// There's no undo. Once the package is deleted, it is gone forever.
	//
	// This operation has a potential to break various pinned historical CIPD
	// ensure files and thus should not be used casually, only in extreme cases.
	// Consider just hiding the package instead of deleting it.
	//
	// For the reasons above, the operation requires admin access: only owners of
	// the repository root can delete packages.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a root owner.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	DeletePackage(context.Context, *PackageRequest) (*emptypb.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//  1. Attempt to register a package instance by calling RegisterInstance.
	//  2. On NOT_UPLOADED status, upload the package data and finalize the
	//     upload operation using Storage RPC service and upload_op from the
	//     response.
	//  3. Once the upload operation is finalized, call RegisterInstance again,
	//     it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(context.Context, *Instance) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// Returns package instances that have all given tags attached.
	//
	// Queries only instances of some particular package (i.e. this is not a
	// global query).
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	SearchInstances(context.Context, *SearchInstancesRequest) (*SearchInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	CreateRef(context.Context, *Ref) (*emptypb.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	DeleteRef(context.Context, *DeleteRefRequest) (*emptypb.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package doesn't exist.
	ListRefs(context.Context, *ListRefsRequest) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	AttachTags(context.Context, *AttachTagsRequest) (*emptypb.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(context.Context, *DetachTagsRequest) (*emptypb.Empty, error)
	// Attaches one or more metadata entries to an instance.
	//
	// An instance metadata entry is a key-value pair, where the key is a
	// lowercase string and the value is an arbitrary blob up to 512 Kb in size.
	//
	// A single key can have multiple different values associated with it.
	// Completely identical key-value pairs are deduplicated: attaching already
	// attached metadata is a noop. Thus all metadata of an instance is a
	// multimap, where a key maps to a set of unique values.
	//
	// A metadata entry is identified by its fingerprint: a hash of concatenated
	// key and value (see InstanceMetadata message for details). It can be used,
	// for example, to point to an entry to detach in DetachMetadata.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	AttachMetadata(context.Context, *AttachMetadataRequest) (*emptypb.Empty, error)
	// Detaches one or more metadata entries if they were attached.
	//
	// Entries are identified by their fingerprints. They can either be calculated
	// from a key-value pair by the client (see InstanceMetadata message for
	// details), by the server (if InstanceMetadata messages inside
	// DetachMetadataRequest have 'key' and 'value' populated, but not
	// 'fingerprint') or taken from some existing InstanceMetadata message (e.g.
	// from inside a ListMetadataResponse).
	//
	// Detaching metadata that doesn't exist is a noop.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	DetachMetadata(context.Context, *DetachMetadataRequest) (*emptypb.Empty, error)
	// Lists metadata entries attached to an instance.
	//
	// Either returns all metadata or only entries with requested keys. The list
	// is sorted by the registration time of metadata entries (the most recent
	// first).
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the package or the instance doesn't exist.
	ListMetadata(context.Context, *ListMetadataRequest) (*ListMetadataResponse, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   - A string-encoded instance ID, e.g. "abcdef....".
	//   - A ref name, e.g. "latest".
	//   - A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if there's no such package or version.
	//	FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(context.Context, *ResolveVersionRequest) (*Instance, error)
	// Produces a signed URL that can be used to fetch the package instance file.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if there's no such instance.
	GetInstanceURL(context.Context, *GetInstanceURLRequest) (*ObjectURL, error)
	// Returns information about a package instance.
	//
	// Depending on fields set in the request, returns details such as when the
	// instance was registered and by whom, refs pointing to it, tags attached to
	// it, state of all processors that handled it (if any).
	//
	// May also be used as a simple instance presence check, if all describe_*
	// fields in the request are false. If the request succeeds, then the
	// instance exists.
	//
	// Returns:
	//
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	//	NOT_FOUND if the instance doesn't exist.
	DescribeInstance(context.Context, *DescribeInstanceRequest) (*DescribeInstanceResponse, error)
	// Returns information about a CIPD client package.
	//
	// Used by the client self-update procedure.
	//
	// Returns:
	//
	//	NOT_FOUND if the package or the instance doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed.
	//	ABORTED if the instance has some failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	DescribeClient(context.Context, *DescribeClientRequest) (*DescribeClientResponse, error)
	// Returns information about binaries extracted from bootstrap packages under
	// some prefix.
	//
	// This is a niche functionality used by some LUCI systems.
	//
	// Unlike other RPC methods here, it operates with a bunch of packages at
	// once. Errors that relate to a particular package instance (instead of the
	// request as a whole) are returned as google.rpc.Status inside the
	// corresponding BootstrapFile entry in DescribeBootstrapBundleResponse.
	// Possible statuses communicated that way:
	//
	//	NOT_FOUND if the requested version of the package doesn't exist.
	//	FAILED_PRECONDITION if the instance is still being processed or it is not
	//	    a bootstrap package at all.
	//	ABORTED if the instance has failed processors associated with it,
	//	    such instance is effectively broken and should not be used.
	//
	// NOTE: The CIPD package server implements a REST endpoint which can be used
	// to retrieve the contents of bootstrap packages:
	//
	//	GET /bootstrap/<package>/+/<version>
	//
	// which will serve a 302 redirect to a signed url for the `file` contents.
	//
	// Returns:
	//
	//	OK if the request was accepted and (perhaps partially) processed.
	//	NOT_FOUND if none of the requested instances exist.
	//	PERMISSION_DENIED if the caller is not a READER for the prefix.
	//	INVALID_ARGUMENT if the request is malformed.
	DescribeBootstrapBundle(context.Context, *DescribeBootstrapBundleRequest) (*DescribeBootstrapBundleResponse, error)
	mustEmbedUnimplementedRepositoryServer()
}

// UnimplementedRepositoryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRepositoryServer struct{}

func (UnimplementedRepositoryServer) GetPrefixMetadata(context.Context, *PrefixRequest) (*PrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrefixMetadata not implemented")
}
func (UnimplementedRepositoryServer) GetInheritedPrefixMetadata(context.Context, *PrefixRequest) (*InheritedPrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInheritedPrefixMetadata not implemented")
}
func (UnimplementedRepositoryServer) UpdatePrefixMetadata(context.Context, *PrefixMetadata) (*PrefixMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrefixMetadata not implemented")
}
func (UnimplementedRepositoryServer) GetRolesInPrefix(context.Context, *PrefixRequest) (*RolesInPrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolesInPrefix not implemented")
}
func (UnimplementedRepositoryServer) GetRolesInPrefixOnBehalfOf(context.Context, *PrefixRequestOnBehalfOf) (*RolesInPrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolesInPrefixOnBehalfOf not implemented")
}
func (UnimplementedRepositoryServer) ListPrefix(context.Context, *ListPrefixRequest) (*ListPrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrefix not implemented")
}
func (UnimplementedRepositoryServer) HidePackage(context.Context, *PackageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HidePackage not implemented")
}
func (UnimplementedRepositoryServer) UnhidePackage(context.Context, *PackageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnhidePackage not implemented")
}
func (UnimplementedRepositoryServer) DeletePackage(context.Context, *PackageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePackage not implemented")
}
func (UnimplementedRepositoryServer) RegisterInstance(context.Context, *Instance) (*RegisterInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterInstance not implemented")
}
func (UnimplementedRepositoryServer) ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedRepositoryServer) SearchInstances(context.Context, *SearchInstancesRequest) (*SearchInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchInstances not implemented")
}
func (UnimplementedRepositoryServer) CreateRef(context.Context, *Ref) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRef not implemented")
}
func (UnimplementedRepositoryServer) DeleteRef(context.Context, *DeleteRefRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRef not implemented")
}
func (UnimplementedRepositoryServer) ListRefs(context.Context, *ListRefsRequest) (*ListRefsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRefs not implemented")
}
func (UnimplementedRepositoryServer) AttachTags(context.Context, *AttachTagsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachTags not implemented")
}
func (UnimplementedRepositoryServer) DetachTags(context.Context, *DetachTagsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachTags not implemented")
}
func (UnimplementedRepositoryServer) AttachMetadata(context.Context, *AttachMetadataRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachMetadata not implemented")
}
func (UnimplementedRepositoryServer) DetachMetadata(context.Context, *DetachMetadataRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachMetadata not implemented")
}
func (UnimplementedRepositoryServer) ListMetadata(context.Context, *ListMetadataRequest) (*ListMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMetadata not implemented")
}
func (UnimplementedRepositoryServer) ResolveVersion(context.Context, *ResolveVersionRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveVersion not implemented")
}
func (UnimplementedRepositoryServer) GetInstanceURL(context.Context, *GetInstanceURLRequest) (*ObjectURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceURL not implemented")
}
func (UnimplementedRepositoryServer) DescribeInstance(context.Context, *DescribeInstanceRequest) (*DescribeInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeInstance not implemented")
}
func (UnimplementedRepositoryServer) DescribeClient(context.Context, *DescribeClientRequest) (*DescribeClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeClient not implemented")
}
func (UnimplementedRepositoryServer) DescribeBootstrapBundle(context.Context, *DescribeBootstrapBundleRequest) (*DescribeBootstrapBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeBootstrapBundle not implemented")
}
func (UnimplementedRepositoryServer) mustEmbedUnimplementedRepositoryServer() {}
func (UnimplementedRepositoryServer) testEmbeddedByValue()                    {}

// UnsafeRepositoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RepositoryServer will
// result in compilation errors.
type UnsafeRepositoryServer interface {
	mustEmbedUnimplementedRepositoryServer()
}

func RegisterRepositoryServer(s grpc.ServiceRegistrar, srv RepositoryServer) {
	// If the following call pancis, it indicates UnimplementedRepositoryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Repository_ServiceDesc, srv)
}

func _Repository_GetPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_GetPrefixMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInheritedPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_GetInheritedPrefixMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UpdatePrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_UpdatePrefixMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, req.(*PrefixMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetRolesInPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_GetRolesInPrefix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetRolesInPrefixOnBehalfOf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequestOnBehalfOf)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetRolesInPrefixOnBehalfOf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_GetRolesInPrefixOnBehalfOf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetRolesInPrefixOnBehalfOf(ctx, req.(*PrefixRequestOnBehalfOf))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_ListPrefix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListPrefix(ctx, req.(*ListPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_HidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).HidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_HidePackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).HidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UnhidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UnhidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_UnhidePackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UnhidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DeletePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DeletePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DeletePackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DeletePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Instance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_RegisterInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).RegisterInstance(ctx, req.(*Instance))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_ListInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_SearchInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).SearchInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_SearchInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).SearchInstances(ctx, req.(*SearchInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_CreateRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).CreateRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_CreateRef_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).CreateRef(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DeleteRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DeleteRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DeleteRef_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DeleteRef(ctx, req.(*DeleteRefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListRefs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_ListRefs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListRefs(ctx, req.(*ListRefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_AttachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).AttachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_AttachTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).AttachTags(ctx, req.(*AttachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DetachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DetachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DetachTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DetachTags(ctx, req.(*DetachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_AttachMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).AttachMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_AttachMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).AttachMetadata(ctx, req.(*AttachMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DetachMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DetachMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DetachMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DetachMetadata(ctx, req.(*DetachMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_ListMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListMetadata(ctx, req.(*ListMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ResolveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ResolveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_ResolveVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ResolveVersion(ctx, req.(*ResolveVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInstanceURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInstanceURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_GetInstanceURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInstanceURL(ctx, req.(*GetInstanceURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DescribeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DescribeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DescribeInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DescribeInstance(ctx, req.(*DescribeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DescribeClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DescribeClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DescribeClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DescribeClient(ctx, req.(*DescribeClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DescribeBootstrapBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeBootstrapBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DescribeBootstrapBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Repository_DescribeBootstrapBundle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DescribeBootstrapBundle(ctx, req.(*DescribeBootstrapBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Repository_ServiceDesc is the grpc.ServiceDesc for Repository service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Repository_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cipd.Repository",
	HandlerType: (*RepositoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrefixMetadata",
			Handler:    _Repository_GetPrefixMetadata_Handler,
		},
		{
			MethodName: "GetInheritedPrefixMetadata",
			Handler:    _Repository_GetInheritedPrefixMetadata_Handler,
		},
		{
			MethodName: "UpdatePrefixMetadata",
			Handler:    _Repository_UpdatePrefixMetadata_Handler,
		},
		{
			MethodName: "GetRolesInPrefix",
			Handler:    _Repository_GetRolesInPrefix_Handler,
		},
		{
			MethodName: "GetRolesInPrefixOnBehalfOf",
			Handler:    _Repository_GetRolesInPrefixOnBehalfOf_Handler,
		},
		{
			MethodName: "ListPrefix",
			Handler:    _Repository_ListPrefix_Handler,
		},
		{
			MethodName: "HidePackage",
			Handler:    _Repository_HidePackage_Handler,
		},
		{
			MethodName: "UnhidePackage",
			Handler:    _Repository_UnhidePackage_Handler,
		},
		{
			MethodName: "DeletePackage",
			Handler:    _Repository_DeletePackage_Handler,
		},
		{
			MethodName: "RegisterInstance",
			Handler:    _Repository_RegisterInstance_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _Repository_ListInstances_Handler,
		},
		{
			MethodName: "SearchInstances",
			Handler:    _Repository_SearchInstances_Handler,
		},
		{
			MethodName: "CreateRef",
			Handler:    _Repository_CreateRef_Handler,
		},
		{
			MethodName: "DeleteRef",
			Handler:    _Repository_DeleteRef_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Repository_ListRefs_Handler,
		},
		{
			MethodName: "AttachTags",
			Handler:    _Repository_AttachTags_Handler,
		},
		{
			MethodName: "DetachTags",
			Handler:    _Repository_DetachTags_Handler,
		},
		{
			MethodName: "AttachMetadata",
			Handler:    _Repository_AttachMetadata_Handler,
		},
		{
			MethodName: "DetachMetadata",
			Handler:    _Repository_DetachMetadata_Handler,
		},
		{
			MethodName: "ListMetadata",
			Handler:    _Repository_ListMetadata_Handler,
		},
		{
			MethodName: "ResolveVersion",
			Handler:    _Repository_ResolveVersion_Handler,
		},
		{
			MethodName: "GetInstanceURL",
			Handler:    _Repository_GetInstanceURL_Handler,
		},
		{
			MethodName: "DescribeInstance",
			Handler:    _Repository_DescribeInstance_Handler,
		},
		{
			MethodName: "DescribeClient",
			Handler:    _Repository_DescribeClient_Handler,
		},
		{
			MethodName: "DescribeBootstrapBundle",
			Handler:    _Repository_DescribeBootstrapBundle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/cipd/api/cipd/v1/repo.proto",
}
