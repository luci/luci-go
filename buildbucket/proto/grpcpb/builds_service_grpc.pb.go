// Copyright 2020 The Swarming Authors. All rights reserved.
// Use of this source code is governed by the Apache v2.0 license that can be
// found in the LICENSE file.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: go.chromium.org/luci/buildbucket/proto/builds_service.proto

package buildbucketgrpcpb

import . "go.chromium.org/luci/buildbucket/proto"

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Builds_GetBuild_FullMethodName            = "/buildbucket.v2.Builds/GetBuild"
	Builds_SearchBuilds_FullMethodName        = "/buildbucket.v2.Builds/SearchBuilds"
	Builds_UpdateBuild_FullMethodName         = "/buildbucket.v2.Builds/UpdateBuild"
	Builds_ScheduleBuild_FullMethodName       = "/buildbucket.v2.Builds/ScheduleBuild"
	Builds_CancelBuild_FullMethodName         = "/buildbucket.v2.Builds/CancelBuild"
	Builds_Batch_FullMethodName               = "/buildbucket.v2.Builds/Batch"
	Builds_CreateBuild_FullMethodName         = "/buildbucket.v2.Builds/CreateBuild"
	Builds_SynthesizeBuild_FullMethodName     = "/buildbucket.v2.Builds/SynthesizeBuild"
	Builds_GetBuildStatus_FullMethodName      = "/buildbucket.v2.Builds/GetBuildStatus"
	Builds_StartBuild_FullMethodName          = "/buildbucket.v2.Builds/StartBuild"
	Builds_CustomMetricPreview_FullMethodName = "/buildbucket.v2.Builds/CustomMetricPreview"
)

// BuildsClient is the client API for Builds service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Manages builds.
//
// Buildbot: To simplify V1->V2 API transition for clients, buildbucket.v2.Builds
// service has some support for non-LUCI builds. Most of such builds are
// Buildbot builds and this documentation refers to them as such, but they also
// include non-Buildbot non-LUCI builds (e.g. Skia builds).
// See "Buildbot" paragraph in each RPC comment.
type BuildsClient interface {
	// Gets a build.
	//
	// By default the returned build does not include all fields.
	// See GetBuildRequest.mask.
	//
	// Buildbot: if the specified build is a buildbot build, converts it to Build
	// message with the following rules:
	//   - bucket names are full, e.g. "luci.infra.try". Note that LUCI buckets
	//     in v2 are shortened, e.g. "try".
	//   - if a v2 Build field does not make sense in V1, it is unset/empty.
	//   - step support is not implemented for Buildbot builds.
	//
	// Note that it does not support getting a buildbot build by build number.
	// Examples: go/buildbucket-rpc#getbuild
	//
	// GetBuild is good for getting detailed information for a build.
	// For use cases that only requires build status checking (e.g. wait for a
	// build to complete), please use GetBuildStatus instead.
	GetBuild(ctx context.Context, in *GetBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Searches for builds.
	// Examples: go/buildbucket-rpc#searchbuilds
	SearchBuilds(ctx context.Context, in *SearchBuildsRequest, opts ...grpc.CallOption) (*SearchBuildsResponse, error)
	// Updates a build.
	//
	// RPC metadata must include "x-buildbucket-token" key with a token
	// generated by the server when scheduling the build.
	UpdateBuild(ctx context.Context, in *UpdateBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Schedules a new build.
	// The requester must have at least SCHEDULER role in the destination bucket.
	// Example: go/buildbucket-rpc#schedulebuild
	ScheduleBuild(ctx context.Context, in *ScheduleBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Cancels a build.
	// The requester must have at least SCHEDULER role in the destination bucket.
	// Note that cancelling a build in ended state (meaning build is not in
	// STATUS_UNSPECIFIED, SCHEDULED or STARTED status) will be a no-op and
	// directly return up-to-date Build message.
	//
	// When called, Buildbucket will set the build's cancelTime to "now".  It
	// will also recursively start the cancellation process for any children of
	// this build which are marked as can_outlive_parent=false.
	//
	// The next time the build checks in (which happens periodically in
	// `bbagent`), bbagent will see the cancelTime, and start the cancellation
	// process described by the 'deadline' section in
	// https://chromium.googlesource.com/infra/luci/luci-py/+/HEAD/client/LUCI_CONTEXT.md.
	//
	// If the build ends before the build's grace_period, then the final status
	// reported from the build is accepted; this is considered 'graceful termination'.
	//
	// If the build doesn't end within the build's grace_period, Buildbucket will
	// forcibly cancel the build.
	CancelBuild(ctx context.Context, in *CancelBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Executes multiple requests in a batch.
	// The response code is always OK.
	// Examples: go/buildbucket-rpc#batch
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	// Creates a new build for the provided build proto.
	//
	// If build with the given ID already exists, returns ALREADY_EXISTS
	// error code.
	// CreateBuild does not support the max_concurrent_builds feature.
	// Incidently, led builds will never reach the builder max_concurrent_builds
	// threshold.
	CreateBuild(ctx context.Context, in *CreateBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Synthesizes a build proto.
	//
	// This RPC is exclusively for generating led builds.
	SynthesizeBuild(ctx context.Context, in *SynthesizeBuildRequest, opts ...grpc.CallOption) (*Build, error)
	// Gets a build's status.
	//
	// The returned build contains the requested build id or
	// (builder + build number), and build status.
	//
	// It's useful when a user only wants to check the build's status (i.e. wait
	// for a build to complete).
	GetBuildStatus(ctx context.Context, in *GetBuildStatusRequest, opts ...grpc.CallOption) (*Build, error)
	// Starts a build.
	//
	// RPC metadata must include "x-buildbucket-token" key with
	//   - a BUILD type token generated by the server when it creates a Swarming
	//     task for the build (builds on Swarming) or
	//   - a START_BUILD type token generated by the server when it attempts to run
	//     a backend task (builds on TaskBackend).
	//
	// Agent must call it before making any UpdateBuild calls.
	//
	// StartBuild will associate a task with a build if the association is not done
	// after RunTaskResponse is returned to buildbucket.
	StartBuild(ctx context.Context, in *StartBuildRequest, opts ...grpc.CallOption) (*StartBuildResponse, error)
	// Preview a custom metric definition with a build.
	// It's useful for builder owners to test the CEL expressions they plan to
	// use in their custom metric predicates and extra_fields.
	CustomMetricPreview(ctx context.Context, in *CustomMetricPreviewRequest, opts ...grpc.CallOption) (*CustomMetricPreviewResponse, error)
}

type buildsClient struct {
	cc grpc.ClientConnInterface
}

func NewBuildsClient(cc grpc.ClientConnInterface) BuildsClient {
	return &buildsClient{cc}
}

func (c *buildsClient) GetBuild(ctx context.Context, in *GetBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_GetBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) SearchBuilds(ctx context.Context, in *SearchBuildsRequest, opts ...grpc.CallOption) (*SearchBuildsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchBuildsResponse)
	err := c.cc.Invoke(ctx, Builds_SearchBuilds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) UpdateBuild(ctx context.Context, in *UpdateBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_UpdateBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) ScheduleBuild(ctx context.Context, in *ScheduleBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_ScheduleBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CancelBuild(ctx context.Context, in *CancelBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_CancelBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, Builds_Batch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CreateBuild(ctx context.Context, in *CreateBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_CreateBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) SynthesizeBuild(ctx context.Context, in *SynthesizeBuildRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_SynthesizeBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetBuildStatus(ctx context.Context, in *GetBuildStatusRequest, opts ...grpc.CallOption) (*Build, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Build)
	err := c.cc.Invoke(ctx, Builds_GetBuildStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) StartBuild(ctx context.Context, in *StartBuildRequest, opts ...grpc.CallOption) (*StartBuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartBuildResponse)
	err := c.cc.Invoke(ctx, Builds_StartBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CustomMetricPreview(ctx context.Context, in *CustomMetricPreviewRequest, opts ...grpc.CallOption) (*CustomMetricPreviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomMetricPreviewResponse)
	err := c.cc.Invoke(ctx, Builds_CustomMetricPreview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuildsServer is the server API for Builds service.
// All implementations must embed UnimplementedBuildsServer
// for forward compatibility.
//
// Manages builds.
//
// Buildbot: To simplify V1->V2 API transition for clients, buildbucket.v2.Builds
// service has some support for non-LUCI builds. Most of such builds are
// Buildbot builds and this documentation refers to them as such, but they also
// include non-Buildbot non-LUCI builds (e.g. Skia builds).
// See "Buildbot" paragraph in each RPC comment.
type BuildsServer interface {
	// Gets a build.
	//
	// By default the returned build does not include all fields.
	// See GetBuildRequest.mask.
	//
	// Buildbot: if the specified build is a buildbot build, converts it to Build
	// message with the following rules:
	//   - bucket names are full, e.g. "luci.infra.try". Note that LUCI buckets
	//     in v2 are shortened, e.g. "try".
	//   - if a v2 Build field does not make sense in V1, it is unset/empty.
	//   - step support is not implemented for Buildbot builds.
	//
	// Note that it does not support getting a buildbot build by build number.
	// Examples: go/buildbucket-rpc#getbuild
	//
	// GetBuild is good for getting detailed information for a build.
	// For use cases that only requires build status checking (e.g. wait for a
	// build to complete), please use GetBuildStatus instead.
	GetBuild(context.Context, *GetBuildRequest) (*Build, error)
	// Searches for builds.
	// Examples: go/buildbucket-rpc#searchbuilds
	SearchBuilds(context.Context, *SearchBuildsRequest) (*SearchBuildsResponse, error)
	// Updates a build.
	//
	// RPC metadata must include "x-buildbucket-token" key with a token
	// generated by the server when scheduling the build.
	UpdateBuild(context.Context, *UpdateBuildRequest) (*Build, error)
	// Schedules a new build.
	// The requester must have at least SCHEDULER role in the destination bucket.
	// Example: go/buildbucket-rpc#schedulebuild
	ScheduleBuild(context.Context, *ScheduleBuildRequest) (*Build, error)
	// Cancels a build.
	// The requester must have at least SCHEDULER role in the destination bucket.
	// Note that cancelling a build in ended state (meaning build is not in
	// STATUS_UNSPECIFIED, SCHEDULED or STARTED status) will be a no-op and
	// directly return up-to-date Build message.
	//
	// When called, Buildbucket will set the build's cancelTime to "now".  It
	// will also recursively start the cancellation process for any children of
	// this build which are marked as can_outlive_parent=false.
	//
	// The next time the build checks in (which happens periodically in
	// `bbagent`), bbagent will see the cancelTime, and start the cancellation
	// process described by the 'deadline' section in
	// https://chromium.googlesource.com/infra/luci/luci-py/+/HEAD/client/LUCI_CONTEXT.md.
	//
	// If the build ends before the build's grace_period, then the final status
	// reported from the build is accepted; this is considered 'graceful termination'.
	//
	// If the build doesn't end within the build's grace_period, Buildbucket will
	// forcibly cancel the build.
	CancelBuild(context.Context, *CancelBuildRequest) (*Build, error)
	// Executes multiple requests in a batch.
	// The response code is always OK.
	// Examples: go/buildbucket-rpc#batch
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
	// Creates a new build for the provided build proto.
	//
	// If build with the given ID already exists, returns ALREADY_EXISTS
	// error code.
	// CreateBuild does not support the max_concurrent_builds feature.
	// Incidently, led builds will never reach the builder max_concurrent_builds
	// threshold.
	CreateBuild(context.Context, *CreateBuildRequest) (*Build, error)
	// Synthesizes a build proto.
	//
	// This RPC is exclusively for generating led builds.
	SynthesizeBuild(context.Context, *SynthesizeBuildRequest) (*Build, error)
	// Gets a build's status.
	//
	// The returned build contains the requested build id or
	// (builder + build number), and build status.
	//
	// It's useful when a user only wants to check the build's status (i.e. wait
	// for a build to complete).
	GetBuildStatus(context.Context, *GetBuildStatusRequest) (*Build, error)
	// Starts a build.
	//
	// RPC metadata must include "x-buildbucket-token" key with
	//   - a BUILD type token generated by the server when it creates a Swarming
	//     task for the build (builds on Swarming) or
	//   - a START_BUILD type token generated by the server when it attempts to run
	//     a backend task (builds on TaskBackend).
	//
	// Agent must call it before making any UpdateBuild calls.
	//
	// StartBuild will associate a task with a build if the association is not done
	// after RunTaskResponse is returned to buildbucket.
	StartBuild(context.Context, *StartBuildRequest) (*StartBuildResponse, error)
	// Preview a custom metric definition with a build.
	// It's useful for builder owners to test the CEL expressions they plan to
	// use in their custom metric predicates and extra_fields.
	CustomMetricPreview(context.Context, *CustomMetricPreviewRequest) (*CustomMetricPreviewResponse, error)
	mustEmbedUnimplementedBuildsServer()
}

// UnimplementedBuildsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuildsServer struct{}

func (UnimplementedBuildsServer) GetBuild(context.Context, *GetBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuild not implemented")
}
func (UnimplementedBuildsServer) SearchBuilds(context.Context, *SearchBuildsRequest) (*SearchBuildsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBuilds not implemented")
}
func (UnimplementedBuildsServer) UpdateBuild(context.Context, *UpdateBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBuild not implemented")
}
func (UnimplementedBuildsServer) ScheduleBuild(context.Context, *ScheduleBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleBuild not implemented")
}
func (UnimplementedBuildsServer) CancelBuild(context.Context, *CancelBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBuild not implemented")
}
func (UnimplementedBuildsServer) Batch(context.Context, *BatchRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Batch not implemented")
}
func (UnimplementedBuildsServer) CreateBuild(context.Context, *CreateBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBuild not implemented")
}
func (UnimplementedBuildsServer) SynthesizeBuild(context.Context, *SynthesizeBuildRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SynthesizeBuild not implemented")
}
func (UnimplementedBuildsServer) GetBuildStatus(context.Context, *GetBuildStatusRequest) (*Build, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildStatus not implemented")
}
func (UnimplementedBuildsServer) StartBuild(context.Context, *StartBuildRequest) (*StartBuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBuild not implemented")
}
func (UnimplementedBuildsServer) CustomMetricPreview(context.Context, *CustomMetricPreviewRequest) (*CustomMetricPreviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CustomMetricPreview not implemented")
}
func (UnimplementedBuildsServer) mustEmbedUnimplementedBuildsServer() {}
func (UnimplementedBuildsServer) testEmbeddedByValue()                {}

// UnsafeBuildsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuildsServer will
// result in compilation errors.
type UnsafeBuildsServer interface {
	mustEmbedUnimplementedBuildsServer()
}

func RegisterBuildsServer(s grpc.ServiceRegistrar, srv BuildsServer) {
	// If the following call pancis, it indicates UnimplementedBuildsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Builds_ServiceDesc, srv)
}

func _Builds_GetBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).GetBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_GetBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).GetBuild(ctx, req.(*GetBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_SearchBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBuildsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).SearchBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_SearchBuilds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).SearchBuilds(ctx, req.(*SearchBuildsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_UpdateBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).UpdateBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_UpdateBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).UpdateBuild(ctx, req.(*UpdateBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_ScheduleBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).ScheduleBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_ScheduleBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).ScheduleBuild(ctx, req.(*ScheduleBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_CancelBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).CancelBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_CancelBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).CancelBuild(ctx, req.(*CancelBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_Batch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_CreateBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).CreateBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_CreateBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).CreateBuild(ctx, req.(*CreateBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_SynthesizeBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SynthesizeBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).SynthesizeBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_SynthesizeBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).SynthesizeBuild(ctx, req.(*SynthesizeBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_GetBuildStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBuildStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).GetBuildStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_GetBuildStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).GetBuildStatus(ctx, req.(*GetBuildStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_StartBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).StartBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_StartBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).StartBuild(ctx, req.(*StartBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Builds_CustomMetricPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomMetricPreviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildsServer).CustomMetricPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Builds_CustomMetricPreview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildsServer).CustomMetricPreview(ctx, req.(*CustomMetricPreviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Builds_ServiceDesc is the grpc.ServiceDesc for Builds service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Builds_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buildbucket.v2.Builds",
	HandlerType: (*BuildsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBuild",
			Handler:    _Builds_GetBuild_Handler,
		},
		{
			MethodName: "SearchBuilds",
			Handler:    _Builds_SearchBuilds_Handler,
		},
		{
			MethodName: "UpdateBuild",
			Handler:    _Builds_UpdateBuild_Handler,
		},
		{
			MethodName: "ScheduleBuild",
			Handler:    _Builds_ScheduleBuild_Handler,
		},
		{
			MethodName: "CancelBuild",
			Handler:    _Builds_CancelBuild_Handler,
		},
		{
			MethodName: "Batch",
			Handler:    _Builds_Batch_Handler,
		},
		{
			MethodName: "CreateBuild",
			Handler:    _Builds_CreateBuild_Handler,
		},
		{
			MethodName: "SynthesizeBuild",
			Handler:    _Builds_SynthesizeBuild_Handler,
		},
		{
			MethodName: "GetBuildStatus",
			Handler:    _Builds_GetBuildStatus_Handler,
		},
		{
			MethodName: "StartBuild",
			Handler:    _Builds_StartBuild_Handler,
		},
		{
			MethodName: "CustomMetricPreview",
			Handler:    _Builds_CustomMetricPreview_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/buildbucket/proto/builds_service.proto",
}
