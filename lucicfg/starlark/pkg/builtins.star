# Copyright 2025 The LUCI Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Symbols available in the default namespace when loading PACKAGE.star file.

Only these symbols (plus Starlark builtins) are available. load(...) is
forbidden.
"""

def _declare(*, name, lucicfg):
    """Declares a lucicfg package.

    It sets the package import name and the required minimum version of lucicfg.

    The name must start with `@`: all load statements referring to this package
    from other packages will use this name:

    ```
    load("@importname//path/within/the/package.star", ...)
    ```

    See [Modules and packages](#modules-and-packages) for more details.

    This name should be reasonably unique: it is impossible to use two
    different packages with the same name as dependencies in a single
    dependency tree (even if they are indirect dependencies).

    For repos containing recipes, this should be the same value as the recipe
    repo-name for consistency, though to avoid recipe<->lucicfg entanglement,
    this is not a requirement.

    This statement is required exactly once and it must be the first statement
    in PACKAGE.star file.

    The names `@stdlib`, `@__main__` and `@proto` are reserved.

    Args:
      name: the name for this package. Required.
      lucicfg: a string `major.minor.revision` with a minimum lucicfg version
        this package requires. Required.
    """
    __native__.declare(
        _validate_string("name", name),
        _validate_string("lucicfg", lucicfg),
    )

def _depend(*, name, source):
    """Declares a dependency on another lucicfg package.

    This essentially declares that `load("@<name>//<path>", ...)` statements
    should be resolved to files from the given source at a revision no older
    than the one specified in the pkg.source.googlesource(...) declaration.

    The name must match the name declared by the dependent package itself in
    its pkg.declare(...) statement.

    Packages form a dependency DAG. All dependencies with a given name should
    all be fetched from the same source (the same repo and the same ref), but
    perhaps have different minimal version constraints. The final single version
    of the dependency that will be used by all packages in the DAG is picked as
    a newest among all collected minimal version constraints (using the git
    ref's history for finding which version is newer).

    The resolved versions are written into a lock file of the current package
    (`PACKAGE.lock`, which is a JSON file). This lock file is used exclusively
    when this package is the entry point package for some lucicfg execution. In
    other words, lock files of imported dependencies have no effect on the
    dependency resolution process at all.

    The lock file is required to run `lucicfg generate`. It can be generated by
    `lucicfg lock` subcommand and checked in into the repository with the rest
    of the package. It is validated as part of `lucicfg validate` call.

    Args:
      name: the name of the depended package. Required.
      source: a pkg.source.ref struct as produced by
        pkg.source.googlesource(...), pkg.source.read_submodule(...) or
        pkg.source.read_local(...). Required.
    """
    _unused(name, source)
    fail("not implemented")

def _resources(*, files):
    """Declares non-Starlark files to includes into the package.

    Only these files can be read at runtime via io.read_file(...) or
    io.read_proto(...).

    Declaring them upfront is useful when the package is used as a dependency.
    Resource files are prefetched from the package source.

    Can be called multiple times. Works additively.

    Args:
      files: a list of glob patterns that define a subset of non-Starlark files
        under the package directory. Each entry is either `<glob pattern>`
        (a "positive" glob) or `!<glob pattern>` (a "negative" glob). A file is
        considered to be a resource file if its slash-separated path matches any
        of the positive globs and none of the negative globs. If a pattern
        starts with `**/`, the rest of it is applied to the base name of the
        file (not the whole path). If only negative globs are given, a single
        positive `**/*` glob is implied as well.
    """
    _unused(files)
    fail("not implemented")

def _entrypoint(path):
    """Declares that the given Starlark file is one of the entry point scripts.

    Entry point scripts are scripts that can be executed (via
    `lucicfg gen <path>`) to generate some configuration file. Only entry point
    scripts can be executed.

    Args:
      path: a path to a Starlark file relative to the package root.
    """
    __native__.entrypoint(_validate_string("path", path))

def _googlesource(*, host, repo, ref, path, minimum_version):
    """Defines a reference to package source stored in a googlesource.com repo.

    Args:
      host: a googlesource.com source host name (e.g. `chromium`). Required.
      repo: a name of the repository on the host (e.g. `chromium/src`).
        Required.
      ref: a full git reference (e.g. `refs/heads/main`) to fetch. The history
        of this reference is used to determine the ordering of commits when
        resolving versions of dependencies. Required.
      path: a directory path to the lucicfg package root (a directory with
        PACKAGE.star file) within the source repo. Required.
      minimum_version: a full git commit hash with a minimum compatible version
        of this dependency. In the final resolved dependency set, the dependency
        will be at this revision or newer (in case some other package depends
        on a newer version). Must be reachable from the given git ref. Required.

    Returns:
      A pkg.source.ref struct that can be passed to pkg.depend(...).
    """
    _unused(host, repo, ref, path, minimum_version)
    fail("not implemented")

def _read_submodule(path):
    """Builds a reference to package source by reading a git submodule.

    Works relative to the repository of the package that declared the
    dependency (aka "the current package repository").

    Constructs pkg.source.googlesource(...) by reading the checked in
    `.gitmodules` file of the current package repository to figure out the host,
    the repo, the ref and the minimum version of the dependency identified by
    the given path.

    Recursive submodules are not supported.

    Args:
      path: a relative path from the current package directory to the
        directory with the target dependency (i.e. the directory that contains
        PACKAGE.star file). This directory must be within some git submodule
        path. Required.

    Returns:
      A pkg.source.ref struct that can be passed to pkg.depend(...).
    """
    _unused(path)
    fail("not implemented")

def _read_local(path):
    """Builds a reference to package source stored in the current repository.

    Works relative to the repository of the package that declared the
    dependency (aka "the current package repository").

    Constructs pkg.source.googlesource(...) by taking the source reference of
    the current package and replacing the path there to point to another
    package.

    Args:
      path: a relative path from the current package directory to the
        directory (within the same repository) with the target dependency.
        Required.

    Returns:
      A pkg.source.ref struct that can be passed to pkg.depend(...).
    """
    _unused(path)
    fail("not implemented")

def _fmt_sort_func_args(*, paths, args):
    """Adds a rule for ordering functions arguments in `lucicfg fmt`.

    Args:
      paths: forward-slash delimited path prefixes for which this rule applies.
        lucicfg will organize all rules by path. Rules with duplicate path
        values are not permitted (i.e. you cannot have two rules with a path
        of "something", nor can you have the path "something" duplicated within
        a single rule). When processing files, lucicfg will calculate the file's
        path as relative to the current lucicfg package, and will select a
        single rule set based on the longest matching path prefix. For example,
        if there are two rule sets, one formatting "a" and another formatting
        "a/folder", then for the file "a/folder/file.star", only the second
        rules set would apply. If NO rules set matches the file path, then only
        default formatting will occur. Required.
      args: a list of arguments allows you to reorder the function call sites,
        based on the name of the arguments. If this is set, then all functions
        will be sorted first by the order of its `arg` field, and then
        alphanumerically. This implies that setting this message without setting
        any `arg` values will sort all function call sites alphabetically. The
        sorting only applies to kwarg-style arguments in files matching the
        rule's paths. Required.
    """
    _unused(paths, args)
    fail("not implemented")

def _unused(*args):  # @unused
    """Used exclusively to shut up `unused-variable` lint."""

pkg = struct(
    declare = _declare,
    depend = _depend,
    resources = _resources,
    entrypoint = _entrypoint,
    source = struct(
        googlesource = _googlesource,
        read_submodule = _read_submodule,
        read_local = _read_local,
    ),
    options = struct(
        fmt = struct(
            sort_func_args = _fmt_sort_func_args,
        ),
    ),
)

### Internals.

def _validate_string(attr, val, *, allow_empty = False, default = None, required = True):
    """Validates that the value is a string and returns it.

    Args:
      attr: field name with this value, for error messages.
      val: a value to validate.
      allow_empty: if True, accept empty string as valid.
      default: a value to use if 'val' is None, ignored if required is True.
      required: if False, allow 'val' to be None, return 'default' in this case.

    Returns:
      The validated string or None if required is False and default is None.
    """
    if val == None:
        if required:
            fail("missing required field %r" % attr)
        if default == None:
            return None
        val = default

    if type(val) != "string":
        fail("bad %r: got %s, want string" % (attr, type(val)))
    if not allow_empty and not val:
        fail("bad %r: must not be empty" % (attr,))

    return val
