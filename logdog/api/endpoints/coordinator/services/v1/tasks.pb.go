// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/logdog/api/endpoints/coordinator/services/v1/tasks.proto

package logdog

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The type of archival task.
type ArchiveDispatchTask_Tag int32

const (
	ArchiveDispatchTask_TERMINATED ArchiveDispatchTask_Tag = 0
	ArchiveDispatchTask_EXPIRED    ArchiveDispatchTask_Tag = 1
)

var ArchiveDispatchTask_Tag_name = map[int32]string{
	0: "TERMINATED",
	1: "EXPIRED",
}

var ArchiveDispatchTask_Tag_value = map[string]int32{
	"TERMINATED": 0,
	"EXPIRED":    1,
}

func (x ArchiveDispatchTask_Tag) String() string {
	return proto.EnumName(ArchiveDispatchTask_Tag_name, int32(x))
}

func (ArchiveDispatchTask_Tag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cd952f8ecee7e922, []int{0, 0}
}

// ArchiveDispatchTask is an internal task used by the Coordinator to schedule
// an archival dispatch.
type ArchiveDispatchTask struct {
	// The hash ID for the log stream to archive.
	Id  string                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Tag ArchiveDispatchTask_Tag `protobuf:"varint,2,opt,name=tag,proto3,enum=logdog.ArchiveDispatchTask_Tag" json:"tag,omitempty"`
	// Don't waste time archiving the log stream until it is at least this old.
	//
	// This is in place to prevent overly-aggressive archivals from wasting time
	// trying, then failing, becuase the log stream data is still being collected
	// into intermediate storage.
	SettleDelay *duration.Duration `protobuf:"bytes,3,opt,name=settle_delay,json=settleDelay,proto3" json:"settle_delay,omitempty"`
	// The amount of time after the task was created that log stream completeness
	// will be used as a success criteria. If the task's age is older than this
	// value, completeness will not be enforced.
	//
	// The task's age can be calculated by subtracting its lease expiration time
	// (leaseTimestamp) from its enqueued timestamp (enqueueTimestamp).
	CompletePeriod       *duration.Duration `protobuf:"bytes,4,opt,name=complete_period,json=completePeriod,proto3" json:"complete_period,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ArchiveDispatchTask) Reset()         { *m = ArchiveDispatchTask{} }
func (m *ArchiveDispatchTask) String() string { return proto.CompactTextString(m) }
func (*ArchiveDispatchTask) ProtoMessage()    {}
func (*ArchiveDispatchTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd952f8ecee7e922, []int{0}
}

func (m *ArchiveDispatchTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ArchiveDispatchTask.Unmarshal(m, b)
}
func (m *ArchiveDispatchTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ArchiveDispatchTask.Marshal(b, m, deterministic)
}
func (m *ArchiveDispatchTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveDispatchTask.Merge(m, src)
}
func (m *ArchiveDispatchTask) XXX_Size() int {
	return xxx_messageInfo_ArchiveDispatchTask.Size(m)
}
func (m *ArchiveDispatchTask) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveDispatchTask.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveDispatchTask proto.InternalMessageInfo

func (m *ArchiveDispatchTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ArchiveDispatchTask) GetTag() ArchiveDispatchTask_Tag {
	if m != nil {
		return m.Tag
	}
	return ArchiveDispatchTask_TERMINATED
}

func (m *ArchiveDispatchTask) GetSettleDelay() *duration.Duration {
	if m != nil {
		return m.SettleDelay
	}
	return nil
}

func (m *ArchiveDispatchTask) GetCompletePeriod() *duration.Duration {
	if m != nil {
		return m.CompletePeriod
	}
	return nil
}

// ArchiveTask is a task queue task description for the archival of a single
// log stream.
type ArchiveTask struct {
	// The name of the project that this stream is bound to.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The hash ID of the log stream to archive.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The archival key of the log stream. If this key doesn't match the key in
	// the log stream state, the request is superfluous and should be deleted.
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Don't waste time archiving the log stream until it is at least this old.
	//
	// This is in place to prevent overly-aggressive archivals from wasting time
	// trying, then failing, becuase the log stream data is still being collected
	// into intermediate storage.
	SettleDelay *duration.Duration `protobuf:"bytes,4,opt,name=settle_delay,json=settleDelay,proto3" json:"settle_delay,omitempty"`
	// The amount of time after the task was created that log stream completeness
	// will be used as a success criteria. If the task's age is older than this
	// value, completeness will not be enforced.
	//
	// The task's age can be calculated by subtracting its lease expiration time
	// (leaseTimestamp) from its enqueued timestamp (enqueueTimestamp).
	CompletePeriod *duration.Duration `protobuf:"bytes,5,opt,name=complete_period,json=completePeriod,proto3" json:"complete_period,omitempty"`
	// The time when this archive task was dispatched.
	//
	// This time is optional, and will be based on the Coordinator's clock. If not
	// zero, it can be used by the Archivist to avoid superfluous archival
	// processing by asserting that IF this time is close to the Archivist's local
	// clock by a specific threshold, it will punt the archival task.
	//
	// Because archival is dispatched by Tumble, the actual encoding of archival
	// parameters is oftentimes delayed such that the request is dispatched to
	// Pub/Sub before the datastore has been updated.
	DispatchedAt         *timestamp.Timestamp `protobuf:"bytes,6,opt,name=dispatched_at,json=dispatchedAt,proto3" json:"dispatched_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ArchiveTask) Reset()         { *m = ArchiveTask{} }
func (m *ArchiveTask) String() string { return proto.CompactTextString(m) }
func (*ArchiveTask) ProtoMessage()    {}
func (*ArchiveTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd952f8ecee7e922, []int{1}
}

func (m *ArchiveTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ArchiveTask.Unmarshal(m, b)
}
func (m *ArchiveTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ArchiveTask.Marshal(b, m, deterministic)
}
func (m *ArchiveTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArchiveTask.Merge(m, src)
}
func (m *ArchiveTask) XXX_Size() int {
	return xxx_messageInfo_ArchiveTask.Size(m)
}
func (m *ArchiveTask) XXX_DiscardUnknown() {
	xxx_messageInfo_ArchiveTask.DiscardUnknown(m)
}

var xxx_messageInfo_ArchiveTask proto.InternalMessageInfo

func (m *ArchiveTask) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *ArchiveTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ArchiveTask) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ArchiveTask) GetSettleDelay() *duration.Duration {
	if m != nil {
		return m.SettleDelay
	}
	return nil
}

func (m *ArchiveTask) GetCompletePeriod() *duration.Duration {
	if m != nil {
		return m.CompletePeriod
	}
	return nil
}

func (m *ArchiveTask) GetDispatchedAt() *timestamp.Timestamp {
	if m != nil {
		return m.DispatchedAt
	}
	return nil
}

func init() {
	proto.RegisterEnum("logdog.ArchiveDispatchTask_Tag", ArchiveDispatchTask_Tag_name, ArchiveDispatchTask_Tag_value)
	proto.RegisterType((*ArchiveDispatchTask)(nil), "logdog.ArchiveDispatchTask")
	proto.RegisterType((*ArchiveTask)(nil), "logdog.ArchiveTask")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/logdog/api/endpoints/coordinator/services/v1/tasks.proto", fileDescriptor_cd952f8ecee7e922)
}

var fileDescriptor_cd952f8ecee7e922 = []byte{
	// 377 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xbf, 0x8f, 0xd3, 0x30,
	0x14, 0xc7, 0x49, 0x72, 0xf4, 0x84, 0x53, 0x42, 0x65, 0x96, 0xd0, 0x81, 0xab, 0x32, 0x75, 0xb2,
	0x75, 0xc7, 0x8a, 0x84, 0x8a, 0x92, 0xe1, 0x86, 0xa2, 0x2a, 0xca, 0xc0, 0x56, 0xb9, 0xb6, 0x71,
	0x4d, 0x93, 0x3c, 0xcb, 0x76, 0x2a, 0xf1, 0x3f, 0xf0, 0x37, 0x23, 0xd4, 0xfc, 0x00, 0x89, 0x22,
	0x21, 0x74, 0x5b, 0x62, 0x7f, 0xbe, 0xcf, 0xef, 0xf3, 0x6c, 0xb4, 0x55, 0x40, 0xf8, 0xd1, 0x42,
	0xa3, 0xbb, 0x86, 0x80, 0x55, 0xb4, 0xee, 0xb8, 0xa6, 0x35, 0x28, 0x01, 0x8a, 0x32, 0xa3, 0xa9,
	0x6c, 0x85, 0x01, 0xdd, 0x7a, 0x47, 0x39, 0x80, 0x15, 0xba, 0x65, 0x1e, 0x2c, 0x75, 0xd2, 0x9e,
	0x35, 0x97, 0x8e, 0x9e, 0xef, 0xa9, 0x67, 0xee, 0xe4, 0x88, 0xb1, 0xe0, 0x01, 0xcf, 0x86, 0xe4,
	0xf2, 0xad, 0x02, 0x50, 0xb5, 0xa4, 0xfd, 0xea, 0xa1, 0xfb, 0x42, 0x45, 0x67, 0x99, 0xd7, 0xd0,
	0x0e, 0xdc, 0xf2, 0xee, 0xcf, 0x7d, 0xaf, 0x1b, 0xe9, 0x3c, 0x6b, 0xcc, 0x00, 0x64, 0x3f, 0x02,
	0xf4, 0x7a, 0x63, 0xf9, 0x51, 0x9f, 0x65, 0xae, 0x9d, 0x61, 0x9e, 0x1f, 0x2b, 0xe6, 0x4e, 0x38,
	0x41, 0xa1, 0x16, 0x69, 0xb0, 0x0a, 0xd6, 0x2f, 0xca, 0x50, 0x0b, 0x7c, 0x8f, 0x22, 0xcf, 0x54,
	0x1a, 0xae, 0x82, 0x75, 0xf2, 0x70, 0x47, 0x86, 0xe3, 0xc9, 0x5f, 0x92, 0xa4, 0x62, 0xaa, 0xbc,
	0xb0, 0xf8, 0x3d, 0x9a, 0x3b, 0xe9, 0x7d, 0x2d, 0xf7, 0x42, 0xd6, 0xec, 0x5b, 0x1a, 0xad, 0x82,
	0x75, 0xfc, 0xf0, 0x86, 0x0c, 0x2d, 0x91, 0xa9, 0x25, 0x92, 0x8f, 0x2d, 0x97, 0xf1, 0x80, 0xe7,
	0x17, 0x1a, 0x7f, 0x44, 0xaf, 0x38, 0x34, 0xa6, 0x96, 0x5e, 0xee, 0x8d, 0xb4, 0x1a, 0x44, 0x7a,
	0xf3, 0xaf, 0x02, 0xc9, 0x94, 0xd8, 0xf5, 0x81, 0x2c, 0x43, 0x51, 0xc5, 0x14, 0x4e, 0x10, 0xaa,
	0x8a, 0x72, 0xfb, 0xf8, 0x69, 0x53, 0x15, 0xf9, 0xe2, 0x19, 0x8e, 0xd1, 0x6d, 0xf1, 0x79, 0xf7,
	0x58, 0x16, 0xf9, 0x22, 0xc8, 0xbe, 0x87, 0x28, 0x1e, 0x35, 0x7a, 0xf1, 0x14, 0xdd, 0x1a, 0x0b,
	0x5f, 0x25, 0xf7, 0xa3, 0xfd, 0xf4, 0x3b, 0x8e, 0x24, 0xfc, 0x35, 0x92, 0x05, 0x8a, 0x4e, 0x72,
	0xd0, 0x9a, 0x97, 0x97, 0xcf, 0x2b, 0xe3, 0x9b, 0xa7, 0x1a, 0x3f, 0xff, 0x4f, 0x63, 0xfc, 0x01,
	0xbd, 0x14, 0xe3, 0x65, 0x48, 0xb1, 0x67, 0x3e, 0x9d, 0xf5, 0x15, 0x96, 0x57, 0x15, 0xaa, 0xe9,
	0x1d, 0x94, 0xf3, 0xdf, 0x81, 0x8d, 0x3f, 0xcc, 0x7a, 0xe2, 0xdd, 0xcf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x87, 0x2d, 0x42, 0x0a, 0xb0, 0x02, 0x00, 0x00,
}
