// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto

/*
Package logdog is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto
	go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/state.proto

It has these top-level messages:
	GetRequest
	TailRequest
	GetResponse
	QueryRequest
	QueryResponse
	LogStreamState
*/
package logdog

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import logpb "go.chromium.org/luci/logdog/api/logpb"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf1 "github.com/golang/protobuf/ptypes/duration"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Trinary represents a trinary value.
type QueryRequest_Trinary int32

const (
	// Both positive and negative results will be returned.
	QueryRequest_BOTH QueryRequest_Trinary = 0
	// Only positive results will be returned.
	QueryRequest_YES QueryRequest_Trinary = 1
	// Only negative results will be returned.
	QueryRequest_NO QueryRequest_Trinary = 2
)

var QueryRequest_Trinary_name = map[int32]string{
	0: "BOTH",
	1: "YES",
	2: "NO",
}
var QueryRequest_Trinary_value = map[string]int32{
	"BOTH": 0,
	"YES":  1,
	"NO":   2,
}

func (x QueryRequest_Trinary) String() string {
	return proto.EnumName(QueryRequest_Trinary_name, int32(x))
}
func (QueryRequest_Trinary) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// GetRequest is the request structure for the user Get endpoint.
//
// If the requested log stream exists, a valid GetRequest will succeed
// regardless of whether the requested log range was available.
//
// Note that this endpoint may return fewer logs than requested due to either
// availability or internal constraints.
type GetRequest struct {
	// The request project to request.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The path of the log stream to get.
	//
	// This can either be a LogDog stream path or the SHA256 hash of a LogDog
	// stream path.
	//
	// Some utilities may find passing around a full LogDog path to be cumbersome
	// due to its length. They can opt to pass around the hash instead and
	// retrieve logs using it.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// If true, requests that the log stream's state is returned.
	State bool `protobuf:"varint,3,opt,name=state" json:"state,omitempty"`
	// The initial log stream index to retrieve.
	Index int64 `protobuf:"varint,4,opt,name=index" json:"index,omitempty"`
	// The maximum number of bytes to return. If non-zero, it is applied as a
	// constraint to limit the number of logs that are returned.
	//
	// This only returns complete logs. Assuming logs are available, it will
	// return at least one log (even if it violates the size constraint) and as
	// many additional logs as it can without exceeding this constraint.
	ByteCount int32 `protobuf:"varint,5,opt,name=byte_count,json=byteCount" json:"byte_count,omitempty"`
	// The maximum number of log records to request.
	//
	// If this value is zero, no count constraint will be applied. If this value
	// is less than zero, no log entries will be returned. This can be used to
	// fetch log stream descriptors without fetching any log records.
	LogCount int32 `protobuf:"varint,6,opt,name=log_count,json=logCount" json:"log_count,omitempty"`
	// If true, allows the range request to return non-contiguous records.
	//
	// A contiguous request (default) will iterate forwards from the supplied
	// Index and stop if either the end of stream is encountered or there is a
	// missing stream index. A NonContiguous request will remove the latter
	// condition.
	//
	// For example, say the log stream consists of:
	// [3, 4, 6, 7]
	//
	// A contiguous request with Index 3 will return: [3, 4], stopping because
	// 5 is missing. A non-contiguous request will return [3, 4, 6, 7].
	NonContiguous bool                       `protobuf:"varint,7,opt,name=non_contiguous,json=nonContiguous" json:"non_contiguous,omitempty"`
	GetSignedUrls *GetRequest_SignURLRequest `protobuf:"bytes,8,opt,name=get_signed_urls,json=getSignedUrls" json:"get_signed_urls,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *GetRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GetRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

func (m *GetRequest) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetRequest) GetByteCount() int32 {
	if m != nil {
		return m.ByteCount
	}
	return 0
}

func (m *GetRequest) GetLogCount() int32 {
	if m != nil {
		return m.LogCount
	}
	return 0
}

func (m *GetRequest) GetNonContiguous() bool {
	if m != nil {
		return m.NonContiguous
	}
	return false
}

func (m *GetRequest) GetGetSignedUrls() *GetRequest_SignURLRequest {
	if m != nil {
		return m.GetSignedUrls
	}
	return nil
}

// If supplied, the response will contain a SignedUrls message with the
// requested signed URLs. If signed URLs are not supported by the log's
// current storage system, the response message will be empty.
type GetRequest_SignURLRequest struct {
	// The lifetime that the signed URL will be bound to.. The
	Lifetime *google_protobuf1.Duration `protobuf:"bytes,1,opt,name=lifetime" json:"lifetime,omitempty"`
	// Return a signed URL for the log's RecordIO protobuf data.
	Stream bool `protobuf:"varint,2,opt,name=stream" json:"stream,omitempty"`
	// Return a signed URL for the log's LogIndex protobuf.
	Index bool `protobuf:"varint,3,opt,name=index" json:"index,omitempty"`
}

func (m *GetRequest_SignURLRequest) Reset()                    { *m = GetRequest_SignURLRequest{} }
func (m *GetRequest_SignURLRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest_SignURLRequest) ProtoMessage()               {}
func (*GetRequest_SignURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *GetRequest_SignURLRequest) GetLifetime() *google_protobuf1.Duration {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

func (m *GetRequest_SignURLRequest) GetStream() bool {
	if m != nil {
		return m.Stream
	}
	return false
}

func (m *GetRequest_SignURLRequest) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

// TailRequest is the request structure for the user Tail endpoint. It returns
// the last log in a given log stream at the time of the request.
type TailRequest struct {
	// The request project to request.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The path of the log stream to get.
	//
	// This can either be a LogDog stream path or the SHA256 hash of a LogDog
	// stream path.
	//
	// Some utilities may find passing around a full LogDog path to be cumbersome
	// due to its length. They can opt to pass around the hash instead and
	// retrieve logs using it.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// If true, requests that the log stream's state is returned.
	State bool `protobuf:"varint,3,opt,name=state" json:"state,omitempty"`
}

func (m *TailRequest) Reset()                    { *m = TailRequest{} }
func (m *TailRequest) String() string            { return proto.CompactTextString(m) }
func (*TailRequest) ProtoMessage()               {}
func (*TailRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TailRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *TailRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TailRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

// GetResponse is the response structure for the user Get endpoint.
type GetResponse struct {
	// Project is the project name that these logs belong to.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The log stream descriptor and state for this stream.
	//
	// It can be requested by setting the request's State field to true. If the
	// Proto field is true, the State's Descriptor field will not be included.
	State *LogStreamState `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	// The expanded LogStreamDescriptor protobuf. It is intended for JSON
	// consumption.
	//
	// If the GetRequest's Proto field is false, this will be populated;
	// otherwise, the serialized protobuf will be written to the DescriptorProto
	// field.
	Desc *logpb.LogStreamDescriptor `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
	// Log represents the set of retrieved log records.
	Logs []*logpb.LogEntry `protobuf:"bytes,4,rep,name=logs" json:"logs,omitempty"`
	// An optional signed log entry RecordIO protobuf URL, if requested via
	// "sign_entry_url_lifetime".
	SignedUrls *GetResponse_SignedUrls `protobuf:"bytes,5,opt,name=signed_urls,json=signedUrls" json:"signed_urls,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetResponse) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *GetResponse) GetState() *LogStreamState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *GetResponse) GetDesc() *logpb.LogStreamDescriptor {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *GetResponse) GetLogs() []*logpb.LogEntry {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *GetResponse) GetSignedUrls() *GetResponse_SignedUrls {
	if m != nil {
		return m.SignedUrls
	}
	return nil
}

// Holds information about the log stream's signed entry URL.
type GetResponse_SignedUrls struct {
	// The time when this signed URL will expire.
	Expiration *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=expiration" json:"expiration,omitempty"`
	// The signed log stream URL, if requested.
	Stream string `protobuf:"bytes,2,opt,name=stream" json:"stream,omitempty"`
	// The signed log index URL, if requested.
	Index string `protobuf:"bytes,3,opt,name=index" json:"index,omitempty"`
}

func (m *GetResponse_SignedUrls) Reset()                    { *m = GetResponse_SignedUrls{} }
func (m *GetResponse_SignedUrls) String() string            { return proto.CompactTextString(m) }
func (*GetResponse_SignedUrls) ProtoMessage()               {}
func (*GetResponse_SignedUrls) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *GetResponse_SignedUrls) GetExpiration() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *GetResponse_SignedUrls) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *GetResponse_SignedUrls) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

// QueryRequest is the request structure for the user Query endpoint.
type QueryRequest struct {
	// The request project to request.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The query parameter.
	//
	// The path expression may substitute a glob ("*") for a specific path
	// component. That is, any stream that matches the remaining structure qualifies
	// regardless of its value in that specific positional field.
	//
	// An unbounded wildcard may appear as a component at the end of both the
	// prefix and name query components. "**" matches all remaining components.
	//
	// If the supplied path query does not contain a path separator ("+"), it will
	// be treated as if the prefix is "**".
	//
	// Examples:
	//   - Empty ("") will return all streams.
	//   - **/+/** will return all streams.
	//   - foo/bar/** will return all streams with the "foo/bar" prefix.
	//   - foo/bar/**/+/baz will return all streams beginning with the "foo/bar"
	//     prefix and named "baz" (e.g., "foo/bar/qux/lol/+/baz")
	//   - foo/bar/+/** will return all streams with a "foo/bar" prefix.
	//   - foo/*/+/baz will return all streams with a two-component prefix whose
	//     first value is "foo" and whose name is "baz".
	//   - foo/bar will return all streams whose name is "foo/bar".
	//   - */* will return all streams with two-component names.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// If true, returns that the streams' full state is returned instead of just
	// its Path.
	State bool `protobuf:"varint,3,opt,name=state" json:"state,omitempty"`
	// If true, causes the requested state to be returned as serialized protobuf
	// data instead of deserialized JSON structures.
	Proto bool `protobuf:"varint,4,opt,name=proto" json:"proto,omitempty"`
	// Next, if not empty, indicates that this query should continue at the point
	// where the previous query left off.
	Next string `protobuf:"bytes,5,opt,name=next" json:"next,omitempty"`
	// MaxResults is the maximum number of query results to return.
	//
	// If MaxResults is zero, no upper bound will be indicated. However, the
	// returned result count is still be subject to internal constraints.
	MaxResults int32 `protobuf:"varint,6,opt,name=max_results,json=maxResults" json:"max_results,omitempty"`
	// ContentType, if not empty, restricts results to streams with the supplied
	// content type.
	ContentType string                         `protobuf:"bytes,10,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	StreamType  *QueryRequest_StreamTypeFilter `protobuf:"bytes,11,opt,name=stream_type,json=streamType" json:"stream_type,omitempty"`
	// Newer restricts results to streams created after the specified date.
	Newer *google_protobuf.Timestamp `protobuf:"bytes,12,opt,name=newer" json:"newer,omitempty"`
	// Older restricts results to streams created before the specified date.
	Older *google_protobuf.Timestamp `protobuf:"bytes,13,opt,name=older" json:"older,omitempty"`
	// If not empty, constrains the results to those whose protobuf version string
	// matches the supplied version.
	ProtoVersion string `protobuf:"bytes,14,opt,name=proto_version,json=protoVersion" json:"proto_version,omitempty"`
	// Tags is the set of tags to constrain the query with.
	//
	// A Tag entry may either be:
	// - A key/value query, in which case the results are constrained by logs
	//   whose tag includes that key/value pair.
	// - A key with an missing (nil) value, in which case the results are
	//   constraints by logs that have that tag key, regardless of its value.
	Tags map[string]string `protobuf:"bytes,15,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Purged restricts the query to streams that have or haven't been purged.
	Purged QueryRequest_Trinary `protobuf:"varint,16,opt,name=purged,enum=logdog.QueryRequest_Trinary" json:"purged,omitempty"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (m *QueryRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QueryRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *QueryRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *QueryRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

func (m *QueryRequest) GetProto() bool {
	if m != nil {
		return m.Proto
	}
	return false
}

func (m *QueryRequest) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

func (m *QueryRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *QueryRequest) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *QueryRequest) GetStreamType() *QueryRequest_StreamTypeFilter {
	if m != nil {
		return m.StreamType
	}
	return nil
}

func (m *QueryRequest) GetNewer() *google_protobuf.Timestamp {
	if m != nil {
		return m.Newer
	}
	return nil
}

func (m *QueryRequest) GetOlder() *google_protobuf.Timestamp {
	if m != nil {
		return m.Older
	}
	return nil
}

func (m *QueryRequest) GetProtoVersion() string {
	if m != nil {
		return m.ProtoVersion
	}
	return ""
}

func (m *QueryRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *QueryRequest) GetPurged() QueryRequest_Trinary {
	if m != nil {
		return m.Purged
	}
	return QueryRequest_BOTH
}

// The stream type to filter on.
type QueryRequest_StreamTypeFilter struct {
	// The StreamType value to filter on.
	Value logpb.StreamType `protobuf:"varint,1,opt,name=value,enum=logpb.StreamType" json:"value,omitempty"`
}

func (m *QueryRequest_StreamTypeFilter) Reset()         { *m = QueryRequest_StreamTypeFilter{} }
func (m *QueryRequest_StreamTypeFilter) String() string { return proto.CompactTextString(m) }
func (*QueryRequest_StreamTypeFilter) ProtoMessage()    {}
func (*QueryRequest_StreamTypeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 0}
}

func (m *QueryRequest_StreamTypeFilter) GetValue() logpb.StreamType {
	if m != nil {
		return m.Value
	}
	return logpb.StreamType_TEXT
}

// QueryResponse is the response structure for the user Query endpoint.
type QueryResponse struct {
	// Project is the project name that all responses belong to.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The list of streams that were identified as the result of the query.
	Streams []*QueryResponse_Stream `protobuf:"bytes,2,rep,name=streams" json:"streams,omitempty"`
	// If not empty, indicates that there are more query results available.
	// These results can be requested by repeating the Query request with the
	// same Path field and supplying this value in the Next field.
	Next string `protobuf:"bytes,3,opt,name=next" json:"next,omitempty"`
}

func (m *QueryResponse) Reset()                    { *m = QueryResponse{} }
func (m *QueryResponse) String() string            { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()               {}
func (*QueryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueryResponse) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *QueryResponse) GetStreams() []*QueryResponse_Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

func (m *QueryResponse) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

// Stream represents a single query response stream.
type QueryResponse_Stream struct {
	// Path is the log stream path.
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// State is the log stream descriptor and state for this stream.
	//
	// It can be requested by setting the request's State field to true. If the
	// Proto field is true, the State's Descriptor field will not be included.
	State *LogStreamState `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	// The JSON-packed log stream descriptor protobuf.
	//
	// A Descriptor entry corresponds to the Path with the same index.
	//
	// If the query request's State field is set, the descriptor will be
	// populated. If the Proto field is false, Descriptor will be populated;
	// otherwise, DescriptorProto will be populated with the serialized descriptor
	// protobuf.
	Desc *logpb.LogStreamDescriptor `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
	// The serialized log stream Descriptor protobuf.
	DescProto []byte `protobuf:"bytes,4,opt,name=desc_proto,json=descProto,proto3" json:"desc_proto,omitempty"`
}

func (m *QueryResponse_Stream) Reset()                    { *m = QueryResponse_Stream{} }
func (m *QueryResponse_Stream) String() string            { return proto.CompactTextString(m) }
func (*QueryResponse_Stream) ProtoMessage()               {}
func (*QueryResponse_Stream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *QueryResponse_Stream) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *QueryResponse_Stream) GetState() *LogStreamState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *QueryResponse_Stream) GetDesc() *logpb.LogStreamDescriptor {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *QueryResponse_Stream) GetDescProto() []byte {
	if m != nil {
		return m.DescProto
	}
	return nil
}

func init() {
	proto.RegisterType((*GetRequest)(nil), "logdog.GetRequest")
	proto.RegisterType((*GetRequest_SignURLRequest)(nil), "logdog.GetRequest.SignURLRequest")
	proto.RegisterType((*TailRequest)(nil), "logdog.TailRequest")
	proto.RegisterType((*GetResponse)(nil), "logdog.GetResponse")
	proto.RegisterType((*GetResponse_SignedUrls)(nil), "logdog.GetResponse.SignedUrls")
	proto.RegisterType((*QueryRequest)(nil), "logdog.QueryRequest")
	proto.RegisterType((*QueryRequest_StreamTypeFilter)(nil), "logdog.QueryRequest.StreamTypeFilter")
	proto.RegisterType((*QueryResponse)(nil), "logdog.QueryResponse")
	proto.RegisterType((*QueryResponse_Stream)(nil), "logdog.QueryResponse.Stream")
	proto.RegisterEnum("logdog.QueryRequest_Trinary", QueryRequest_Trinary_name, QueryRequest_Trinary_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Logs service

type LogsClient interface {
	// Get returns state and log data for a single log stream.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Tail returns the last log in the log stream at the time of the request.
	Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Query returns log stream paths that match the requested query.
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
}
type logsPRPCClient struct {
	client *prpc.Client
}

func NewLogsPRPCClient(client *prpc.Client) LogsClient {
	return &logsPRPCClient{client}
}

func (c *logsPRPCClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsPRPCClient) Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Tail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsPRPCClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type logsClient struct {
	cc *grpc.ClientConn
}

func NewLogsClient(cc *grpc.ClientConn) LogsClient {
	return &logsClient{cc}
}

func (c *logsClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/logdog.Logs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsClient) Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/logdog.Logs/Tail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := grpc.Invoke(ctx, "/logdog.Logs/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Logs service

type LogsServer interface {
	// Get returns state and log data for a single log stream.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Tail returns the last log in the log stream at the time of the request.
	Tail(context.Context, *TailRequest) (*GetResponse, error)
	// Query returns log stream paths that match the requested query.
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
}

func RegisterLogsServer(s prpc.Registrar, srv LogsServer) {
	s.RegisterService(&_Logs_serviceDesc, srv)
}

func _Logs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logs_Tail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Tail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Tail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Tail(ctx, req.(*TailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logs_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Logs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "logdog.Logs",
	HandlerType: (*LogsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Logs_Get_Handler,
		},
		{
			MethodName: "Tail",
			Handler:    _Logs_Tail_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _Logs_Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto",
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 911 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0xae, 0xdb, 0x44,
	0x10, 0xc6, 0x89, 0xf3, 0x37, 0x4e, 0x72, 0xc2, 0x52, 0x2a, 0x63, 0xe8, 0x69, 0x9a, 0x52, 0x91,
	0x0b, 0x64, 0x97, 0x50, 0x7e, 0x54, 0x2e, 0x90, 0xe8, 0xbf, 0x74, 0x44, 0xe9, 0x26, 0x45, 0xe2,
	0x2a, 0xf2, 0x89, 0xb7, 0x5b, 0x83, 0xb3, 0x6b, 0x76, 0xd7, 0x87, 0xe4, 0x19, 0xb8, 0xe2, 0x0a,
	0x71, 0xc3, 0xcb, 0xf1, 0x22, 0x68, 0x77, 0xed, 0x38, 0x3d, 0x8d, 0xc8, 0x05, 0xed, 0x4d, 0xec,
	0x99, 0xf9, 0x66, 0xbd, 0xf3, 0x7d, 0x33, 0x13, 0x78, 0x4c, 0x79, 0xb8, 0x7a, 0x29, 0xf8, 0x3a,
	0x2d, 0xd6, 0x21, 0x17, 0x34, 0xca, 0x8a, 0x55, 0x1a, 0x65, 0x9c, 0x26, 0x9c, 0x46, 0x71, 0x9e,
	0x46, 0x84, 0x25, 0x39, 0x4f, 0x99, 0x92, 0xd1, 0x8a, 0x73, 0x91, 0xa4, 0x2c, 0x56, 0x5c, 0x68,
	0x80, 0x8c, 0x2e, 0x3e, 0x33, 0xcf, 0x30, 0x17, 0x5c, 0x71, 0xd4, 0xb6, 0x49, 0xc1, 0x93, 0xff,
	0x77, 0xa2, 0x54, 0xb1, 0x22, 0xf6, 0xc8, 0x20, 0x3a, 0x76, 0x54, 0xc6, 0x69, 0x7e, 0xae, 0x7f,
	0xcb, 0x84, 0xeb, 0x94, 0x73, 0x9a, 0x91, 0xc8, 0x58, 0xe7, 0xc5, 0x8b, 0x48, 0xa5, 0x6b, 0x22,
	0x55, 0xbc, 0xce, 0x4b, 0xc0, 0xe9, 0x65, 0x40, 0x52, 0x88, 0x58, 0xa5, 0x9c, 0xd9, 0xf8, 0xe4,
	0xf7, 0x26, 0xc0, 0x23, 0xa2, 0x30, 0xf9, 0xb5, 0x20, 0x52, 0x21, 0x1f, 0x3a, 0xb9, 0xe0, 0x3f,
	0x93, 0x95, 0xf2, 0x9d, 0xb1, 0x33, 0xed, 0xe1, 0xca, 0x44, 0x08, 0xdc, 0x3c, 0x56, 0x2f, 0xfd,
	0x86, 0x71, 0x9b, 0x77, 0x74, 0x05, 0x5a, 0xe6, 0xf6, 0x7e, 0x73, 0xec, 0x4c, 0xbb, 0xd8, 0x1a,
	0xda, 0x9b, 0xb2, 0x84, 0x6c, 0x7c, 0x77, 0xec, 0x4c, 0x9b, 0xd8, 0x1a, 0xe8, 0x1a, 0xc0, 0xf9,
	0x56, 0x91, 0xe5, 0x8a, 0x17, 0x4c, 0xf9, 0xad, 0xb1, 0x33, 0x6d, 0xe1, 0x9e, 0xf6, 0xdc, 0xd3,
	0x0e, 0xf4, 0x21, 0xf4, 0x32, 0x4e, 0xcb, 0x68, 0xdb, 0x44, 0xbb, 0x19, 0xa7, 0x36, 0x78, 0x0b,
	0x86, 0x8c, 0xb3, 0xe5, 0x8a, 0x33, 0x95, 0xd2, 0x82, 0x17, 0xd2, 0xef, 0x98, 0x0f, 0x0e, 0x18,
	0x67, 0xf7, 0x76, 0x4e, 0xf4, 0x04, 0x4e, 0x28, 0x51, 0x4b, 0x99, 0x52, 0x46, 0x92, 0x65, 0x21,
	0x32, 0xe9, 0x77, 0xc7, 0xce, 0xd4, 0x9b, 0xdd, 0x08, 0x2d, 0x85, 0x61, 0x5d, 0x69, 0x38, 0x4f,
	0x29, 0x7b, 0x8e, 0xcf, 0x4a, 0x13, 0x0f, 0x28, 0x51, 0x73, 0x93, 0xf8, 0x5c, 0x64, 0x32, 0x28,
	0x60, 0xf8, 0x2a, 0x00, 0x7d, 0x01, 0xdd, 0x2c, 0x7d, 0x41, 0x34, 0xbf, 0x86, 0x1a, 0x6f, 0xf6,
	0x41, 0x68, 0xb9, 0x0d, 0x2b, 0x6e, 0xc3, 0xfb, 0x25, 0xb7, 0x78, 0x07, 0x45, 0x57, 0xa1, 0x2d,
	0x95, 0x20, 0xf1, 0xda, 0x10, 0xd7, 0xc5, 0xa5, 0x55, 0x93, 0x54, 0x52, 0x67, 0x8c, 0xc9, 0x33,
	0xf0, 0x16, 0x71, 0x9a, 0xbd, 0x41, 0x35, 0x26, 0xff, 0x34, 0xc0, 0x33, 0x65, 0xcb, 0x9c, 0x33,
	0x49, 0xfe, 0xe3, 0xcc, 0x4f, 0xab, 0xfc, 0x86, 0x29, 0xef, 0x6a, 0x45, 0xda, 0x19, 0xa7, 0x73,
	0x73, 0xe9, 0xb9, 0x8e, 0x56, 0x2a, 0x87, 0xe0, 0x26, 0x44, 0xae, 0xcc, 0xc7, 0xbc, 0x59, 0x10,
	0x9a, 0xce, 0xac, 0xb1, 0xf7, 0x89, 0x5c, 0x89, 0x34, 0x57, 0x5c, 0x60, 0x83, 0x43, 0x37, 0xc1,
	0xd5, 0x1d, 0xef, 0xbb, 0xe3, 0xe6, 0xd4, 0x9b, 0x9d, 0xd4, 0xf8, 0x07, 0x4c, 0x89, 0x2d, 0x36,
	0x41, 0xf4, 0x2d, 0x78, 0xfb, 0xea, 0xb5, 0xcc, 0xd9, 0xa7, 0xaf, 0xa8, 0x67, 0xcb, 0x08, 0x6b,
	0xad, 0x30, 0xc8, 0x5a, 0xb7, 0x0b, 0x80, 0x3a, 0x82, 0xee, 0x02, 0x90, 0x4d, 0x9e, 0x5a, 0x51,
	0x4a, 0xd5, 0x82, 0xd7, 0x54, 0x5b, 0x54, 0x23, 0x83, 0xf7, 0xd0, 0x97, 0x84, 0xeb, 0x1d, 0x16,
	0xae, 0x57, 0x09, 0xf7, 0x67, 0x0b, 0xfa, 0xcf, 0x0a, 0x22, 0xb6, 0x6f, 0x78, 0x90, 0xcc, 0x25,
	0xcd, 0x20, 0x75, 0xb1, 0x35, 0x74, 0x3e, 0x23, 0x1b, 0x3b, 0x42, 0x3d, 0x6c, 0xde, 0xd1, 0x75,
	0xf0, 0xd6, 0xf1, 0x66, 0x29, 0x88, 0x2c, 0x32, 0x25, 0xcb, 0xf9, 0x81, 0x75, 0xbc, 0xc1, 0xd6,
	0x83, 0x6e, 0x40, 0x5f, 0x4f, 0x0f, 0x61, 0x6a, 0xa9, 0xb6, 0x39, 0xf1, 0xc1, 0x24, 0x7b, 0xa5,
	0x6f, 0xb1, 0xcd, 0x09, 0x7a, 0x08, 0x9e, 0x2d, 0xd1, 0x22, 0x3c, 0xc3, 0xd6, 0xad, 0x8a, 0xfb,
	0xfd, 0xe2, 0x42, 0x2b, 0xb1, 0xce, 0x7a, 0x98, 0x66, 0x8a, 0x08, 0x0c, 0x72, 0xe7, 0x41, 0xb7,
	0xa1, 0xc5, 0xc8, 0x6f, 0x44, 0xf8, 0xfd, 0xa3, 0x7c, 0x5b, 0xa0, 0xce, 0xe0, 0x59, 0x42, 0x84,
	0x3f, 0x38, 0x9e, 0x61, 0x80, 0xe8, 0x26, 0x0c, 0x4c, 0x70, 0x79, 0x41, 0x84, 0xd4, 0xda, 0x0e,
	0x4d, 0x3d, 0x7d, 0xe3, 0xfc, 0xd1, 0xfa, 0xd0, 0x0c, 0x5c, 0x15, 0x53, 0xe9, 0x9f, 0x98, 0x8e,
	0x3b, 0x3d, 0x58, 0xc9, 0x22, 0xa6, 0xb2, 0x6c, 0x40, 0x8d, 0x45, 0x77, 0xa0, 0x9d, 0x17, 0x82,
	0x92, 0xc4, 0x1f, 0x8d, 0x9d, 0xe9, 0x70, 0xf6, 0xd1, 0xe1, 0x2c, 0x91, 0xb2, 0x58, 0x6c, 0x71,
	0x89, 0x0d, 0xbe, 0x81, 0xd1, 0x65, 0x4a, 0xd0, 0x27, 0xd0, 0xba, 0x88, 0xb3, 0xc2, 0x2e, 0x8b,
	0xe1, 0xec, 0xdd, 0xb2, 0xe1, 0x6b, 0x1c, 0xb6, 0xf1, 0xe0, 0x2b, 0xe8, 0xed, 0x6e, 0x81, 0x46,
	0xd0, 0xfc, 0x85, 0x6c, 0xcb, 0x96, 0xd1, 0xaf, 0xba, 0x09, 0xec, 0x39, 0xb6, 0x5f, 0xac, 0x71,
	0xb7, 0xf1, 0xb5, 0x33, 0xf9, 0x18, 0x3a, 0xe5, 0x45, 0x50, 0x17, 0xdc, 0xef, 0x9e, 0x2e, 0x1e,
	0x8f, 0xde, 0x41, 0x1d, 0x68, 0xfe, 0xf4, 0x60, 0x3e, 0x72, 0x50, 0x1b, 0x1a, 0xdf, 0x3f, 0x1d,
	0x35, 0x26, 0x7f, 0x34, 0x60, 0x50, 0x5e, 0xfe, 0xe8, 0x06, 0xf8, 0x12, 0x3a, 0x56, 0x48, 0xe9,
	0x37, 0x0c, 0x69, 0x97, 0xcb, 0xaf, 0x86, 0xcf, 0x80, 0x70, 0x05, 0xde, 0xb5, 0x64, 0xb3, 0x6e,
	0xc9, 0xe0, 0x2f, 0x07, 0xda, 0x16, 0xb7, 0xeb, 0x78, 0x67, 0xaf, 0xe3, 0xdf, 0xee, 0xb2, 0xb9,
	0x06, 0xa0, 0x9f, 0xcb, 0x7a, 0x7c, 0xfa, 0xb8, 0xa7, 0x3d, 0x3f, 0x68, 0xc7, 0xec, 0x6f, 0x07,
	0xdc, 0x33, 0xbd, 0x6f, 0x42, 0x68, 0x3e, 0x22, 0x0a, 0xa1, 0xd7, 0xff, 0x1f, 0x82, 0xf7, 0x0e,
	0x6c, 0x1d, 0x74, 0x1b, 0x5c, 0xbd, 0x9f, 0xd1, 0x2e, 0xb8, 0xb7, 0xad, 0x0f, 0x67, 0xdc, 0x81,
	0x96, 0xe1, 0x0e, 0x5d, 0x39, 0xd4, 0x49, 0xc1, 0xfb, 0x07, 0x09, 0x3e, 0x6f, 0x9b, 0x8b, 0x7f,
	0xfe, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb0, 0xa0, 0x4f, 0x31, 0xad, 0x08, 0x00, 0x00,
}
