// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: go.chromium.org/luci/cv/internal/tryjob/storage.proto

package tryjob

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	buildbucketpb "go.chromium.org/luci/buildbucket/proto"

	cfgpb "go.chromium.org/luci/cv/api/config/v2"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = buildbucketpb.Status(0)

	_ = cfgpb.CommentLevel(0)
)

// Validate checks the field values on Definition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Definition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Definition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefinitionMultiError, or
// nil if none found.
func (m *Definition) ValidateAll() error {
	return m.validate(true)
}

func (m *Definition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEquivalentTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "EquivalentTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "EquivalentTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEquivalentTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefinitionValidationError{
				field:  "EquivalentTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DisableReuse

	// no validation rules for SkipStaleCheck

	// no validation rules for Critical

	// no validation rules for Optional

	// no validation rules for ResultVisibility

	switch v := m.Backend.(type) {
	case *Definition_Buildbucket_:
		if v == nil {
			err := DefinitionValidationError{
				field:  "Backend",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBuildbucket()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DefinitionValidationError{
						field:  "Buildbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DefinitionValidationError{
						field:  "Buildbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBuildbucket()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DefinitionValidationError{
					field:  "Buildbucket",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DefinitionMultiError(errors)
	}

	return nil
}

// DefinitionMultiError is an error wrapping multiple validation errors
// returned by Definition.ValidateAll() if the designated constraints aren't met.
type DefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefinitionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefinitionMultiError) AllErrors() []error { return m }

// DefinitionValidationError is the validation error returned by
// Definition.Validate if the designated constraints aren't met.
type DefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefinitionValidationError) ErrorName() string { return "DefinitionValidationError" }

// Error satisfies the builtin error interface
func (e DefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefinitionValidationError{}

// Validate checks the field values on Requirement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Requirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Requirement with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequirementMultiError, or
// nil if none found.
func (m *Requirement) ValidateAll() error {
	return m.validate(true)
}

func (m *Requirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequirementValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequirementValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequirementValidationError{
					field:  fmt.Sprintf("Definitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRetryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequirementValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequirementValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequirementValidationError{
				field:  "RetryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RequirementMultiError(errors)
	}

	return nil
}

// RequirementMultiError is an error wrapping multiple validation errors
// returned by Requirement.ValidateAll() if the designated constraints aren't met.
type RequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequirementMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequirementMultiError) AllErrors() []error { return m }

// RequirementValidationError is the validation error returned by
// Requirement.Validate if the designated constraints aren't met.
type RequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequirementValidationError) ErrorName() string { return "RequirementValidationError" }

// Error satisfies the builtin error interface
func (e RequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequirementValidationError{}

// Validate checks the field values on Result with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Result) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Result with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResultMultiError, or nil if none found.
func (m *Result) ValidateAll() error {
	return m.validate(true)
}

func (m *Result) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResultValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResultValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResultValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResultValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Backend.(type) {
	case *Result_Buildbucket_:
		if v == nil {
			err := ResultValidationError{
				field:  "Backend",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBuildbucket()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResultValidationError{
						field:  "Buildbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResultValidationError{
						field:  "Buildbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBuildbucket()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResultValidationError{
					field:  "Buildbucket",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResultMultiError(errors)
	}

	return nil
}

// ResultMultiError is an error wrapping multiple validation errors returned by
// Result.ValidateAll() if the designated constraints aren't met.
type ResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResultMultiError) AllErrors() []error { return m }

// ResultValidationError is the validation error returned by Result.Validate if
// the designated constraints aren't met.
type ResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResultValidationError) ErrorName() string { return "ResultValidationError" }

// Error satisfies the builtin error interface
func (e ResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResultValidationError{}

// Validate checks the field values on ExecutionState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionStateMultiError,
// or nil if none found.
func (m *ExecutionState) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExecutions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionStateValidationError{
						field:  fmt.Sprintf("Executions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionStateValidationError{
						field:  fmt.Sprintf("Executions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionStateValidationError{
					field:  fmt.Sprintf("Executions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRequirement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "Requirement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "Requirement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequirement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionStateValidationError{
				field:  "Requirement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequirementVersion

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetFailures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "Failures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "Failures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionStateValidationError{
				field:  "Failures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionStateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionStateValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FirstTryjobLatencyMetricsReported

	if len(errors) > 0 {
		return ExecutionStateMultiError(errors)
	}

	return nil
}

// ExecutionStateMultiError is an error wrapping multiple validation errors
// returned by ExecutionState.ValidateAll() if the designated constraints
// aren't met.
type ExecutionStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionStateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionStateMultiError) AllErrors() []error { return m }

// ExecutionStateValidationError is the validation error returned by
// ExecutionState.Validate if the designated constraints aren't met.
type ExecutionStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionStateValidationError) ErrorName() string { return "ExecutionStateValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionStateValidationError{}

// Validate checks the field values on ExecutionLogEntries with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionLogEntries) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntries with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecutionLogEntriesMultiError, or nil if none found.
func (m *ExecutionLogEntries) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntries) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntriesValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntriesValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntriesValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionLogEntriesMultiError(errors)
	}

	return nil
}

// ExecutionLogEntriesMultiError is an error wrapping multiple validation
// errors returned by ExecutionLogEntries.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntriesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntriesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntriesMultiError) AllErrors() []error { return m }

// ExecutionLogEntriesValidationError is the validation error returned by
// ExecutionLogEntries.Validate if the designated constraints aren't met.
type ExecutionLogEntriesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntriesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntriesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntriesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntriesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntriesValidationError) ErrorName() string {
	return "ExecutionLogEntriesValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntriesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntries.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntriesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntriesValidationError{}

// Validate checks the field values on ExecutionLogEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecutionLogEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecutionLogEntryMultiError, or nil if none found.
func (m *ExecutionLogEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionLogEntryValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionLogEntryValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionLogEntryValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Kind.(type) {
	case *ExecutionLogEntry_RequirementChanged_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRequirementChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "RequirementChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "RequirementChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequirementChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "RequirementChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_TryjobsLaunched_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTryjobsLaunched()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsLaunched",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsLaunched",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryjobsLaunched()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "TryjobsLaunched",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_TryjobsLaunchFailed_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTryjobsLaunchFailed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsLaunchFailed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsLaunchFailed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryjobsLaunchFailed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "TryjobsLaunchFailed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_TryjobsReused_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTryjobsReused()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsReused",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsReused",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryjobsReused()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "TryjobsReused",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_TryjobsEnded_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTryjobsEnded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsEnded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobsEnded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryjobsEnded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "TryjobsEnded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_TryjobDiscarded_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTryjobDiscarded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobDiscarded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "TryjobDiscarded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryjobDiscarded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "TryjobDiscarded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecutionLogEntry_RetryDenied_:
		if v == nil {
			err := ExecutionLogEntryValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRetryDenied()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "RetryDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntryValidationError{
						field:  "RetryDenied",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRetryDenied()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntryValidationError{
					field:  "RetryDenied",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExecutionLogEntryMultiError(errors)
	}

	return nil
}

// ExecutionLogEntryMultiError is an error wrapping multiple validation errors
// returned by ExecutionLogEntry.ValidateAll() if the designated constraints
// aren't met.
type ExecutionLogEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntryMultiError) AllErrors() []error { return m }

// ExecutionLogEntryValidationError is the validation error returned by
// ExecutionLogEntry.Validate if the designated constraints aren't met.
type ExecutionLogEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntryValidationError) ErrorName() string {
	return "ExecutionLogEntryValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntryValidationError{}

// Validate checks the field values on TryjobUpdatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TryjobUpdatedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TryjobUpdatedEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TryjobUpdatedEventMultiError, or nil if none found.
func (m *TryjobUpdatedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TryjobUpdatedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TryjobId

	if len(errors) > 0 {
		return TryjobUpdatedEventMultiError(errors)
	}

	return nil
}

// TryjobUpdatedEventMultiError is an error wrapping multiple validation errors
// returned by TryjobUpdatedEvent.ValidateAll() if the designated constraints
// aren't met.
type TryjobUpdatedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TryjobUpdatedEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TryjobUpdatedEventMultiError) AllErrors() []error { return m }

// TryjobUpdatedEventValidationError is the validation error returned by
// TryjobUpdatedEvent.Validate if the designated constraints aren't met.
type TryjobUpdatedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TryjobUpdatedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TryjobUpdatedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TryjobUpdatedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TryjobUpdatedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TryjobUpdatedEventValidationError) ErrorName() string {
	return "TryjobUpdatedEventValidationError"
}

// Error satisfies the builtin error interface
func (e TryjobUpdatedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTryjobUpdatedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TryjobUpdatedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TryjobUpdatedEventValidationError{}

// Validate checks the field values on TryjobUpdatedEvents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TryjobUpdatedEvents) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TryjobUpdatedEvents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TryjobUpdatedEventsMultiError, or nil if none found.
func (m *TryjobUpdatedEvents) ValidateAll() error {
	return m.validate(true)
}

func (m *TryjobUpdatedEvents) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TryjobUpdatedEventsValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TryjobUpdatedEventsValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TryjobUpdatedEventsValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TryjobUpdatedEventsMultiError(errors)
	}

	return nil
}

// TryjobUpdatedEventsMultiError is an error wrapping multiple validation
// errors returned by TryjobUpdatedEvents.ValidateAll() if the designated
// constraints aren't met.
type TryjobUpdatedEventsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TryjobUpdatedEventsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TryjobUpdatedEventsMultiError) AllErrors() []error { return m }

// TryjobUpdatedEventsValidationError is the validation error returned by
// TryjobUpdatedEvents.Validate if the designated constraints aren't met.
type TryjobUpdatedEventsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TryjobUpdatedEventsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TryjobUpdatedEventsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TryjobUpdatedEventsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TryjobUpdatedEventsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TryjobUpdatedEventsValidationError) ErrorName() string {
	return "TryjobUpdatedEventsValidationError"
}

// Error satisfies the builtin error interface
func (e TryjobUpdatedEventsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTryjobUpdatedEvents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TryjobUpdatedEventsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TryjobUpdatedEventsValidationError{}

// Validate checks the field values on Definition_Buildbucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Definition_Buildbucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Definition_Buildbucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Definition_BuildbucketMultiError, or nil if none found.
func (m *Definition_Buildbucket) ValidateAll() error {
	return m.validate(true)
}

func (m *Definition_Buildbucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	if all {
		switch v := interface{}(m.GetBuilder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Definition_BuildbucketValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Definition_BuildbucketValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuilder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Definition_BuildbucketValidationError{
				field:  "Builder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Definition_BuildbucketMultiError(errors)
	}

	return nil
}

// Definition_BuildbucketMultiError is an error wrapping multiple validation
// errors returned by Definition_Buildbucket.ValidateAll() if the designated
// constraints aren't met.
type Definition_BuildbucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Definition_BuildbucketMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Definition_BuildbucketMultiError) AllErrors() []error { return m }

// Definition_BuildbucketValidationError is the validation error returned by
// Definition_Buildbucket.Validate if the designated constraints aren't met.
type Definition_BuildbucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Definition_BuildbucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Definition_BuildbucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Definition_BuildbucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Definition_BuildbucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Definition_BuildbucketValidationError) ErrorName() string {
	return "Definition_BuildbucketValidationError"
}

// Error satisfies the builtin error interface
func (e Definition_BuildbucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefinition_Buildbucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Definition_BuildbucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Definition_BuildbucketValidationError{}

// Validate checks the field values on Result_Buildbucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Result_Buildbucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Result_Buildbucket with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Result_BuildbucketMultiError, or nil if none found.
func (m *Result_Buildbucket) ValidateAll() error {
	return m.validate(true)
}

func (m *Result_Buildbucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetBuilder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Result_BuildbucketValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Result_BuildbucketValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuilder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Result_BuildbucketValidationError{
				field:  "Builder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for SummaryMarkdown

	if all {
		switch v := interface{}(m.GetInfra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Result_BuildbucketValidationError{
					field:  "Infra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Result_BuildbucketValidationError{
					field:  "Infra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Result_BuildbucketValidationError{
				field:  "Infra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Result_BuildbucketMultiError(errors)
	}

	return nil
}

// Result_BuildbucketMultiError is an error wrapping multiple validation errors
// returned by Result_Buildbucket.ValidateAll() if the designated constraints
// aren't met.
type Result_BuildbucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Result_BuildbucketMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Result_BuildbucketMultiError) AllErrors() []error { return m }

// Result_BuildbucketValidationError is the validation error returned by
// Result_Buildbucket.Validate if the designated constraints aren't met.
type Result_BuildbucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Result_BuildbucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Result_BuildbucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Result_BuildbucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Result_BuildbucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Result_BuildbucketValidationError) ErrorName() string {
	return "Result_BuildbucketValidationError"
}

// Error satisfies the builtin error interface
func (e Result_BuildbucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResult_Buildbucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Result_BuildbucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Result_BuildbucketValidationError{}

// Validate checks the field values on ExecutionState_Execution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionState_Execution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionState_Execution with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecutionState_ExecutionMultiError, or nil if none found.
func (m *ExecutionState_Execution) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState_Execution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAttempts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionState_ExecutionValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionState_ExecutionValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionState_ExecutionValidationError{
					field:  fmt.Sprintf("Attempts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UsedQuota

	if len(errors) > 0 {
		return ExecutionState_ExecutionMultiError(errors)
	}

	return nil
}

// ExecutionState_ExecutionMultiError is an error wrapping multiple validation
// errors returned by ExecutionState_Execution.ValidateAll() if the designated
// constraints aren't met.
type ExecutionState_ExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionState_ExecutionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionState_ExecutionMultiError) AllErrors() []error { return m }

// ExecutionState_ExecutionValidationError is the validation error returned by
// ExecutionState_Execution.Validate if the designated constraints aren't met.
type ExecutionState_ExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionState_ExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionState_ExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionState_ExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionState_ExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionState_ExecutionValidationError) ErrorName() string {
	return "ExecutionState_ExecutionValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionState_ExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState_Execution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionState_ExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionState_ExecutionValidationError{}

// Validate checks the field values on ExecutionState_Failures with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionState_Failures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionState_Failures with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecutionState_FailuresMultiError, or nil if none found.
func (m *ExecutionState_Failures) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState_Failures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLaunchFailures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionState_FailuresValidationError{
						field:  fmt.Sprintf("LaunchFailures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionState_FailuresValidationError{
						field:  fmt.Sprintf("LaunchFailures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionState_FailuresValidationError{
					field:  fmt.Sprintf("LaunchFailures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUnsuccessfulResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionState_FailuresValidationError{
						field:  fmt.Sprintf("UnsuccessfulResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionState_FailuresValidationError{
						field:  fmt.Sprintf("UnsuccessfulResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionState_FailuresValidationError{
					field:  fmt.Sprintf("UnsuccessfulResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionState_FailuresMultiError(errors)
	}

	return nil
}

// ExecutionState_FailuresMultiError is an error wrapping multiple validation
// errors returned by ExecutionState_Failures.ValidateAll() if the designated
// constraints aren't met.
type ExecutionState_FailuresMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionState_FailuresMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionState_FailuresMultiError) AllErrors() []error { return m }

// ExecutionState_FailuresValidationError is the validation error returned by
// ExecutionState_Failures.Validate if the designated constraints aren't met.
type ExecutionState_FailuresValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionState_FailuresValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionState_FailuresValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionState_FailuresValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionState_FailuresValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionState_FailuresValidationError) ErrorName() string {
	return "ExecutionState_FailuresValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionState_FailuresValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState_Failures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionState_FailuresValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionState_FailuresValidationError{}

// Validate checks the field values on ExecutionState_Execution_Attempt with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecutionState_Execution_Attempt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionState_Execution_Attempt with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecutionState_Execution_AttemptMultiError, or nil if none found.
func (m *ExecutionState_Execution_Attempt) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState_Execution_Attempt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TryjobId

	// no validation rules for ExternalId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionState_Execution_AttemptValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionState_Execution_AttemptValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionState_Execution_AttemptValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reused

	if len(errors) > 0 {
		return ExecutionState_Execution_AttemptMultiError(errors)
	}

	return nil
}

// ExecutionState_Execution_AttemptMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionState_Execution_Attempt.ValidateAll() if the designated
// constraints aren't met.
type ExecutionState_Execution_AttemptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionState_Execution_AttemptMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionState_Execution_AttemptMultiError) AllErrors() []error { return m }

// ExecutionState_Execution_AttemptValidationError is the validation error
// returned by ExecutionState_Execution_Attempt.Validate if the designated
// constraints aren't met.
type ExecutionState_Execution_AttemptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionState_Execution_AttemptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionState_Execution_AttemptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionState_Execution_AttemptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionState_Execution_AttemptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionState_Execution_AttemptValidationError) ErrorName() string {
	return "ExecutionState_Execution_AttemptValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionState_Execution_AttemptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState_Execution_Attempt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionState_Execution_AttemptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionState_Execution_AttemptValidationError{}

// Validate checks the field values on ExecutionState_Failures_LaunchFailure
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExecutionState_Failures_LaunchFailure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionState_Failures_LaunchFailure
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionState_Failures_LaunchFailureMultiError, or nil if none found.
func (m *ExecutionState_Failures_LaunchFailure) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState_Failures_LaunchFailure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefinition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionState_Failures_LaunchFailureValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionState_Failures_LaunchFailureValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefinition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionState_Failures_LaunchFailureValidationError{
				field:  "Definition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return ExecutionState_Failures_LaunchFailureMultiError(errors)
	}

	return nil
}

// ExecutionState_Failures_LaunchFailureMultiError is an error wrapping
// multiple validation errors returned by
// ExecutionState_Failures_LaunchFailure.ValidateAll() if the designated
// constraints aren't met.
type ExecutionState_Failures_LaunchFailureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionState_Failures_LaunchFailureMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionState_Failures_LaunchFailureMultiError) AllErrors() []error { return m }

// ExecutionState_Failures_LaunchFailureValidationError is the validation error
// returned by ExecutionState_Failures_LaunchFailure.Validate if the
// designated constraints aren't met.
type ExecutionState_Failures_LaunchFailureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionState_Failures_LaunchFailureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionState_Failures_LaunchFailureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionState_Failures_LaunchFailureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionState_Failures_LaunchFailureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionState_Failures_LaunchFailureValidationError) ErrorName() string {
	return "ExecutionState_Failures_LaunchFailureValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionState_Failures_LaunchFailureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState_Failures_LaunchFailure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionState_Failures_LaunchFailureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionState_Failures_LaunchFailureValidationError{}

// Validate checks the field values on
// ExecutionState_Failures_UnsuccessfulResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionState_Failures_UnsuccessfulResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExecutionState_Failures_UnsuccessfulResult with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExecutionState_Failures_UnsuccessfulResultMultiError, or nil if none found.
func (m *ExecutionState_Failures_UnsuccessfulResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionState_Failures_UnsuccessfulResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TryjobId

	if len(errors) > 0 {
		return ExecutionState_Failures_UnsuccessfulResultMultiError(errors)
	}

	return nil
}

// ExecutionState_Failures_UnsuccessfulResultMultiError is an error wrapping
// multiple validation errors returned by
// ExecutionState_Failures_UnsuccessfulResult.ValidateAll() if the designated
// constraints aren't met.
type ExecutionState_Failures_UnsuccessfulResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionState_Failures_UnsuccessfulResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionState_Failures_UnsuccessfulResultMultiError) AllErrors() []error { return m }

// ExecutionState_Failures_UnsuccessfulResultValidationError is the validation
// error returned by ExecutionState_Failures_UnsuccessfulResult.Validate if
// the designated constraints aren't met.
type ExecutionState_Failures_UnsuccessfulResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) ErrorName() string {
	return "ExecutionState_Failures_UnsuccessfulResultValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionState_Failures_UnsuccessfulResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionState_Failures_UnsuccessfulResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionState_Failures_UnsuccessfulResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionState_Failures_UnsuccessfulResultValidationError{}

// Validate checks the field values on ExecutionLogEntry_RequirementChanged
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExecutionLogEntry_RequirementChanged) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_RequirementChanged
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_RequirementChangedMultiError, or nil if none found.
func (m *ExecutionLogEntry_RequirementChanged) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_RequirementChanged) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExecutionLogEntry_RequirementChangedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_RequirementChangedMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionLogEntry_RequirementChanged.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_RequirementChangedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_RequirementChangedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_RequirementChangedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_RequirementChangedValidationError is the validation error
// returned by ExecutionLogEntry_RequirementChanged.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_RequirementChangedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_RequirementChangedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_RequirementChangedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_RequirementChangedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_RequirementChangedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_RequirementChangedValidationError) ErrorName() string {
	return "ExecutionLogEntry_RequirementChangedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_RequirementChangedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_RequirementChanged.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_RequirementChangedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_RequirementChangedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobSnapshot with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecutionLogEntry_TryjobSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobSnapshot with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobSnapshotMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ExternalId

	if all {
		switch v := interface{}(m.GetDefinition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobSnapshotValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobSnapshotValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefinition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionLogEntry_TryjobSnapshotValidationError{
				field:  "Definition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobSnapshotValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobSnapshotValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionLogEntry_TryjobSnapshotValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reused

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobSnapshotMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobSnapshotMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionLogEntry_TryjobSnapshot.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobSnapshotMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobSnapshotMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobSnapshotValidationError is the validation error
// returned by ExecutionLogEntry_TryjobSnapshot.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobSnapshotValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobSnapshotValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobsLaunched with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecutionLogEntry_TryjobsLaunched) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobsLaunched
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobsLaunchedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobsLaunched) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobsLaunched) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTryjobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsLaunchedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsLaunchedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntry_TryjobsLaunchedValidationError{
					field:  fmt.Sprintf("Tryjobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobsLaunchedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobsLaunchedMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionLogEntry_TryjobsLaunched.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobsLaunchedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobsLaunchedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobsLaunchedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobsLaunchedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobsLaunched.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobsLaunchedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobsLaunchedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobsLaunchedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobsLaunched.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobsLaunchedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobsLaunchedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobsLaunchFailed
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExecutionLogEntry_TryjobsLaunchFailed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobsLaunchFailed
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobsLaunchFailedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobsLaunchFailed) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobsLaunchFailed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTryjobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsLaunchFailedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsLaunchFailedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntry_TryjobsLaunchFailedValidationError{
					field:  fmt.Sprintf("Tryjobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobsLaunchFailedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobsLaunchFailedMultiError is an error wrapping
// multiple validation errors returned by
// ExecutionLogEntry_TryjobsLaunchFailed.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobsLaunchFailedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobsLaunchFailedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobsLaunchFailedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobsLaunchFailedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobsLaunchFailed.Validate if the
// designated constraints aren't met.
type ExecutionLogEntry_TryjobsLaunchFailedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobsLaunchFailedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobsLaunchFailedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobsLaunchFailed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobsLaunchFailedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobsLaunchFailedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobLaunchFailed
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExecutionLogEntry_TryjobLaunchFailed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobLaunchFailed
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobLaunchFailedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobLaunchFailed) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobLaunchFailed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefinition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobLaunchFailedValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobLaunchFailedValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefinition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionLogEntry_TryjobLaunchFailedValidationError{
				field:  "Definition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobLaunchFailedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobLaunchFailedMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionLogEntry_TryjobLaunchFailed.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobLaunchFailedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobLaunchFailedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobLaunchFailedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobLaunchFailedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobLaunchFailed.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobLaunchFailedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobLaunchFailedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobLaunchFailedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobLaunchFailed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobLaunchFailedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobLaunchFailedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobsReused with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionLogEntry_TryjobsReused) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobsReused with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobsReusedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobsReused) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobsReused) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTryjobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsReusedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsReusedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntry_TryjobsReusedValidationError{
					field:  fmt.Sprintf("Tryjobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobsReusedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobsReusedMultiError is an error wrapping multiple
// validation errors returned by ExecutionLogEntry_TryjobsReused.ValidateAll()
// if the designated constraints aren't met.
type ExecutionLogEntry_TryjobsReusedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobsReusedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobsReusedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobsReusedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobsReused.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobsReusedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobsReusedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobsReusedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobsReusedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobsReusedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobsReusedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobsReusedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobsReusedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobsReused.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobsReusedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobsReusedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobsEnded with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionLogEntry_TryjobsEnded) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobsEnded with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobsEndedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobsEnded) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobsEnded) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTryjobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsEndedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntry_TryjobsEndedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntry_TryjobsEndedValidationError{
					field:  fmt.Sprintf("Tryjobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobsEndedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobsEndedMultiError is an error wrapping multiple
// validation errors returned by ExecutionLogEntry_TryjobsEnded.ValidateAll()
// if the designated constraints aren't met.
type ExecutionLogEntry_TryjobsEndedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobsEndedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobsEndedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobsEndedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobsEnded.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobsEndedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobsEndedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobsEndedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobsEndedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobsEndedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobsEndedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobsEndedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobsEndedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobsEnded.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobsEndedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobsEndedValidationError{}

// Validate checks the field values on ExecutionLogEntry_TryjobDiscarded with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExecutionLogEntry_TryjobDiscarded) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_TryjobDiscarded
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_TryjobDiscardedMultiError, or nil if none found.
func (m *ExecutionLogEntry_TryjobDiscarded) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_TryjobDiscarded) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSnapshot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobDiscardedValidationError{
					field:  "Snapshot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecutionLogEntry_TryjobDiscardedValidationError{
					field:  "Snapshot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSnapshot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecutionLogEntry_TryjobDiscardedValidationError{
				field:  "Snapshot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return ExecutionLogEntry_TryjobDiscardedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_TryjobDiscardedMultiError is an error wrapping multiple
// validation errors returned by
// ExecutionLogEntry_TryjobDiscarded.ValidateAll() if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobDiscardedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_TryjobDiscardedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_TryjobDiscardedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_TryjobDiscardedValidationError is the validation error
// returned by ExecutionLogEntry_TryjobDiscarded.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_TryjobDiscardedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_TryjobDiscardedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_TryjobDiscardedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_TryjobDiscardedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_TryjobDiscardedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_TryjobDiscardedValidationError) ErrorName() string {
	return "ExecutionLogEntry_TryjobDiscardedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_TryjobDiscardedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_TryjobDiscarded.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_TryjobDiscardedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_TryjobDiscardedValidationError{}

// Validate checks the field values on ExecutionLogEntry_RetryDenied with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecutionLogEntry_RetryDenied) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionLogEntry_RetryDenied with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExecutionLogEntry_RetryDeniedMultiError, or nil if none found.
func (m *ExecutionLogEntry_RetryDenied) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionLogEntry_RetryDenied) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTryjobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionLogEntry_RetryDeniedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionLogEntry_RetryDeniedValidationError{
						field:  fmt.Sprintf("Tryjobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionLogEntry_RetryDeniedValidationError{
					field:  fmt.Sprintf("Tryjobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return ExecutionLogEntry_RetryDeniedMultiError(errors)
	}

	return nil
}

// ExecutionLogEntry_RetryDeniedMultiError is an error wrapping multiple
// validation errors returned by ExecutionLogEntry_RetryDenied.ValidateAll()
// if the designated constraints aren't met.
type ExecutionLogEntry_RetryDeniedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionLogEntry_RetryDeniedMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionLogEntry_RetryDeniedMultiError) AllErrors() []error { return m }

// ExecutionLogEntry_RetryDeniedValidationError is the validation error
// returned by ExecutionLogEntry_RetryDenied.Validate if the designated
// constraints aren't met.
type ExecutionLogEntry_RetryDeniedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionLogEntry_RetryDeniedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionLogEntry_RetryDeniedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionLogEntry_RetryDeniedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionLogEntry_RetryDeniedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionLogEntry_RetryDeniedValidationError) ErrorName() string {
	return "ExecutionLogEntry_RetryDeniedValidationError"
}

// Error satisfies the builtin error interface
func (e ExecutionLogEntry_RetryDeniedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionLogEntry_RetryDenied.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionLogEntry_RetryDeniedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionLogEntry_RetryDeniedValidationError{}
