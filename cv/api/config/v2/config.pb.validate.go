// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: go.chromium.org/luci/cv/api/config/v2/config.proto

package cfgpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	cvpb "go.chromium.org/luci/cv/api/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = cvpb.Run_Status(0)
)

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DrainingStartTime

	// no validation rules for CqStatusHost

	if all {
		switch v := interface{}(m.GetSubmitOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "SubmitOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "SubmitOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "SubmitOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetConfigGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("ConfigGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("ConfigGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigValidationError{
					field:  fmt.Sprintf("ConfigGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ProjectScopedAccount

	// no validation rules for HonorGerritLinkedAccounts

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on ConfigGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigGroupMultiError, or
// nil if none found.
func (m *ConfigGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetGerrit() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("Gerrit[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("Gerrit[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroupValidationError{
					field:  fmt.Sprintf("Gerrit[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCombineCls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "CombineCls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "CombineCls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCombineCls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigGroupValidationError{
				field:  "CombineCls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerifiers()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "Verifiers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "Verifiers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerifiers()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigGroupValidationError{
				field:  "Verifiers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Fallback

	for idx, item := range m.GetAdditionalModes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("AdditionalModes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("AdditionalModes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroupValidationError{
					field:  fmt.Sprintf("AdditionalModes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUserLimits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("UserLimits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("UserLimits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroupValidationError{
					field:  fmt.Sprintf("UserLimits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetUserLimitDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "UserLimitDefault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigGroupValidationError{
					field:  "UserLimitDefault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserLimitDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigGroupValidationError{
				field:  "UserLimitDefault",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPostActions() {
		_, _ = idx, item

		if item == nil {
			err := ConfigGroupValidationError{
				field:  fmt.Sprintf("PostActions[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("PostActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("PostActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroupValidationError{
					field:  fmt.Sprintf("PostActions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTryjobExperiments() {
		_, _ = idx, item

		if item == nil {
			err := ConfigGroupValidationError{
				field:  fmt.Sprintf("TryjobExperiments[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("TryjobExperiments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroupValidationError{
						field:  fmt.Sprintf("TryjobExperiments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroupValidationError{
					field:  fmt.Sprintf("TryjobExperiments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigGroupMultiError(errors)
	}

	return nil
}

// ConfigGroupMultiError is an error wrapping multiple validation errors
// returned by ConfigGroup.ValidateAll() if the designated constraints aren't met.
type ConfigGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroupMultiError) AllErrors() []error { return m }

// ConfigGroupValidationError is the validation error returned by
// ConfigGroup.Validate if the designated constraints aren't met.
type ConfigGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroupValidationError) ErrorName() string { return "ConfigGroupValidationError" }

// Error satisfies the builtin error interface
func (e ConfigGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroupValidationError{}

// Validate checks the field values on SubmitOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubmitOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubmitOptionsMultiError, or
// nil if none found.
func (m *SubmitOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxBurst

	if all {
		switch v := interface{}(m.GetBurstDelay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmitOptionsValidationError{
					field:  "BurstDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmitOptionsValidationError{
					field:  "BurstDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBurstDelay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitOptionsValidationError{
				field:  "BurstDelay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubmitOptionsMultiError(errors)
	}

	return nil
}

// SubmitOptionsMultiError is an error wrapping multiple validation errors
// returned by SubmitOptions.ValidateAll() if the designated constraints
// aren't met.
type SubmitOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitOptionsMultiError) AllErrors() []error { return m }

// SubmitOptionsValidationError is the validation error returned by
// SubmitOptions.Validate if the designated constraints aren't met.
type SubmitOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitOptionsValidationError) ErrorName() string { return "SubmitOptionsValidationError" }

// Error satisfies the builtin error interface
func (e SubmitOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitOptionsValidationError{}

// Validate checks the field values on Mode with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Mode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mode with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ModeMultiError, or nil if none found.
func (m *Mode) ValidateAll() error {
	return m.validate(true)
}

func (m *Mode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _Mode_Name_NotInLookup[m.GetName()]; ok {
		err := ModeValidationError{
			field:  "Name",
			reason: "value must not be in list [DRY_RUN FULL_RUN NEW_PATCHSET_RUN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Mode_Name_Pattern.MatchString(m.GetName()) {
		err := ModeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[A-Z][A-Z_]{0,39}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Mode_CqLabelValue_InLookup[m.GetCqLabelValue()]; !ok {
		err := ModeValidationError{
			field:  "CqLabelValue",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Mode_TriggeringLabel_NotInLookup[m.GetTriggeringLabel()]; ok {
		err := ModeValidationError{
			field:  "TriggeringLabel",
			reason: "value must not be in list [Commit-Queue]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTriggeringLabel()) < 1 {
		err := ModeValidationError{
			field:  "TriggeringLabel",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTriggeringValue() <= 0 {
		err := ModeValidationError{
			field:  "TriggeringValue",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ModeMultiError(errors)
	}

	return nil
}

// ModeMultiError is an error wrapping multiple validation errors returned by
// Mode.ValidateAll() if the designated constraints aren't met.
type ModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModeMultiError) AllErrors() []error { return m }

// ModeValidationError is the validation error returned by Mode.Validate if the
// designated constraints aren't met.
type ModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModeValidationError) ErrorName() string { return "ModeValidationError" }

// Error satisfies the builtin error interface
func (e ModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModeValidationError{}

var _Mode_Name_NotInLookup = map[string]struct{}{
	"DRY_RUN":          {},
	"FULL_RUN":         {},
	"NEW_PATCHSET_RUN": {},
}

var _Mode_Name_Pattern = regexp.MustCompile("^[A-Z][A-Z_]{0,39}$")

var _Mode_CqLabelValue_InLookup = map[int32]struct{}{
	1: {},
	2: {},
}

var _Mode_TriggeringLabel_NotInLookup = map[string]struct{}{
	"Commit-Queue": {},
}

// Validate checks the field values on CombineCLs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CombineCLs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CombineCLs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CombineCLsMultiError, or
// nil if none found.
func (m *CombineCLs) ValidateAll() error {
	return m.validate(true)
}

func (m *CombineCLs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStabilizationDelay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CombineCLsValidationError{
					field:  "StabilizationDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CombineCLsValidationError{
					field:  "StabilizationDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStabilizationDelay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CombineCLsValidationError{
				field:  "StabilizationDelay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CombineCLsMultiError(errors)
	}

	return nil
}

// CombineCLsMultiError is an error wrapping multiple validation errors
// returned by CombineCLs.ValidateAll() if the designated constraints aren't met.
type CombineCLsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CombineCLsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CombineCLsMultiError) AllErrors() []error { return m }

// CombineCLsValidationError is the validation error returned by
// CombineCLs.Validate if the designated constraints aren't met.
type CombineCLsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CombineCLsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CombineCLsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CombineCLsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CombineCLsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CombineCLsValidationError) ErrorName() string { return "CombineCLsValidationError" }

// Error satisfies the builtin error interface
func (e CombineCLsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCombineCLs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CombineCLsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CombineCLsValidationError{}

// Validate checks the field values on Verifiers with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Verifiers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VerifiersMultiError, or nil
// if none found.
func (m *Verifiers) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGerritCqAbility()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "GerritCqAbility",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "GerritCqAbility",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGerritCqAbility()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifiersValidationError{
				field:  "GerritCqAbility",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTreeStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "TreeStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "TreeStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreeStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifiersValidationError{
				field:  "TreeStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTryjob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Tryjob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Tryjob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTryjob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifiersValidationError{
				field:  "Tryjob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCqlinter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Cqlinter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Cqlinter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCqlinter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifiersValidationError{
				field:  "Cqlinter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFake()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Fake",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifiersValidationError{
					field:  "Fake",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFake()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifiersValidationError{
				field:  "Fake",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifiersMultiError(errors)
	}

	return nil
}

// VerifiersMultiError is an error wrapping multiple validation errors returned
// by Verifiers.ValidateAll() if the designated constraints aren't met.
type VerifiersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifiersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifiersMultiError) AllErrors() []error { return m }

// VerifiersValidationError is the validation error returned by
// Verifiers.Validate if the designated constraints aren't met.
type VerifiersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifiersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifiersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifiersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifiersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifiersValidationError) ErrorName() string { return "VerifiersValidationError" }

// Error satisfies the builtin error interface
func (e VerifiersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifiersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifiersValidationError{}

// Validate checks the field values on UserLimit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserLimitMultiError, or nil
// if none found.
func (m *UserLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserLimitValidationError{
					field:  "Run",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserLimitValidationError{
					field:  "Run",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserLimitValidationError{
				field:  "Run",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTryjob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserLimitValidationError{
					field:  "Tryjob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserLimitValidationError{
					field:  "Tryjob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTryjob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserLimitValidationError{
				field:  "Tryjob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserLimitMultiError(errors)
	}

	return nil
}

// UserLimitMultiError is an error wrapping multiple validation errors returned
// by UserLimit.ValidateAll() if the designated constraints aren't met.
type UserLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLimitMultiError) AllErrors() []error { return m }

// UserLimitValidationError is the validation error returned by
// UserLimit.Validate if the designated constraints aren't met.
type UserLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLimitValidationError) ErrorName() string { return "UserLimitValidationError" }

// Error satisfies the builtin error interface
func (e UserLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLimitValidationError{}

// Validate checks the field values on ConfigGroup_Gerrit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_Gerrit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigGroup_Gerrit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigGroup_GerritMultiError, or nil if none found.
func (m *ConfigGroup_Gerrit) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_Gerrit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroup_GerritValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroup_GerritValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroup_GerritValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigGroup_GerritMultiError(errors)
	}

	return nil
}

// ConfigGroup_GerritMultiError is an error wrapping multiple validation errors
// returned by ConfigGroup_Gerrit.ValidateAll() if the designated constraints
// aren't met.
type ConfigGroup_GerritMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_GerritMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_GerritMultiError) AllErrors() []error { return m }

// ConfigGroup_GerritValidationError is the validation error returned by
// ConfigGroup_Gerrit.Validate if the designated constraints aren't met.
type ConfigGroup_GerritValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_GerritValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_GerritValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_GerritValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_GerritValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_GerritValidationError) ErrorName() string {
	return "ConfigGroup_GerritValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_GerritValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_Gerrit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_GerritValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_GerritValidationError{}

// Validate checks the field values on ConfigGroup_PostAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_PostAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigGroup_PostAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigGroup_PostActionMultiError, or nil if none found.
func (m *ConfigGroup_PostAction) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_PostAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ConfigGroup_PostActionValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetConditions()) < 1 {
		err := ConfigGroup_PostActionValidationError{
			field:  "Conditions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if item == nil {
			err := ConfigGroup_PostActionValidationError{
				field:  fmt.Sprintf("Conditions[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroup_PostActionValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroup_PostActionValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroup_PostActionValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	oneofActionPresent := false
	switch v := m.Action.(type) {
	case *ConfigGroup_PostAction_VoteGerritLabels_:
		if v == nil {
			err := ConfigGroup_PostActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofActionPresent = true

		if all {
			switch v := interface{}(m.GetVoteGerritLabels()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroup_PostActionValidationError{
						field:  "VoteGerritLabels",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroup_PostActionValidationError{
						field:  "VoteGerritLabels",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVoteGerritLabels()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroup_PostActionValidationError{
					field:  "VoteGerritLabels",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofActionPresent {
		err := ConfigGroup_PostActionValidationError{
			field:  "Action",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigGroup_PostActionMultiError(errors)
	}

	return nil
}

// ConfigGroup_PostActionMultiError is an error wrapping multiple validation
// errors returned by ConfigGroup_PostAction.ValidateAll() if the designated
// constraints aren't met.
type ConfigGroup_PostActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_PostActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_PostActionMultiError) AllErrors() []error { return m }

// ConfigGroup_PostActionValidationError is the validation error returned by
// ConfigGroup_PostAction.Validate if the designated constraints aren't met.
type ConfigGroup_PostActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_PostActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_PostActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_PostActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_PostActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_PostActionValidationError) ErrorName() string {
	return "ConfigGroup_PostActionValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_PostActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_PostAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_PostActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_PostActionValidationError{}

// Validate checks the field values on ConfigGroup_TryjobExperiment with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_TryjobExperiment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigGroup_TryjobExperiment with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigGroup_TryjobExperimentMultiError, or nil if none found.
func (m *ConfigGroup_TryjobExperiment) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_TryjobExperiment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ConfigGroup_TryjobExperimentValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigGroup_TryjobExperimentValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigGroup_TryjobExperimentValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigGroup_TryjobExperimentValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigGroup_TryjobExperimentMultiError(errors)
	}

	return nil
}

// ConfigGroup_TryjobExperimentMultiError is an error wrapping multiple
// validation errors returned by ConfigGroup_TryjobExperiment.ValidateAll() if
// the designated constraints aren't met.
type ConfigGroup_TryjobExperimentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_TryjobExperimentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_TryjobExperimentMultiError) AllErrors() []error { return m }

// ConfigGroup_TryjobExperimentValidationError is the validation error returned
// by ConfigGroup_TryjobExperiment.Validate if the designated constraints
// aren't met.
type ConfigGroup_TryjobExperimentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_TryjobExperimentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_TryjobExperimentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_TryjobExperimentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_TryjobExperimentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_TryjobExperimentValidationError) ErrorName() string {
	return "ConfigGroup_TryjobExperimentValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_TryjobExperimentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_TryjobExperiment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_TryjobExperimentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_TryjobExperimentValidationError{}

// Validate checks the field values on ConfigGroup_Gerrit_Project with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_Gerrit_Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigGroup_Gerrit_Project with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigGroup_Gerrit_ProjectMultiError, or nil if none found.
func (m *ConfigGroup_Gerrit_Project) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_Gerrit_Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ConfigGroup_Gerrit_ProjectMultiError(errors)
	}

	return nil
}

// ConfigGroup_Gerrit_ProjectMultiError is an error wrapping multiple
// validation errors returned by ConfigGroup_Gerrit_Project.ValidateAll() if
// the designated constraints aren't met.
type ConfigGroup_Gerrit_ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_Gerrit_ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_Gerrit_ProjectMultiError) AllErrors() []error { return m }

// ConfigGroup_Gerrit_ProjectValidationError is the validation error returned
// by ConfigGroup_Gerrit_Project.Validate if the designated constraints aren't met.
type ConfigGroup_Gerrit_ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_Gerrit_ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_Gerrit_ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_Gerrit_ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_Gerrit_ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_Gerrit_ProjectValidationError) ErrorName() string {
	return "ConfigGroup_Gerrit_ProjectValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_Gerrit_ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_Gerrit_Project.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_Gerrit_ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_Gerrit_ProjectValidationError{}

// Validate checks the field values on
// ConfigGroup_PostAction_TriggeringCondition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_PostAction_TriggeringCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConfigGroup_PostAction_TriggeringCondition with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ConfigGroup_PostAction_TriggeringConditionMultiError, or nil if none found.
func (m *ConfigGroup_PostAction_TriggeringCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_PostAction_TriggeringCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetMode()) < 1 {
		err := ConfigGroup_PostAction_TriggeringConditionValidationError{
			field:  "Mode",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetStatuses()) < 1 {
		err := ConfigGroup_PostAction_TriggeringConditionValidationError{
			field:  "Statuses",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetStatuses() {
		_, _ = idx, item

		if _, ok := cvpb.Run_Status_name[int32(item)]; !ok {
			err := ConfigGroup_PostAction_TriggeringConditionValidationError{
				field:  fmt.Sprintf("Statuses[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ConfigGroup_PostAction_TriggeringConditionMultiError(errors)
	}

	return nil
}

// ConfigGroup_PostAction_TriggeringConditionMultiError is an error wrapping
// multiple validation errors returned by
// ConfigGroup_PostAction_TriggeringCondition.ValidateAll() if the designated
// constraints aren't met.
type ConfigGroup_PostAction_TriggeringConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_PostAction_TriggeringConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_PostAction_TriggeringConditionMultiError) AllErrors() []error { return m }

// ConfigGroup_PostAction_TriggeringConditionValidationError is the validation
// error returned by ConfigGroup_PostAction_TriggeringCondition.Validate if
// the designated constraints aren't met.
type ConfigGroup_PostAction_TriggeringConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) ErrorName() string {
	return "ConfigGroup_PostAction_TriggeringConditionValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_PostAction_TriggeringConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_PostAction_TriggeringCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_PostAction_TriggeringConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_PostAction_TriggeringConditionValidationError{}

// Validate checks the field values on ConfigGroup_PostAction_VoteGerritLabels
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ConfigGroup_PostAction_VoteGerritLabels) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConfigGroup_PostAction_VoteGerritLabels with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ConfigGroup_PostAction_VoteGerritLabelsMultiError, or nil if none found.
func (m *ConfigGroup_PostAction_VoteGerritLabels) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_PostAction_VoteGerritLabels) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetVotes()) < 1 {
		err := ConfigGroup_PostAction_VoteGerritLabelsValidationError{
			field:  "Votes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetVotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigGroup_PostAction_VoteGerritLabelsValidationError{
						field:  fmt.Sprintf("Votes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigGroup_PostAction_VoteGerritLabelsValidationError{
						field:  fmt.Sprintf("Votes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigGroup_PostAction_VoteGerritLabelsValidationError{
					field:  fmt.Sprintf("Votes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigGroup_PostAction_VoteGerritLabelsMultiError(errors)
	}

	return nil
}

// ConfigGroup_PostAction_VoteGerritLabelsMultiError is an error wrapping
// multiple validation errors returned by
// ConfigGroup_PostAction_VoteGerritLabels.ValidateAll() if the designated
// constraints aren't met.
type ConfigGroup_PostAction_VoteGerritLabelsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_PostAction_VoteGerritLabelsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_PostAction_VoteGerritLabelsMultiError) AllErrors() []error { return m }

// ConfigGroup_PostAction_VoteGerritLabelsValidationError is the validation
// error returned by ConfigGroup_PostAction_VoteGerritLabels.Validate if the
// designated constraints aren't met.
type ConfigGroup_PostAction_VoteGerritLabelsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) ErrorName() string {
	return "ConfigGroup_PostAction_VoteGerritLabelsValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_PostAction_VoteGerritLabelsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_PostAction_VoteGerritLabels.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_PostAction_VoteGerritLabelsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_PostAction_VoteGerritLabelsValidationError{}

// Validate checks the field values on
// ConfigGroup_PostAction_VoteGerritLabels_Vote with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigGroup_PostAction_VoteGerritLabels_Vote) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConfigGroup_PostAction_VoteGerritLabels_Vote with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError, or nil if none found.
func (m *ConfigGroup_PostAction_VoteGerritLabels_Vote) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_PostAction_VoteGerritLabels_Vote) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Value

	if len(errors) > 0 {
		return ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError(errors)
	}

	return nil
}

// ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError is an error wrapping
// multiple validation errors returned by
// ConfigGroup_PostAction_VoteGerritLabels_Vote.ValidateAll() if the
// designated constraints aren't met.
type ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_PostAction_VoteGerritLabels_VoteMultiError) AllErrors() []error { return m }

// ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError is the
// validation error returned by
// ConfigGroup_PostAction_VoteGerritLabels_Vote.Validate if the designated
// constraints aren't met.
type ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) ErrorName() string {
	return "ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_PostAction_VoteGerritLabels_Vote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_PostAction_VoteGerritLabels_VoteValidationError{}

// Validate checks the field values on ConfigGroup_TryjobExperiment_Condition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ConfigGroup_TryjobExperiment_Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConfigGroup_TryjobExperiment_Condition with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ConfigGroup_TryjobExperiment_ConditionMultiError, or nil if none found.
func (m *ConfigGroup_TryjobExperiment_Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigGroup_TryjobExperiment_Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOwnerGroupAllowlist() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := ConfigGroup_TryjobExperiment_ConditionValidationError{
				field:  fmt.Sprintf("OwnerGroupAllowlist[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ConfigGroup_TryjobExperiment_ConditionMultiError(errors)
	}

	return nil
}

// ConfigGroup_TryjobExperiment_ConditionMultiError is an error wrapping
// multiple validation errors returned by
// ConfigGroup_TryjobExperiment_Condition.ValidateAll() if the designated
// constraints aren't met.
type ConfigGroup_TryjobExperiment_ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigGroup_TryjobExperiment_ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigGroup_TryjobExperiment_ConditionMultiError) AllErrors() []error { return m }

// ConfigGroup_TryjobExperiment_ConditionValidationError is the validation
// error returned by ConfigGroup_TryjobExperiment_Condition.Validate if the
// designated constraints aren't met.
type ConfigGroup_TryjobExperiment_ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) ErrorName() string {
	return "ConfigGroup_TryjobExperiment_ConditionValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigGroup_TryjobExperiment_ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigGroup_TryjobExperiment_Condition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigGroup_TryjobExperiment_ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigGroup_TryjobExperiment_ConditionValidationError{}

// Validate checks the field values on Verifiers_GerritCQAbility with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_GerritCQAbility) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_GerritCQAbility with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_GerritCQAbilityMultiError, or nil if none found.
func (m *Verifiers_GerritCQAbility) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_GerritCQAbility) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AllowSubmitWithOpenDeps

	// no validation rules for AllowOwnerIfSubmittable

	// no validation rules for TrustDryRunnerDeps

	// no validation rules for AllowNonOwnerDryRunner

	if len(errors) > 0 {
		return Verifiers_GerritCQAbilityMultiError(errors)
	}

	return nil
}

// Verifiers_GerritCQAbilityMultiError is an error wrapping multiple validation
// errors returned by Verifiers_GerritCQAbility.ValidateAll() if the
// designated constraints aren't met.
type Verifiers_GerritCQAbilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_GerritCQAbilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_GerritCQAbilityMultiError) AllErrors() []error { return m }

// Verifiers_GerritCQAbilityValidationError is the validation error returned by
// Verifiers_GerritCQAbility.Validate if the designated constraints aren't met.
type Verifiers_GerritCQAbilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_GerritCQAbilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_GerritCQAbilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_GerritCQAbilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_GerritCQAbilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_GerritCQAbilityValidationError) ErrorName() string {
	return "Verifiers_GerritCQAbilityValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_GerritCQAbilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_GerritCQAbility.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_GerritCQAbilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_GerritCQAbilityValidationError{}

// Validate checks the field values on Verifiers_TreeStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_TreeStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_TreeStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_TreeStatusMultiError, or nil if none found.
func (m *Verifiers_TreeStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_TreeStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeName

	// no validation rules for Url

	if len(errors) > 0 {
		return Verifiers_TreeStatusMultiError(errors)
	}

	return nil
}

// Verifiers_TreeStatusMultiError is an error wrapping multiple validation
// errors returned by Verifiers_TreeStatus.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_TreeStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_TreeStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_TreeStatusMultiError) AllErrors() []error { return m }

// Verifiers_TreeStatusValidationError is the validation error returned by
// Verifiers_TreeStatus.Validate if the designated constraints aren't met.
type Verifiers_TreeStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_TreeStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_TreeStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_TreeStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_TreeStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_TreeStatusValidationError) ErrorName() string {
	return "Verifiers_TreeStatusValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_TreeStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_TreeStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_TreeStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_TreeStatusValidationError{}

// Validate checks the field values on Verifiers_Tryjob with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_Tryjob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_TryjobMultiError, or nil if none found.
func (m *Verifiers_Tryjob) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuilders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Verifiers_TryjobValidationError{
						field:  fmt.Sprintf("Builders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Verifiers_TryjobValidationError{
						field:  fmt.Sprintf("Builders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Verifiers_TryjobValidationError{
					field:  fmt.Sprintf("Builders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRetryConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Verifiers_TryjobValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Verifiers_TryjobValidationError{
					field:  "RetryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetryConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Verifiers_TryjobValidationError{
				field:  "RetryConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CancelStaleTryjobs

	if len(errors) > 0 {
		return Verifiers_TryjobMultiError(errors)
	}

	return nil
}

// Verifiers_TryjobMultiError is an error wrapping multiple validation errors
// returned by Verifiers_Tryjob.ValidateAll() if the designated constraints
// aren't met.
type Verifiers_TryjobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_TryjobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_TryjobMultiError) AllErrors() []error { return m }

// Verifiers_TryjobValidationError is the validation error returned by
// Verifiers_Tryjob.Validate if the designated constraints aren't met.
type Verifiers_TryjobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_TryjobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_TryjobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_TryjobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_TryjobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_TryjobValidationError) ErrorName() string { return "Verifiers_TryjobValidationError" }

// Error satisfies the builtin error interface
func (e Verifiers_TryjobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_TryjobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_TryjobValidationError{}

// Validate checks the field values on Verifiers_CQLinter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_CQLinter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_CQLinter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_CQLinterMultiError, or nil if none found.
func (m *Verifiers_CQLinter) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_CQLinter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Verifiers_CQLinterMultiError(errors)
	}

	return nil
}

// Verifiers_CQLinterMultiError is an error wrapping multiple validation errors
// returned by Verifiers_CQLinter.ValidateAll() if the designated constraints
// aren't met.
type Verifiers_CQLinterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_CQLinterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_CQLinterMultiError) AllErrors() []error { return m }

// Verifiers_CQLinterValidationError is the validation error returned by
// Verifiers_CQLinter.Validate if the designated constraints aren't met.
type Verifiers_CQLinterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_CQLinterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_CQLinterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_CQLinterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_CQLinterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_CQLinterValidationError) ErrorName() string {
	return "Verifiers_CQLinterValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_CQLinterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_CQLinter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_CQLinterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_CQLinterValidationError{}

// Validate checks the field values on Verifiers_Fake with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Verifiers_Fake) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Fake with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Verifiers_FakeMultiError,
// or nil if none found.
func (m *Verifiers_Fake) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Fake) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for EventualState

	// no validation rules for Delay

	if len(errors) > 0 {
		return Verifiers_FakeMultiError(errors)
	}

	return nil
}

// Verifiers_FakeMultiError is an error wrapping multiple validation errors
// returned by Verifiers_Fake.ValidateAll() if the designated constraints
// aren't met.
type Verifiers_FakeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_FakeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_FakeMultiError) AllErrors() []error { return m }

// Verifiers_FakeValidationError is the validation error returned by
// Verifiers_Fake.Validate if the designated constraints aren't met.
type Verifiers_FakeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_FakeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_FakeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_FakeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_FakeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_FakeValidationError) ErrorName() string { return "Verifiers_FakeValidationError" }

// Error satisfies the builtin error interface
func (e Verifiers_FakeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Fake.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_FakeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_FakeValidationError{}

// Validate checks the field values on Verifiers_Tryjob_Builder with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_Tryjob_Builder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob_Builder with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_Tryjob_BuilderMultiError, or nil if none found.
func (m *Verifiers_Tryjob_Builder) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_Builder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Name

	// no validation rules for IncludableOnly

	// no validation rules for ResultVisibility

	// no validation rules for DisableReuse

	// no validation rules for CancelStale

	// no validation rules for ExperimentPercentage

	if all {
		switch v := interface{}(m.GetEquivalentTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
					field:  "EquivalentTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
					field:  "EquivalentTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEquivalentTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Verifiers_Tryjob_BuilderValidationError{
				field:  "EquivalentTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLocationFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
						field:  fmt.Sprintf("LocationFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
						field:  fmt.Sprintf("LocationFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Verifiers_Tryjob_BuilderValidationError{
					field:  fmt.Sprintf("LocationFilters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSkipFooters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
						field:  fmt.Sprintf("SkipFooters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Verifiers_Tryjob_BuilderValidationError{
						field:  fmt.Sprintf("SkipFooters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Verifiers_Tryjob_BuilderValidationError{
					field:  fmt.Sprintf("SkipFooters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Verifiers_Tryjob_BuilderMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_BuilderMultiError is an error wrapping multiple validation
// errors returned by Verifiers_Tryjob_Builder.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_Tryjob_BuilderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_BuilderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_BuilderMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_BuilderValidationError is the validation error returned by
// Verifiers_Tryjob_Builder.Validate if the designated constraints aren't met.
type Verifiers_Tryjob_BuilderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_BuilderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_BuilderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_BuilderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_BuilderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_BuilderValidationError) ErrorName() string {
	return "Verifiers_Tryjob_BuilderValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_BuilderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_Builder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_BuilderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_BuilderValidationError{}

// Validate checks the field values on Verifiers_Tryjob_EquivalentBuilder with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Verifiers_Tryjob_EquivalentBuilder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob_EquivalentBuilder
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Verifiers_Tryjob_EquivalentBuilderMultiError, or nil if none found.
func (m *Verifiers_Tryjob_EquivalentBuilder) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_EquivalentBuilder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Percentage

	// no validation rules for OwnerWhitelistGroup

	if len(errors) > 0 {
		return Verifiers_Tryjob_EquivalentBuilderMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_EquivalentBuilderMultiError is an error wrapping multiple
// validation errors returned by
// Verifiers_Tryjob_EquivalentBuilder.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_Tryjob_EquivalentBuilderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_EquivalentBuilderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_EquivalentBuilderMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_EquivalentBuilderValidationError is the validation error
// returned by Verifiers_Tryjob_EquivalentBuilder.Validate if the designated
// constraints aren't met.
type Verifiers_Tryjob_EquivalentBuilderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) ErrorName() string {
	return "Verifiers_Tryjob_EquivalentBuilderValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_EquivalentBuilderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_EquivalentBuilder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_EquivalentBuilderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_EquivalentBuilderValidationError{}

// Validate checks the field values on Verifiers_Tryjob_IncludableBuilder with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Verifiers_Tryjob_IncludableBuilder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob_IncludableBuilder
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Verifiers_Tryjob_IncludableBuilderMultiError, or nil if none found.
func (m *Verifiers_Tryjob_IncludableBuilder) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_IncludableBuilder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return Verifiers_Tryjob_IncludableBuilderMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_IncludableBuilderMultiError is an error wrapping multiple
// validation errors returned by
// Verifiers_Tryjob_IncludableBuilder.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_Tryjob_IncludableBuilderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_IncludableBuilderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_IncludableBuilderMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_IncludableBuilderValidationError is the validation error
// returned by Verifiers_Tryjob_IncludableBuilder.Validate if the designated
// constraints aren't met.
type Verifiers_Tryjob_IncludableBuilderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_IncludableBuilderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_IncludableBuilderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_IncludableBuilderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_IncludableBuilderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_IncludableBuilderValidationError) ErrorName() string {
	return "Verifiers_Tryjob_IncludableBuilderValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_IncludableBuilderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_IncludableBuilder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_IncludableBuilderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_IncludableBuilderValidationError{}

// Validate checks the field values on Verifiers_Tryjob_RetryConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Verifiers_Tryjob_RetryConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob_RetryConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Verifiers_Tryjob_RetryConfigMultiError, or nil if none found.
func (m *Verifiers_Tryjob_RetryConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_RetryConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SingleQuota

	// no validation rules for GlobalQuota

	// no validation rules for FailureWeight

	// no validation rules for TransientFailureWeight

	// no validation rules for TimeoutWeight

	if len(errors) > 0 {
		return Verifiers_Tryjob_RetryConfigMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_RetryConfigMultiError is an error wrapping multiple
// validation errors returned by Verifiers_Tryjob_RetryConfig.ValidateAll() if
// the designated constraints aren't met.
type Verifiers_Tryjob_RetryConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_RetryConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_RetryConfigMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_RetryConfigValidationError is the validation error returned
// by Verifiers_Tryjob_RetryConfig.Validate if the designated constraints
// aren't met.
type Verifiers_Tryjob_RetryConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_RetryConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_RetryConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_RetryConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_RetryConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_RetryConfigValidationError) ErrorName() string {
	return "Verifiers_Tryjob_RetryConfigValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_RetryConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_RetryConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_RetryConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_RetryConfigValidationError{}

// Validate checks the field values on Verifiers_Tryjob_Builder_LocationFilter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Verifiers_Tryjob_Builder_LocationFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Verifiers_Tryjob_Builder_LocationFilter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Verifiers_Tryjob_Builder_LocationFilterMultiError, or nil if none found.
func (m *Verifiers_Tryjob_Builder_LocationFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_Builder_LocationFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GerritHostRegexp

	// no validation rules for GerritProjectRegexp

	// no validation rules for GerritRefRegexp

	// no validation rules for PathRegexp

	// no validation rules for Exclude

	if len(errors) > 0 {
		return Verifiers_Tryjob_Builder_LocationFilterMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_Builder_LocationFilterMultiError is an error wrapping
// multiple validation errors returned by
// Verifiers_Tryjob_Builder_LocationFilter.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_Tryjob_Builder_LocationFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_Builder_LocationFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_Builder_LocationFilterMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_Builder_LocationFilterValidationError is the validation
// error returned by Verifiers_Tryjob_Builder_LocationFilter.Validate if the
// designated constraints aren't met.
type Verifiers_Tryjob_Builder_LocationFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) ErrorName() string {
	return "Verifiers_Tryjob_Builder_LocationFilterValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_Builder_LocationFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_Builder_LocationFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_Builder_LocationFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_Builder_LocationFilterValidationError{}

// Validate checks the field values on Verifiers_Tryjob_Builder_SkipFooter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Verifiers_Tryjob_Builder_SkipFooter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Verifiers_Tryjob_Builder_SkipFooter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Verifiers_Tryjob_Builder_SkipFooterMultiError, or nil if none found.
func (m *Verifiers_Tryjob_Builder_SkipFooter) ValidateAll() error {
	return m.validate(true)
}

func (m *Verifiers_Tryjob_Builder_SkipFooter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for ValueRegexp

	if len(errors) > 0 {
		return Verifiers_Tryjob_Builder_SkipFooterMultiError(errors)
	}

	return nil
}

// Verifiers_Tryjob_Builder_SkipFooterMultiError is an error wrapping multiple
// validation errors returned by
// Verifiers_Tryjob_Builder_SkipFooter.ValidateAll() if the designated
// constraints aren't met.
type Verifiers_Tryjob_Builder_SkipFooterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Verifiers_Tryjob_Builder_SkipFooterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Verifiers_Tryjob_Builder_SkipFooterMultiError) AllErrors() []error { return m }

// Verifiers_Tryjob_Builder_SkipFooterValidationError is the validation error
// returned by Verifiers_Tryjob_Builder_SkipFooter.Validate if the designated
// constraints aren't met.
type Verifiers_Tryjob_Builder_SkipFooterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) ErrorName() string {
	return "Verifiers_Tryjob_Builder_SkipFooterValidationError"
}

// Error satisfies the builtin error interface
func (e Verifiers_Tryjob_Builder_SkipFooterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifiers_Tryjob_Builder_SkipFooter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Verifiers_Tryjob_Builder_SkipFooterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Verifiers_Tryjob_Builder_SkipFooterValidationError{}

// Validate checks the field values on UserLimit_Limit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLimit_Limit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLimit_Limit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLimit_LimitMultiError, or nil if none found.
func (m *UserLimit_Limit) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLimit_Limit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Limit.(type) {
	case *UserLimit_Limit_Value:
		if v == nil {
			err := UserLimit_LimitValidationError{
				field:  "Limit",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Value
	case *UserLimit_Limit_Unlimited:
		if v == nil {
			err := UserLimit_LimitValidationError{
				field:  "Limit",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Unlimited
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return UserLimit_LimitMultiError(errors)
	}

	return nil
}

// UserLimit_LimitMultiError is an error wrapping multiple validation errors
// returned by UserLimit_Limit.ValidateAll() if the designated constraints
// aren't met.
type UserLimit_LimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLimit_LimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLimit_LimitMultiError) AllErrors() []error { return m }

// UserLimit_LimitValidationError is the validation error returned by
// UserLimit_Limit.Validate if the designated constraints aren't met.
type UserLimit_LimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLimit_LimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLimit_LimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLimit_LimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLimit_LimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLimit_LimitValidationError) ErrorName() string { return "UserLimit_LimitValidationError" }

// Error satisfies the builtin error interface
func (e UserLimit_LimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLimit_Limit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLimit_LimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLimit_LimitValidationError{}

// Validate checks the field values on UserLimit_Run with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserLimit_Run) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLimit_Run with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserLimit_RunMultiError, or
// nil if none found.
func (m *UserLimit_Run) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLimit_Run) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMaxActive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserLimit_RunValidationError{
					field:  "MaxActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserLimit_RunValidationError{
					field:  "MaxActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxActive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserLimit_RunValidationError{
				field:  "MaxActive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReachLimitMsg

	if len(errors) > 0 {
		return UserLimit_RunMultiError(errors)
	}

	return nil
}

// UserLimit_RunMultiError is an error wrapping multiple validation errors
// returned by UserLimit_Run.ValidateAll() if the designated constraints
// aren't met.
type UserLimit_RunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLimit_RunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLimit_RunMultiError) AllErrors() []error { return m }

// UserLimit_RunValidationError is the validation error returned by
// UserLimit_Run.Validate if the designated constraints aren't met.
type UserLimit_RunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLimit_RunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLimit_RunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLimit_RunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLimit_RunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLimit_RunValidationError) ErrorName() string { return "UserLimit_RunValidationError" }

// Error satisfies the builtin error interface
func (e UserLimit_RunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLimit_Run.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLimit_RunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLimit_RunValidationError{}

// Validate checks the field values on UserLimit_Tryjob with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLimit_Tryjob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLimit_Tryjob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLimit_TryjobMultiError, or nil if none found.
func (m *UserLimit_Tryjob) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLimit_Tryjob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMaxActive()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserLimit_TryjobValidationError{
					field:  "MaxActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserLimit_TryjobValidationError{
					field:  "MaxActive",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxActive()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserLimit_TryjobValidationError{
				field:  "MaxActive",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserLimit_TryjobMultiError(errors)
	}

	return nil
}

// UserLimit_TryjobMultiError is an error wrapping multiple validation errors
// returned by UserLimit_Tryjob.ValidateAll() if the designated constraints
// aren't met.
type UserLimit_TryjobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLimit_TryjobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLimit_TryjobMultiError) AllErrors() []error { return m }

// UserLimit_TryjobValidationError is the validation error returned by
// UserLimit_Tryjob.Validate if the designated constraints aren't met.
type UserLimit_TryjobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLimit_TryjobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLimit_TryjobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLimit_TryjobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLimit_TryjobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLimit_TryjobValidationError) ErrorName() string { return "UserLimit_TryjobValidationError" }

// Error satisfies the builtin error interface
func (e UserLimit_TryjobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLimit_Tryjob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLimit_TryjobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLimit_TryjobValidationError{}
