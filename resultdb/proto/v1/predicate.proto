// Copyright 2019 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package luci.resultdb.v1;

import "go.chromium.org/luci/resultdb/proto/v1/common.proto";

option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
option java_package = "com.google.luci.resultdb.v1";
option java_multiple_files = true;

// Represents a function TestResult -> bool.
// Empty message matches all test results.
//
// Most clients would want to set expected_results to
// VARIANTS_WITH_UNEXPECTED_RESULTS.
message TestResultPredicate {
  // A test result must have a test id matching this regular expression
  // entirely, i.e. the expression is implicitly wrapped with ^ and $.
  string test_id_regexp = 1;

  // A test result must have a variant satisfying this predicate.
  VariantPredicate variant = 2;

  // Filters test results based on TestResult.expected field.
  enum Expectancy {
    // All test results satisfy this.
    // WARNING: using this significantly increases response size and latency.
    ALL = 0;

    // A test result must belong to a test variant that has one or more
    // unexpected results. It can be used to fetch both unexpected and flakily
    // expected results.
    //
    // Note that the predicate is defined at the test variant level.
    // For example, if a test variant expects a PASS and has results
    // [FAIL, FAIL, PASS], then all results satisfy the predicate because
    // the variant satisfies the predicate.
    VARIANTS_WITH_UNEXPECTED_RESULTS = 1;

    // Similar to VARIANTS_WITH_UNEXPECTED_RESULTS, but the test variant
    // must not have any expected results.
    VARIANTS_WITH_ONLY_UNEXPECTED_RESULTS = 2;
  }

  // A test result must match this predicate based on TestResult.expected field.
  // Most clients would want to override this field because the default
  // typically causes a large response size.
  Expectancy expectancy = 3;

  // If true, filter out exonerated test variants.
  // Mutually exclusive with Expectancy.ALL.
  //
  // If false, the filter is NOT applied.
  // That is, the test result may or may not be exonerated.
  bool exclude_exonerated = 4;
}

// Represents a function TestExoneration -> bool.
// Empty message matches all test exonerations.
message TestExonerationPredicate {
  // A test exoneration must have a test id matching this regular expression
  // entirely, i.e. the expression is implicitly wrapped with ^ and $.
  string test_id_regexp = 1;

  // A test exoneration must have a variant satisfying this predicate.
  VariantPredicate variant = 2;
}

// Represents a function Variant -> bool.
message VariantPredicate {
  oneof predicate {
    // A variant must be equal this definition exactly.
    Variant equals = 1;

    // A variant's key-value pairs must contain those in this one.
    Variant contains = 2;
  }
}

// Represents a function Artifact -> bool.
// Next id: 9
message ArtifactPredicate {
  // A set of Invocation's outgoing edge types.
  //
  // DEPRECATED: Use the ArtifactKind instead which is compatible with root
  // invocations.
  message EdgeTypeSet {
    // The edges represented by Invocation.included_invocations field.
    bool included_invocations = 1;
    // The parent-child relationship between Invocation and TestResult.
    bool test_results = 2;
  }

  // Specifies which edges to follow when retrieving directly/indirectly
  // included artifacts.
  // For example,
  // - to retrieve only invocation-level artifacts, use
  //   {included_invocations: true}.
  // - to retrieve only test-result-level artifacts, use {test_results: true}.
  //
  // By default, follows all edges.
  //
  // DEPRECATED: Use the artifact_kind instead which is compatible with root
  // invocations.
  EdgeTypeSet follow_edges = 1 [ deprecated = true ];  // defaults to All.

   // Filters artifacts based on the kind they belong to.
   // Next id: 3
  enum ArtifactKind {
    // Artifacts from all data kinds including work units and test results are
    // returned.
    // Default value.
    ARTIFACT_KIND_UNSPECIFIED = 0;

    // Only work unit artifacts are returned.
    WORK_UNIT = 1;
  }

  // Specifies which kind of artifacts are returned.
  ArtifactKind artifact_kind = 7;

  // The resource names of the work units to filter the response to.
  // See WorkUnit.name. The work units must be from the same root invocation as
  // the parent field.
  //
  // If set, only artifacts from the specified work units are returned.
  repeated string work_units = 8;

  // If an Artifact belongs to a TestResult, then the test result must satisfy
  // this predicate.
  // Note: this predicate does NOT apply to invocation-level artifacts.
  // To exclude them from the response, use follow_edges.
  //
  // DEPRECATED: This option is not supported for root invocations.
  TestResultPredicate test_result_predicate = 2 [ deprecated = true ];

  // An artifact must have a content type matching this regular expression
  // entirely, i.e. the expression is implicitly wrapped with ^ and $.
  // Defaults to ".*".
  string content_type_regexp = 3;

  // An artifact must have an ID matching this regular expression entirely, i.e.
  // the expression is implicitly wrapped with ^ and $.  Defaults to ".*".
  string artifact_id_regexp = 4;

  // An artifact must have an artifact type matching this regular expression
  // entirely, i.e. the expression is implicitly wrapped with ^ and $.
  // Defaults to ".*".
  string artifact_type_regexp = 5;
}

// Represents a function TestMetadata -> bool.
// Empty message matches all test metadata.
message TestMetadataPredicate {
  // Filters to tests with a test_id in this list.
  repeated string test_ids = 1;

  // Filters to tests which have a test_metadata.previous_test_id in this list.
  // Use to find newer tests corresponding to a given old test ID.
  // May not be used in conjunction with test_ids.
  repeated string previous_test_ids = 2;
}

// Represents a function WorkUnit -> bool.
message WorkUnitPredicate {
  // If set, filters to ancestors of the specified work unit.
  //
  // When specified, the result will be a list of work units ordered
  // from closest parent to furthest parent.
  string ancestors_of = 1;
}

// Represents a function TestAggregation -> bool.
message TestAggregationPredicate {
  // The level of aggregate to return.
  // All values except CASE are supported. For CASE-level aggregations,
  // use QueryTestVerdicts instead.
  // Required.
  AggregationLevel aggregation_level = 1;

  // The test prefix for which to return aggregates.
  //
  // The test prefix must not be more precise than the requested aggregation_level.
  // For example, if the requested aggregation_level is COARSE, you may not
  // use a test_id_prefix with an aggregation_level of FINE.
  //
  // Example #1: To obtain coarse-level aggregates in a module:
  // - set the requested aggregation_level to COARSE.
  // - set the test_prefix_filter.aggregation_level to MODULE, and
  // - test_prefix_filter.id to the Test ID prefix of that module.
  //
  // Example #2: To obtain the invocation-level aggregate:
  // - set the requested aggregation_level to INVOCATION.
  // - leave the test_prefix_filter unset, or set it to
  //   test_id_prefix.aggregation_level to INVOCATION.
  TestIdentifierPrefix test_prefix_filter = 2;

  // Limits results to only those test aggregations that *contain* a test result
  // matching this filter.
  //
  // The filter is an AIP-160 filter string (see https://google.aip.dev/160 for syntax),
  // with the following fields available:
  // - test_id (string) - the flat-form test ID
  // - test_id_structured.module_name (string) - the structured form test ID
  // - test_id_structured.module_scheme (string)
  // - test_id_structured.module_variant (filters behave as if this field is a map<string, string>)
  // - test_id_structured.module_variant_hash (string)
  // - test_id_structured.coarse_name (string)
  // - test_id_structured.fine_name (string)
  // - test_id_structured.case_name (string)
  // - test_metadata.name (string)
  // - tags (repeated (key string, value string))
  // - test_metadata.location.repo (string)
  // - test_metadata.location.file_name (string)
  // - status (enum luci.resultdb.v1.TestResult.Status) - the status_v2 of the test result
  // - duration (google.protobuf.Duration)
  //
  // While this filter generally offers a superset of functionality of the `test_prefix_filter`
  // field, clients will generally prefer to use `test_prefix_filter` if it is
  // sufficient as its use has less sharp edges (e.g. no need to escape test ID
  // components when injecting them into filter strings, filtering on a variant is exact
  // and not simply checking for presence of a subset of key/value pairs).
  //
  // Note: Setting this to a filter that will always evaluate to true yields
  // different results to leaving this filter unset, in that the former filters to
  // only aggregations with test results and the latter returns any test aggregation.
  // Aggregations without test results can occur for module and invocation-level
  // aggregations.
  string contains_test_result_filter = 3;

  // A free-form filter on the returned `TestAggregation`s.
  //
  // The filter is an AIP-160 filter string (see https://google.aip.dev/160 for syntax),
  // with the following fields available:
  // - verdict_counts.failed (number)
  // - verdict_counts.flaky (number)
  // - verdict_counts.passed (number)
  // - verdict_counts.skipped (number)
  // - verdict_counts.execution_errored (number)
  // - verdict_counts.precluded (number)
  // - verdict_counts.exonerated (number)
  // - module_status (luci.resultdb.v1.TestAggregation.ModuleStatus):
  //   for aggregations at Invocation, Coarse and Fine levels, this field is
  //   be MODULE_STATUS_UNSPECIFIED, so is only useful for filtering Module-level
  //   aggregations.
  string filter = 4;
}

// Represents a function TestVerdict -> bool.
message TestVerdictPredicate {
  // The test prefix for which to return verdicts.
  //
  // Example: To limit verdicts to those for a given module:
  // - set the test_prefix_filter.aggregation_level to MODULE, and
  // - test_prefix_filter.id to the Test ID prefix of that module.
  TestIdentifierPrefix test_prefix_filter = 1;

  // Limits results to only those test verdicts that *contain* a test result
  // matching this filter.
  //
  // The filter is an AIP-160 filter string (see https://google.aip.dev/160 for syntax),
  // with the following fields available:
  // - test_id (string) - the flat-form test ID
  // - test_id_structured.module_name (string) - the structured form test ID
  // - test_id_structured.module_scheme (string)
  // - test_id_structured.module_variant (filters behave as if this field is a map<string, string>)
  // - test_id_structured.module_variant_hash (string)
  // - test_id_structured.coarse_name (string)
  // - test_id_structured.fine_name (string)
  // - test_id_structured.case_name (string)
  // - test_metadata.name (string)
  // - tags (repeated (key string, value string))
  // - test_metadata.location.repo (string)
  // - test_metadata.location.file_name (string)
  // - status (enum luci.resultdb.v1.TestResult.Status) - the status_v2 of the test result
  // - duration (google.protobuf.Duration)
  //
  // While this filter generally offers a superset of functionality of the `test_prefix_filter`
  // field, clients will generally prefer to use `test_prefix_filter` if it is
  // sufficient as its use has less sharp edges (e.g. no need to escape test ID
  // components when injecting them into filter strings, filtering on a variant is exact
  // and not simply checking for presence of a subset of key/value pairs).
  string contains_test_result_filter = 2;

  // Represents a filter on the effective status of a test verdict,
  // the result of combining the TestVerdict.Status and TestVerdict.StatusOverride.
  enum VerdictEffectiveStatus {
    // Do not use.
    VERDICT_EFFECTIVE_STATUS_UNSPECIFIED = 0;
    // The test failed, and was not exonerated.
    FAILED = 10;
    // The test execution errored, and was not exonerated.
    EXECUTION_ERRORED = 20;
    // The test execution was precluded, and was not exonerated.
    PRECLUDED = 30;
    // The test was flaky, and was not exonerated.
    FLAKY = 40;
    // The test was skipped.
    SKIPPED = 50;
    // The test passed.
    PASSED = 60;
    // The test was originally failed, execution errored, precluded or flaky,
    // but the subject of the test (e.g. the CL under test) was absolved from blame.
    // For example, because the failure also existed in the tree without the
    // changelist applied.
    EXONERATED = 70;
  }

  // If set, filters the verdicts to the given effective status(es).
  //
  // The effective verdict status is the status of the test verdict after
  // applying any status overrides.
  repeated VerdictEffectiveStatus effective_verdict_status = 4;

  // For free-form AIP-160 filter.
  reserved 3;
  reserved "filter";
}
