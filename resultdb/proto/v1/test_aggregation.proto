// Copyright 2025 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package luci.resultdb.v1;

import "go.chromium.org/luci/resultdb/proto/v1/common.proto";

option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
option java_package = "com.google.luci.resultdb.v1";
option java_multiple_files = true;

// TestAggregation represents a summary of all test cases in a root invocation,
// module, coarse_name or fine_name.
message TestAggregation {
  // The test identifier prefix represented by the test aggregate.
  TestIdentifierPrefix id = 1;

  // The next (finer) aggregation level to use if drilling into this aggregate,
  // based on the currently defined scheme information.
  // Some schemes do not use one or both intermediate hierarchy levels, this
  // makes it easy to skip them.
  // If unset, no finer aggregation is available and the next finer level
  // is test verdicts.
  AggregationLevel next_finer_level = 2;

  // Counts of test case verdicts, by status v2.
  message VerdictCounts {
    // Counts by final status (after any status override like exoneration).

    // The number of failed test cases.
    // A test case is failed if it has a failed result and no passed results.
    // Count includes only non-exonerated failed verdicts.
    int32 failed = 1;
    // The number of flaky test cases.
    // A flaky test case is any test case with both a passed and a failed result.
    // Count includes only non-exonerated flaky verdicts.
    int32 flaky = 2;
    // The number of passed test cases.
    // A test case is passed if it has a passed result and no failed results.
    int32 passed = 3;
    // The number of skipped test cases.
    // A test case is skipped if it has a skipped result and no passed or failed results.
    int32 skipped = 4;
    // The number of execution errored test cases.
    // A test case is execution errored if it has an execution errored result, and no
    // passing, failing or skipped results.
    // Count includes only non-exonerated execution errored verdicts.
    int32 execution_errored = 5;
    // The number of precluded test cases.
    // A test case is precluded if it only has precluded results.
    // Count includes only non-exonerated precluded verdicts.
    int32 precluded = 6;
    // The number of exonerated test cases.
    int32 exonerated = 7;

    // Counts by base status (before any status override like exoneration).

    // A test case is failed if it has a failed result and no passed results.
    // This differs from `failed` in that it includes exonerated failures.
    int32 failed_base = 8;
    // A flaky test case is any test case with both a passed and a failed result.
    // This differs from `flaky` in that it includes exonerated flakes.
    int32 flaky_base = 9;
    // A test case is passed if it has a passed result and no failed results.
    // This is currently always the same as `passed` but could diverge if additional
    // status overrides are introduced.
    int32 passed_base = 10;
    // A test case is skipped if it has a skipped result and no passed or failed results.
    // This is currently always the same as `skipped` but could diverge if additional
    // status overrides are introduced.
    int32 skipped_base = 11;
    // A test case is execution errored if it has an execution errored result, and no
    // passing, failing or skipped results.
    // This differs from `execution_errored` in that it includes exonerated
    // execution errored verdicts.
    int32 execution_errored_base = 12;
    // A test case is precluded if it only has precluded results.
    // This differs from `precluded` in that it includes exonerated precluded verdicts.
    int32 precluded_base = 13;
  }

  // The counts of test verdict statuses rolling up to this aggregation.
  VerdictCounts verdict_counts = 3;

  // Module status. This is based on the work unit status and reflects
  // the success running and uploading test results to ResultDB, not the
  // success of the test cases themselves.
  //
  // The module status is aggregated from the status of top-level work units
  // associated with that module as follows:
  // - When combining top-level work units within a module-shard, where
  //   the shard can be retried multiple times and only one attempt needs
  //   to succeed, the greatest status in the following order wins:
  //   SUCCEEDED > RUNNING > PENDING > SKIPPED > FAILED > CANCELLED.
  // - When combining module-shards into the overall module status,
  //   where we need all shards must succeed for the whole to succeed, the
  //   greatest status in the following order wins:
  //   FAILED > RUNNING > PENDING > CANCELLED > SUCCEEDED > SKIPPED.
  //
  // The "RUNNING" and "PENDING" statuses were placed one behind the greatest
  // status in each order, to propagate the known uncertainties about the final
  // status of the module and preference alerting users about problems that
  // look final over those that are known to have retries pending. Of course,
  // until the root invocation is finalized, all module statuses are subject to
  // revision as more shards/retries may still be created.
  //
  // In aggregated form, the FAILED work unit status is renamed "ERRORED" to
  // avoid confusion with the FAILED verdict status and connect it to the
  // "EXECUTION_ERRORED" verdict status, which is closer in meaning.
  //
  // In root invocations that are finalized, the status "RUNNING" and "PENDING"
  // will never occur as all work units will be in final states.
  enum ModuleStatus {
    MODULE_STATUS_UNSPECIFIED = 0;
    // The module succeeded.
    //
    // When seen on a finalized root invocation, means that for every
    // module-shard, there was a top-level work unit with a status of
    // SUCCEEDED or SKIPPED
    // ("no failed or cancelled module-shards").
    //
    // And moreover, there was at least one module-shard with a top-level
    // work unit with a status of SUCCEEDED
    // ("at least one succeeded module-shard").
    SUCCEEDED = 1;
    // The module failed to run and/or upload all test cases.
    //
    // When seen on a finalized root invocation, means that there
    // was at least one module-shard that:
    // - consisted only of FAILED or CANCELLED top-level work units, and
    // - one of these was a FAILED top-level work unit.
    ERRORED = 2;
    // The module was skipped.
    //
    // When seen on a finalized root invocation, means that for every
    // module-shard, there was a top-level work unit with a status of SKIPPED.
    //
    // And moreover, there was no module-shard with a top-level work unit that
    // had a status of SUCCEEDED ("no succeeded module-shards").
    SKIPPED = 3;
    // The module was cancelled.
    //
    // When seen on a finalized root invocation, means that there was at
    // least one module-shard that consisted only of CANCELLED top-level work units.
    //
    // And moreover, there was no module-shard that had a FAILED
    // top-level work unit, that did not also have a SKIPPED or SUCCEEDED
    // top-level work unit.
    CANCELLED = 4;
    // The module is running.
    RUNNING = 5;
    // The module is pending.
    PENDING = 6;
  }

  // The module status. Set only for module-level aggregations.
  //
  // This reflects the success running and uploading test results to ResultDB,
  // not the success of the test cases themselves.
  ModuleStatus module_status = 4;

  // Counts of module statuses.
  message ModuleStatusCounts {
    // The number of modules that succeeded.
    int32 succeeded = 1;
    // The number of modules that failed.
    int32 failed = 2;
    // The number of modules that skipped.
    int32 skipped = 3;
    // The number of modules that were cancelled.
    int32 cancelled = 4;
    // The number of modules that are running.
    int32 running = 5;
    // The number of modules that are pending.
    int32 pending = 6;
  }

  // The module status counts. Set only for invocation-level aggregations.
  ModuleStatusCounts module_status_counts = 5;
}
