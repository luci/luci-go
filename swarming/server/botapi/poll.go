// Copyright 2024 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package botapi

import (
	"context"
	"fmt"
	"slices"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"go.chromium.org/luci/common/clock"
	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"
	"go.chromium.org/luci/common/retry/transient"

	internalspb "go.chromium.org/luci/swarming/proto/internals"
	"go.chromium.org/luci/swarming/server/botsession"
	"go.chromium.org/luci/swarming/server/botsrv"
	"go.chromium.org/luci/swarming/server/botstate"
	"go.chromium.org/luci/swarming/server/cfg"
	"go.chromium.org/luci/swarming/server/validate"
)

// PollCommand instructs the bot what to do after it calls /bot/poll.
type PollCommand string

const (
	// PollRBE tells the bot it should open and run an RBE session.
	PollRBE PollCommand = "rbe"
	// PollSleep tells the bot it should shutdown the RBE session and sleep.
	PollSleep PollCommand = "sleep"
	// PollUpdate tells the bot it should self-update.
	PollUpdate PollCommand = "update"
	// PollBotRestart tells the bot process to restart.
	PollBotRestart PollCommand = "bot_restart"
)

// PollRequest is sent by the bot.
type PollRequest struct {
	// Session is a serialized Swarming Bot Session proto.
	Session []byte `json:"session"`

	// Dimensions are the current dimensions collected by the bot.
	//
	// At least `id` dimension must be set. It is the bot ID.
	Dimensions map[string][]string `json:"dimensions"`

	// State is (mostly) arbitrary JSON dict with various properties of the bot.
	//
	// Values here are not indexed and they do not affect how tasks are scheduled
	// on the bot. The server is still aware of some keys and checks them to
	// decide how to handle the bot calls.
	State botstate.Dict `json:"state"`

	// Version is the bot's own version.
	//
	// It is a digest of the running bot archive. Used to detect if the bot should
	// self-update.
	Version string `json:"version"`

	// RequestUUID is used to skip reporting duplicate events on retries.
	//
	// Generated by the client (usually an UUID4 string). Optional.
	RequestUUID string `json:"request_uuid,omitempty"`
}

func (r *PollRequest) ExtractSession() []byte { return r.Session }
func (r *PollRequest) ExtractDebugRequest() any {
	return &PollRequest{
		Session:     nil,
		Dimensions:  r.Dimensions,
		State:       r.State,
		Version:     r.Version,
		RequestUUID: r.RequestUUID,
	}
}

// PollResponse is returned by the server.
type PollResponse struct {
	// Cmd instructs the bot what to do next.
	Cmd PollCommand `json:"cmd"`

	// Session is an updated serialized Swarming Bot Session proto.
	Session []byte `json:"session,omitempty"`

	// Duration is how long to sleep (in seconds) for PollSleep command.
	Duration float64 `json:"duration,omitempty"`

	// Version is the bot version to update to for PollUpdate command.
	Version string `json:"version,omitempty"`

	// Message is why the bot is restarting for PollBotRestart command.
	Message string `json:"message,omitempty"`

	// RBE contains parameters of the RBE session for PollRBE command.
	RBE *BotRBEParams `json:"rbe,omitempty"`
}

// Poll implements the handler that collects information about the bot.
//
// In the past it also used to tell the bot what to execute (the bot was
// "polling for work") but this is now done through RBE session endpoints. Now
// this handler is more of a "heartbeat" handler, called occasionally by the bot
// when it is in-between tasks.
//
// This handler does following:
//   - Registers heartbeats from the bot (updating BotInfo.LastSeenTs).
//   - Updates the bot state in the datastore (dimensions, state, health).
//   - Refreshes the bot's session token.
//   - Issues self-update and restart commands.
//   - Tells the bot what RBE instance to use.
func (srv *BotAPIServer) Poll(ctx context.Context, body *PollRequest, _ *botsrv.Request) (botsrv.Response, error) {
	// Parse and validate the request.
	pr, err := srv.processPoll(ctx, body)
	if err != nil {
		return nil, err
	}
	_ = pr
	return nil, status.Errorf(codes.Unimplemented, "not implemented yet")
}

// pollRequest contains information extracted from the poll request.
//
// Note the request may still be pretty broken. It will still be accepted, since
// we need to process it to record the bot as quarantined (for sending broken
// requests). Otherwise such broken requests are hard to surface.
type pollRequest struct {
	botID string // ID of the bot extracted from the session or dimensions

	errs errors.MultiError // all request validation errors, if any

	session       *internalspb.Session // validated session or nil if missing or broken
	sessionBroken bool                 // true if there is a session token, but it is broken

	version     string        // the bot version from the request, if known
	requestUUID string        // the request UUID for idempotency, if known
	state       botstate.Dict // validated state dict or an empty dict if broken
	dims        []string      // bot's "k:v" dimensions or nil if they are invalid

	conf  *cfg.Config   // the config snapshot used to authorize the bot
	group *cfg.BotGroup // the group the bot belongs to
}

// processPoll parses poll arguments, does validation and authorization.
//
// If the request is authorized, but has invalid dimensions or state, returns
// *poolRequest with `errs` inside. The bot will be put into quarantine in that
// case.
func (srv *BotAPIServer) processPoll(ctx context.Context, body *PollRequest) (*pollRequest, error) {
	// Bots are expected to send session tokens. But very old bots don't. We
	// should tolerate missing token to let old bots to self-update. The same for
	// expired or broken session tokens (except we'll ask the bot to restart to
	// get a new token).
	var session *internalspb.Session
	var sessionBroken bool
	if len(body.Session) != 0 {
		var err error
		session, err = botsession.CheckSessionToken(body.Session, srv.hmacSecret, clock.Now(ctx))
		if err != nil {
			logging.Warningf(ctx, "Bad session token: %s", err)
			if session != nil {
				botsession.LogSession(ctx, session)
			}
			sessionBroken = true
			session = nil
		}
	}

	// There must be "id" dimension. We'll validate the rest of dimensions later.
	botIDFromDims, err := peekBotID(body.Dimensions)
	if err != nil {
		return nil, err
	}

	// If have a valid session, use bot ID from it. Otherwise fallback to
	// dimensions. Both should be equal in correctly functioning bots. We'll check
	// that later.
	var botID string
	if session != nil {
		botID = session.BotId
	} else {
		botID = botIDFromDims
	}

	// If have a valid session, use its LastSeenConfig to force fetch the correct
	// version of the server config. Otherwise the bot might observe config going
	// back in time if it hits a backend with an older cached config.
	var conf *cfg.Config
	if session != nil {
		var err error
		conf, err = srv.cfg.FreshEnough(ctx, session.LastSeenConfig.AsTime())
		if err != nil {
			return nil, status.Errorf(codes.Internal, "failed to fetch service config")
		}
	} else {
		conf = srv.cfg.Cached(ctx)
	}

	// Authorize the bot. Note that unlike most other handlers, we use the current
	// server config here (not the snapshot stored in the session), because Poll
	// handler is where this snapshot is actually refreshed.
	group := conf.BotGroup(botID)
	if err := srv.authorizeBot(ctx, botID, group.Auth); err != nil {
		if transient.Tag.In(err) {
			return nil, status.Errorf(codes.Internal, "transient error checking bot credentials: %s", err)
		}
		return nil, status.Errorf(codes.Unauthenticated, "the bot is not in bots.cfg or wrong credentials passed: %s", err)
	}

	// Validate dimensions. We'll quarantine the bot if they are malformed.
	var errs errors.MultiError
	for _, err := range validate.BotDimensions(body.Dimensions) {
		errs = append(errs, errors.Annotate(err, "bad dimensions").Err())
	}
	if session != nil && session.BotId != botIDFromDims {
		errs = append(errs, errors.Reason(`"id" dimension %q doesn't match bot ID in the session %q`, botIDFromDims, session.BotId).Err())
	}

	// If dimensions are valid, apply server-enforced dimensions on top. This is
	// a security-critical feature, since "pool" is one of such server-enforced
	// dimensions.
	//
	// Note `dims` will remain nil if dimensions are broken. It is an indication
	// that they should not be stored in BotInfo.
	var dims []string
	if len(errs) == 0 {
		for key, vals := range body.Dimensions {
			if _, set := group.Dimensions[key]; !set {
				for _, val := range vals {
					dims = append(dims, fmt.Sprintf("%s:%s", key, val))
				}
			}
		}
		for key, vals := range group.Dimensions {
			for _, val := range vals {
				dims = append(dims, fmt.Sprintf("%s:%s", key, val))
			}
		}
		slices.Sort(dims)
	}

	// Validate the state is a correct JSON. We'll quarantine the bot if it isn't.
	state := body.State
	if err := state.Unseal(); err != nil {
		errs = append(errs, errors.Annotate(err, "bad state dict").Err())
		state = botstate.Dict{}
	}

	// A version string is required.
	if body.Version == "" {
		errs = append(errs, errors.Reason("no `version` in the request").Err())
	}

	// Log all errors for easier debugging.
	for _, err := range errs {
		logging.Errorf(ctx, "Validation error: %s", err)
	}

	return &pollRequest{
		botID:         botID,
		errs:          errs,
		session:       session,
		sessionBroken: sessionBroken,
		version:       body.Version,
		requestUUID:   body.RequestUUID,
		state:         state,
		dims:          dims,
		conf:          conf,
		group:         group,
	}, nil
}
