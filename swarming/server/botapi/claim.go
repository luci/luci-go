// Copyright 2024 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package botapi

import (
	"context"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"go.chromium.org/luci/auth/identity"

	"go.chromium.org/luci/swarming/server/botsrv"
	"go.chromium.org/luci/swarming/server/botstate"
	"go.chromium.org/luci/swarming/server/model"
)

// ClaimCommand instructs the bot what to do after it calls /bot/claim.
type ClaimCommand string

const (
	// ClaimSkip means the bot should skip this task and poll for another one.
	ClaimSkip ClaimCommand = "skip"
	// ClaimRun means the bot should start running the task.
	ClaimRun ClaimCommand = "run"
	// ClaimTerminate means the bot process should gracefully terminate.
	ClaimTerminate ClaimCommand = "terminate"
)

// ClaimRequest is sent by the bot.
type ClaimRequest struct {
	// Session is a serialized Swarming Bot Session proto.
	Session []byte `json:"session"`

	// State is (mostly) arbitrary JSON dict with various properties of the bot.
	//
	// This field is used by the bot to opportunistically report its state changes
	// when running tasks back-to-back (since it doesn't call /bot/poll in that
	// case and has no other way to report the state).
	//
	// Optional.
	State botstate.Dict `json:"state,omitempty"`

	// ClaimID is an opaque string used to make this request idempotent.
	//
	// Generated by the bot (usually derived from RBE's lease ID, but it is not
	// a requirement).
	//
	// Required.
	ClaimID string `json:"claim_id"`

	// TaskID is the TaskResultSummary packed key of the task to claim.
	//
	// The bot takes it from the RBE task payload and passes it to /bot/claim as
	// is, see swarming.internals.rbe.TaskPayload proto message.
	//
	// Required.
	TaskID string `json:"task_id"`

	// TaskToRunShard is an entity class shard index for claimed TaskToRun.
	//
	// The bot takes it from the RBE task payload and passes it to /bot/claim as
	// is, see swarming.internals.rbe.TaskPayload proto message.
	//
	// Required.
	TaskToRunShard int `json:"task_to_run_shard"`

	// TaskToRunID identifies TaskToRun to claim.
	//
	// The bot takes it from the RBE task payload and passes it to /bot/claim as
	// is, see swarming.internals.rbe.TaskPayload proto message.
	//
	// Required.
	TaskToRunID int64 `json:"task_to_run_id"`
}

func (r *ClaimRequest) ExtractSession() []byte { return r.Session }
func (r *ClaimRequest) ExtractDebugRequest() any {
	return &ClaimRequest{
		Session:        nil,
		State:          r.State,
		ClaimID:        r.ClaimID,
		TaskID:         r.TaskID,
		TaskToRunShard: r.TaskToRunShard,
		TaskToRunID:    r.TaskToRunID,
	}
}

// ClaimResponse is returned by the server.
type ClaimResponse struct {
	// Cmd instructs the bot what to do next.
	Cmd ClaimCommand `json:"cmd"`

	// Session is a serialized bot session proto.
	//
	// If not empty, contains the refreshed session.
	Session []byte `json:"session,omitempty"`

	// Manifest is full details about the task to execute.
	//
	// Present only for ClaimRun command.
	Manifest *TaskManifest `json:"manifest,omitempty"`

	// TaskID is TaskRunResult ID of the task to run (if any).
	//
	// This is populated for both ClaimRun and ClaimTerminate.
	TaskID string `json:"task_id,omitempty"`
}

// TaskManifest describes to the bot what it should execute.
//
// This is based to the task runner process.
type TaskManifest struct {
	// TaskID is TaskRunResult ID of the task to run.
	TaskID string `json:"task_id"`

	// Caches is a list of named caches requested by the task.
	Caches []TaskCache `json:"caches,omitempty"`
	// CIPDInput are CIPD packages that the bot should fetch.
	CIPDInput *model.CIPDInput `json:"cipd_input,omitempty"`
	// Command is the actual command line the bot should execute.
	Command []string `json:"command"`
	// Containment describes the task process containment (not implemented).
	Containment *model.Containment `json:"containment,omitempty"`
	// Dimensions are task's dimension requirements.
	Dimensions model.TaskDimensions `json:"dimensions"`
	// Env is the environment variables to set.
	Env model.Env `json:"env,omitempty"`
	// EnvPrefixes is values to prepend to environment variables.
	EnvPrefixes model.EnvPrefixes `json:"env_prefixes,omitempty"`
	// GracePeriodSecs is how long to wait for the task to gracefully terminate.
	GracePeriodSecs int64 `json:"grace_period"`
	// HardTimeoutSecs is how long to allow the task to run.
	HardTimeoutSecs int64 `json:"hard_timeout"`
	// IOTimeoutSecs is how long to allow no stdout before the task is terminated.
	IOTimeoutSecs int64 `json:"io_timeout"`
	// SecretBytes are the task secret, if any.
	SecretBytes []byte `json:"secret_bytes,omitempty"`
	// CASInputRoot is what CAS files to fetch.
	CASInputRoot *model.CASDigest `json:"cas_input_root,omitempty"`
	// Outputs are list of extra outputs to upload to RBE-CAS as task results.
	Outputs []string `json:"outputs,omitempty"`
	// Realm is the task's security realm.
	Realm *TaskRealm `json:"realm,omitempty"`
	// RelativeCwd is the directory to set as current when running the task.
	RelativeCwd string `json:"relative_cwd,omitempty"`
	// ResultDB is parameters of the ResultDB invocation for the task.
	ResultDB *TaskResultDB `json:"resultdb,omitempty"`
	// ServiceAccounts describe what service account a task can use.
	ServiceAccounts struct {
		System TaskServiceAccount `json:"system"`
		Task   TaskServiceAccount `json:"task"`
	} `json:"service_accounts"`

	// BotID is the ID of the calling bot.
	BotID string `json:"bot_id"`
	// BotDimensions are dimensions of the calling bot.
	BotDimensions map[string][]string `json:"bot_dimensions"`
	// BotAuthenticatedAs is how the server authenticated the bot.
	BotAuthenticatedAs identity.Identity `json:"bot_authenticated_as"`
}

// TaskRealm defines the task's security realm.
//
// It is put into LUCI_CONTEXT["realm"].
type TaskRealm struct {
	// Name is the name of the realm.
	Name string `json:"name,omitempty"`
}

// TaskResultDB is parameters of the ResultDB invocation for the task.
//
// It is put into LUCI_CONTEXT["resultdb"].
type TaskResultDB struct {
	// Hostname is the hostname of ResultDB service to use.
	Hostname string `json:"hostname"`
	// CurrentInvocation is the ResultDB invocation to use.
	CurrentInvocation struct {
		// Name is the invocation name.
		Name string `json:"name"`
		// UpdateToken is the invocation's update token.
		UpdateToken string `json:"update_token"`
	} `json:"current_invocation"`
}

// TaskCache describes one named cache requested by a task.
type TaskCache struct {
	// Name is a logical cache name.
	Name string `json:"name"`
	// Path is where to mount it relative to the task root directory.
	Path string `json:"path"`
	// Hint is cache size hint (as a decimal string) or "-1" if unknown.
	Hint string `json:"hint"`
}

// TaskServiceAccount describe what service account a task can use.
type TaskServiceAccount struct {
	// ServiceAccount is 'none', 'bot' or an email.
	//
	// Bot interprets 'none' and 'bot' locally. When it sees something else, it
	// uses /bot/oauth_token or /bot/id_token API endpoints to grab tokens through
	// the server.
	ServiceAccount string `json:"service_account"`
}

// Claim implements the handler that claims pending tasks.
//
// This transactionally and idempotently assigns the task to the calling bot or
// instructs the bot to skip the task if it is no longer pending. On success it
// returns detailed description of the task to let the bot know what it should
// be executing.
//
// Called by bots after they get a lease from the RBE.
func (srv *BotAPIServer) Claim(ctx context.Context, body *ClaimRequest, r *botsrv.Request) (botsrv.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "not implemented yet")
}
