// Copyright 2022 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.1
// source: go.chromium.org/luci/swarming/proto/api_v2/swarming.proto

package apipb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Bots_GetBot_FullMethodName           = "/swarming.v2.Bots/GetBot"
	Bots_DeleteBot_FullMethodName        = "/swarming.v2.Bots/DeleteBot"
	Bots_ListBotEvents_FullMethodName    = "/swarming.v2.Bots/ListBotEvents"
	Bots_TerminateBot_FullMethodName     = "/swarming.v2.Bots/TerminateBot"
	Bots_ListBotTasks_FullMethodName     = "/swarming.v2.Bots/ListBotTasks"
	Bots_ListBots_FullMethodName         = "/swarming.v2.Bots/ListBots"
	Bots_CountBots_FullMethodName        = "/swarming.v2.Bots/CountBots"
	Bots_GetBotDimensions_FullMethodName = "/swarming.v2.Bots/GetBotDimensions"
)

// BotsClient is the client API for Bots service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BotsClient interface {
	// GetBot returns information on a single bot
	GetBot(ctx context.Context, in *BotRequest, opts ...grpc.CallOption) (*BotInfo, error)
	// DeleteBot makes Swarming forget about a single bot.
	//
	// This includes the event history, task history and current state (dimensions,
	// cache state, etc). Once deleted, Swarming will not send tasks to this bot.
	// A still running bot will fininsh executing its task and then not have any
	// further tasks queued on it.
	//
	// For non-GCE-Provider bots, this does not remove any data on the bot
	// machine itself, and if the bot is still running on that machine, it will
	// likely show up again in swarming shortly after calling this API.
	//
	// If this bot is managed with GCE Provider, the underlying VM will be recycled
	// and all data on that VM will be lost.
	//
	// If you wish to shut the bot down, call TerminateBot.
	DeleteBot(ctx context.Context, in *BotRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// ListBotEvents returns a section of the Events (limited in quantity, time range)
	// related to a single Bot.
	//
	// The bot in question must still be 'known' to Swarming.
	ListBotEvents(ctx context.Context, in *BotEventsRequest, opts ...grpc.CallOption) (*BotEventsResponse, error)
	// TerminateBot asks a bot to terminate itself gracefully.
	// The bot will stay in the DB, use 'delete' to remove it from the DB
	// afterward. This request returns a pseudo-taskid that can be waited for to
	// wait for the bot to turn down.
	// This command is particularly useful when a privileged user needs to safely
	// debug a machine specific issue. The user can trigger a terminate for one of
	// the bot exhibiting the issue, wait for the pseudo-task to run then access
	// the machine with the guarantee that the bot is not running anymore.
	TerminateBot(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error)
	// ListBotTasks returns a section of the Task history (limited in quantity, time
	// range) in the context of a single bot.
	//
	// The bot in question must still be 'known' to Swarming.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING', which
	// will always result in empty response, since pending tasks are not
	// associated with bots. To get all tasks regardless of state, set
	// 'state' to 'QUERY_ALL'.
	ListBotTasks(ctx context.Context, in *BotTasksRequest, opts ...grpc.CallOption) (*TaskListResponse, error)
	// ListBots returns the state of a filtered (dimensions, state) list of known bots.
	ListBots(ctx context.Context, in *BotsRequest, opts ...grpc.CallOption) (*BotInfoListResponse, error)
	// CountBots returns the number of bots which match given set of filters.
	CountBots(ctx context.Context, in *BotsCountRequest, opts ...grpc.CallOption) (*BotsCount, error)
	// GetBotDimensions returns a list of known dimensions/values for bots currently
	// connected to a given pool.
	GetBotDimensions(ctx context.Context, in *BotsDimensionsRequest, opts ...grpc.CallOption) (*BotsDimensions, error)
}

type botsClient struct {
	cc grpc.ClientConnInterface
}

func NewBotsClient(cc grpc.ClientConnInterface) BotsClient {
	return &botsClient{cc}
}

func (c *botsClient) GetBot(ctx context.Context, in *BotRequest, opts ...grpc.CallOption) (*BotInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotInfo)
	err := c.cc.Invoke(ctx, Bots_GetBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) DeleteBot(ctx context.Context, in *BotRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, Bots_DeleteBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) ListBotEvents(ctx context.Context, in *BotEventsRequest, opts ...grpc.CallOption) (*BotEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotEventsResponse)
	err := c.cc.Invoke(ctx, Bots_ListBotEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) TerminateBot(ctx context.Context, in *TerminateRequest, opts ...grpc.CallOption) (*TerminateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateResponse)
	err := c.cc.Invoke(ctx, Bots_TerminateBot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) ListBotTasks(ctx context.Context, in *BotTasksRequest, opts ...grpc.CallOption) (*TaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskListResponse)
	err := c.cc.Invoke(ctx, Bots_ListBotTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) ListBots(ctx context.Context, in *BotsRequest, opts ...grpc.CallOption) (*BotInfoListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotInfoListResponse)
	err := c.cc.Invoke(ctx, Bots_ListBots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) CountBots(ctx context.Context, in *BotsCountRequest, opts ...grpc.CallOption) (*BotsCount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotsCount)
	err := c.cc.Invoke(ctx, Bots_CountBots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *botsClient) GetBotDimensions(ctx context.Context, in *BotsDimensionsRequest, opts ...grpc.CallOption) (*BotsDimensions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BotsDimensions)
	err := c.cc.Invoke(ctx, Bots_GetBotDimensions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BotsServer is the server API for Bots service.
// All implementations must embed UnimplementedBotsServer
// for forward compatibility.
type BotsServer interface {
	// GetBot returns information on a single bot
	GetBot(context.Context, *BotRequest) (*BotInfo, error)
	// DeleteBot makes Swarming forget about a single bot.
	//
	// This includes the event history, task history and current state (dimensions,
	// cache state, etc). Once deleted, Swarming will not send tasks to this bot.
	// A still running bot will fininsh executing its task and then not have any
	// further tasks queued on it.
	//
	// For non-GCE-Provider bots, this does not remove any data on the bot
	// machine itself, and if the bot is still running on that machine, it will
	// likely show up again in swarming shortly after calling this API.
	//
	// If this bot is managed with GCE Provider, the underlying VM will be recycled
	// and all data on that VM will be lost.
	//
	// If you wish to shut the bot down, call TerminateBot.
	DeleteBot(context.Context, *BotRequest) (*DeleteResponse, error)
	// ListBotEvents returns a section of the Events (limited in quantity, time range)
	// related to a single Bot.
	//
	// The bot in question must still be 'known' to Swarming.
	ListBotEvents(context.Context, *BotEventsRequest) (*BotEventsResponse, error)
	// TerminateBot asks a bot to terminate itself gracefully.
	// The bot will stay in the DB, use 'delete' to remove it from the DB
	// afterward. This request returns a pseudo-taskid that can be waited for to
	// wait for the bot to turn down.
	// This command is particularly useful when a privileged user needs to safely
	// debug a machine specific issue. The user can trigger a terminate for one of
	// the bot exhibiting the issue, wait for the pseudo-task to run then access
	// the machine with the guarantee that the bot is not running anymore.
	TerminateBot(context.Context, *TerminateRequest) (*TerminateResponse, error)
	// ListBotTasks returns a section of the Task history (limited in quantity, time
	// range) in the context of a single bot.
	//
	// The bot in question must still be 'known' to Swarming.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING', which
	// will always result in empty response, since pending tasks are not
	// associated with bots. To get all tasks regardless of state, set
	// 'state' to 'QUERY_ALL'.
	ListBotTasks(context.Context, *BotTasksRequest) (*TaskListResponse, error)
	// ListBots returns the state of a filtered (dimensions, state) list of known bots.
	ListBots(context.Context, *BotsRequest) (*BotInfoListResponse, error)
	// CountBots returns the number of bots which match given set of filters.
	CountBots(context.Context, *BotsCountRequest) (*BotsCount, error)
	// GetBotDimensions returns a list of known dimensions/values for bots currently
	// connected to a given pool.
	GetBotDimensions(context.Context, *BotsDimensionsRequest) (*BotsDimensions, error)
	mustEmbedUnimplementedBotsServer()
}

// UnimplementedBotsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBotsServer struct{}

func (UnimplementedBotsServer) GetBot(context.Context, *BotRequest) (*BotInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBot not implemented")
}
func (UnimplementedBotsServer) DeleteBot(context.Context, *BotRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBot not implemented")
}
func (UnimplementedBotsServer) ListBotEvents(context.Context, *BotEventsRequest) (*BotEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBotEvents not implemented")
}
func (UnimplementedBotsServer) TerminateBot(context.Context, *TerminateRequest) (*TerminateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateBot not implemented")
}
func (UnimplementedBotsServer) ListBotTasks(context.Context, *BotTasksRequest) (*TaskListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBotTasks not implemented")
}
func (UnimplementedBotsServer) ListBots(context.Context, *BotsRequest) (*BotInfoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBots not implemented")
}
func (UnimplementedBotsServer) CountBots(context.Context, *BotsCountRequest) (*BotsCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountBots not implemented")
}
func (UnimplementedBotsServer) GetBotDimensions(context.Context, *BotsDimensionsRequest) (*BotsDimensions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBotDimensions not implemented")
}
func (UnimplementedBotsServer) mustEmbedUnimplementedBotsServer() {}
func (UnimplementedBotsServer) testEmbeddedByValue()              {}

// UnsafeBotsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BotsServer will
// result in compilation errors.
type UnsafeBotsServer interface {
	mustEmbedUnimplementedBotsServer()
}

func RegisterBotsServer(s grpc.ServiceRegistrar, srv BotsServer) {
	// If the following call pancis, it indicates UnimplementedBotsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Bots_ServiceDesc, srv)
}

func _Bots_GetBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).GetBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_GetBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).GetBot(ctx, req.(*BotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_DeleteBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).DeleteBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_DeleteBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).DeleteBot(ctx, req.(*BotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_ListBotEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).ListBotEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_ListBotEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).ListBotEvents(ctx, req.(*BotEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_TerminateBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).TerminateBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_TerminateBot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).TerminateBot(ctx, req.(*TerminateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_ListBotTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).ListBotTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_ListBotTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).ListBotTasks(ctx, req.(*BotTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_ListBots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).ListBots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_ListBots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).ListBots(ctx, req.(*BotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_CountBots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotsCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).CountBots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_CountBots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).CountBots(ctx, req.(*BotsCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bots_GetBotDimensions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotsDimensionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotsServer).GetBotDimensions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Bots_GetBotDimensions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotsServer).GetBotDimensions(ctx, req.(*BotsDimensionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Bots_ServiceDesc is the grpc.ServiceDesc for Bots service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Bots_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "swarming.v2.Bots",
	HandlerType: (*BotsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBot",
			Handler:    _Bots_GetBot_Handler,
		},
		{
			MethodName: "DeleteBot",
			Handler:    _Bots_DeleteBot_Handler,
		},
		{
			MethodName: "ListBotEvents",
			Handler:    _Bots_ListBotEvents_Handler,
		},
		{
			MethodName: "TerminateBot",
			Handler:    _Bots_TerminateBot_Handler,
		},
		{
			MethodName: "ListBotTasks",
			Handler:    _Bots_ListBotTasks_Handler,
		},
		{
			MethodName: "ListBots",
			Handler:    _Bots_ListBots_Handler,
		},
		{
			MethodName: "CountBots",
			Handler:    _Bots_CountBots_Handler,
		},
		{
			MethodName: "GetBotDimensions",
			Handler:    _Bots_GetBotDimensions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/swarming/proto/api_v2/swarming.proto",
}

const (
	Tasks_GetResult_FullMethodName        = "/swarming.v2.Tasks/GetResult"
	Tasks_BatchGetResult_FullMethodName   = "/swarming.v2.Tasks/BatchGetResult"
	Tasks_GetRequest_FullMethodName       = "/swarming.v2.Tasks/GetRequest"
	Tasks_CancelTask_FullMethodName       = "/swarming.v2.Tasks/CancelTask"
	Tasks_GetStdout_FullMethodName        = "/swarming.v2.Tasks/GetStdout"
	Tasks_NewTask_FullMethodName          = "/swarming.v2.Tasks/NewTask"
	Tasks_ListTasks_FullMethodName        = "/swarming.v2.Tasks/ListTasks"
	Tasks_ListTaskStates_FullMethodName   = "/swarming.v2.Tasks/ListTaskStates"
	Tasks_ListTaskRequests_FullMethodName = "/swarming.v2.Tasks/ListTaskRequests"
	Tasks_CancelTasks_FullMethodName      = "/swarming.v2.Tasks/CancelTasks"
	Tasks_CountTasks_FullMethodName       = "/swarming.v2.Tasks/CountTasks"
)

// TasksClient is the client API for Tasks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TasksClient interface {
	// GetResult reports the result of the task corresponding to a task ID.
	// It can be a 'run' ID specifying a specific retry or a 'summary' ID hidding
	// the fact that a task may have been retried transparently, when a bot reports
	// BOT_DIED.
	// A summary ID ends with '0', a run ID ends with '1' or '2'.
	//
	// TODO(vadimsh): Require the summary ID ending with '0'.
	GetResult(ctx context.Context, in *TaskIdWithPerfRequest, opts ...grpc.CallOption) (*TaskResultResponse, error)
	// BatchGetResult returns results of many tasks at once.
	BatchGetResult(ctx context.Context, in *BatchGetResultRequest, opts ...grpc.CallOption) (*BatchGetResultResponse, error)
	// GetRequest returns the task request corresponding to a task ID.
	GetRequest(ctx context.Context, in *TaskIdRequest, opts ...grpc.CallOption) (*TaskRequestResponse, error)
	// CancelTask cancels a task. If a bot was running the task, the bot will forcibly cancel the task.
	CancelTask(ctx context.Context, in *TaskCancelRequest, opts ...grpc.CallOption) (*CancelResponse, error)
	// GetStdout returns the output of the task corresponding to a task ID.
	GetStdout(ctx context.Context, in *TaskIdWithOffsetRequest, opts ...grpc.CallOption) (*TaskOutputResponse, error)
	// NewTask creates a new task.
	// The task will be enqueued in the tasks list and will be executed at the
	// earliest opportunity by a bot that has at least the dimensions as described
	// in the task request.
	NewTask(ctx context.Context, in *NewTaskRequest, opts ...grpc.CallOption) (*TaskRequestMetadataResponse, error)
	// ListTasks returns full task results based on the filters.
	// This endpoint is significantly slower than 'count'. Use 'count' when
	// possible. If you just want the state of tasks, use 'get_states'.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	ListTasks(ctx context.Context, in *TasksWithPerfRequest, opts ...grpc.CallOption) (*TaskListResponse, error)
	// ListTaskStates returns task state for a specific set of tasks.
	ListTaskStates(ctx context.Context, in *TaskStatesRequest, opts ...grpc.CallOption) (*TaskStates, error)
	// ListTaskRequests returns task requests based on the filters.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	ListTaskRequests(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*TaskRequestsResponse, error)
	// CancelTasks cancels a subset of pending tasks based on the tags.
	// Cancellation happens asynchronously, so when this call returns,
	// cancellations will not have completed yet.
	CancelTasks(ctx context.Context, in *TasksCancelRequest, opts ...grpc.CallOption) (*TasksCancelResponse, error)
	// CountTasks returns the number of tasks in a given state.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	CountTasks(ctx context.Context, in *TasksCountRequest, opts ...grpc.CallOption) (*TasksCount, error)
}

type tasksClient struct {
	cc grpc.ClientConnInterface
}

func NewTasksClient(cc grpc.ClientConnInterface) TasksClient {
	return &tasksClient{cc}
}

func (c *tasksClient) GetResult(ctx context.Context, in *TaskIdWithPerfRequest, opts ...grpc.CallOption) (*TaskResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResultResponse)
	err := c.cc.Invoke(ctx, Tasks_GetResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) BatchGetResult(ctx context.Context, in *BatchGetResultRequest, opts ...grpc.CallOption) (*BatchGetResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchGetResultResponse)
	err := c.cc.Invoke(ctx, Tasks_BatchGetResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) GetRequest(ctx context.Context, in *TaskIdRequest, opts ...grpc.CallOption) (*TaskRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskRequestResponse)
	err := c.cc.Invoke(ctx, Tasks_GetRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) CancelTask(ctx context.Context, in *TaskCancelRequest, opts ...grpc.CallOption) (*CancelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelResponse)
	err := c.cc.Invoke(ctx, Tasks_CancelTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) GetStdout(ctx context.Context, in *TaskIdWithOffsetRequest, opts ...grpc.CallOption) (*TaskOutputResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskOutputResponse)
	err := c.cc.Invoke(ctx, Tasks_GetStdout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) NewTask(ctx context.Context, in *NewTaskRequest, opts ...grpc.CallOption) (*TaskRequestMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskRequestMetadataResponse)
	err := c.cc.Invoke(ctx, Tasks_NewTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) ListTasks(ctx context.Context, in *TasksWithPerfRequest, opts ...grpc.CallOption) (*TaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskListResponse)
	err := c.cc.Invoke(ctx, Tasks_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) ListTaskStates(ctx context.Context, in *TaskStatesRequest, opts ...grpc.CallOption) (*TaskStates, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskStates)
	err := c.cc.Invoke(ctx, Tasks_ListTaskStates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) ListTaskRequests(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*TaskRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskRequestsResponse)
	err := c.cc.Invoke(ctx, Tasks_ListTaskRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) CancelTasks(ctx context.Context, in *TasksCancelRequest, opts ...grpc.CallOption) (*TasksCancelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TasksCancelResponse)
	err := c.cc.Invoke(ctx, Tasks_CancelTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tasksClient) CountTasks(ctx context.Context, in *TasksCountRequest, opts ...grpc.CallOption) (*TasksCount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TasksCount)
	err := c.cc.Invoke(ctx, Tasks_CountTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TasksServer is the server API for Tasks service.
// All implementations must embed UnimplementedTasksServer
// for forward compatibility.
type TasksServer interface {
	// GetResult reports the result of the task corresponding to a task ID.
	// It can be a 'run' ID specifying a specific retry or a 'summary' ID hidding
	// the fact that a task may have been retried transparently, when a bot reports
	// BOT_DIED.
	// A summary ID ends with '0', a run ID ends with '1' or '2'.
	//
	// TODO(vadimsh): Require the summary ID ending with '0'.
	GetResult(context.Context, *TaskIdWithPerfRequest) (*TaskResultResponse, error)
	// BatchGetResult returns results of many tasks at once.
	BatchGetResult(context.Context, *BatchGetResultRequest) (*BatchGetResultResponse, error)
	// GetRequest returns the task request corresponding to a task ID.
	GetRequest(context.Context, *TaskIdRequest) (*TaskRequestResponse, error)
	// CancelTask cancels a task. If a bot was running the task, the bot will forcibly cancel the task.
	CancelTask(context.Context, *TaskCancelRequest) (*CancelResponse, error)
	// GetStdout returns the output of the task corresponding to a task ID.
	GetStdout(context.Context, *TaskIdWithOffsetRequest) (*TaskOutputResponse, error)
	// NewTask creates a new task.
	// The task will be enqueued in the tasks list and will be executed at the
	// earliest opportunity by a bot that has at least the dimensions as described
	// in the task request.
	NewTask(context.Context, *NewTaskRequest) (*TaskRequestMetadataResponse, error)
	// ListTasks returns full task results based on the filters.
	// This endpoint is significantly slower than 'count'. Use 'count' when
	// possible. If you just want the state of tasks, use 'get_states'.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	ListTasks(context.Context, *TasksWithPerfRequest) (*TaskListResponse, error)
	// ListTaskStates returns task state for a specific set of tasks.
	ListTaskStates(context.Context, *TaskStatesRequest) (*TaskStates, error)
	// ListTaskRequests returns task requests based on the filters.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	ListTaskRequests(context.Context, *TasksRequest) (*TaskRequestsResponse, error)
	// CancelTasks cancels a subset of pending tasks based on the tags.
	// Cancellation happens asynchronously, so when this call returns,
	// cancellations will not have completed yet.
	CancelTasks(context.Context, *TasksCancelRequest) (*TasksCancelResponse, error)
	// CountTasks returns the number of tasks in a given state.
	//
	// Note: by default the `state` parameter has value 'QUERY_PENDING'. To get
	// all tasks regardless of state, set 'state' to 'QUERY_ALL'.
	CountTasks(context.Context, *TasksCountRequest) (*TasksCount, error)
	mustEmbedUnimplementedTasksServer()
}

// UnimplementedTasksServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTasksServer struct{}

func (UnimplementedTasksServer) GetResult(context.Context, *TaskIdWithPerfRequest) (*TaskResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResult not implemented")
}
func (UnimplementedTasksServer) BatchGetResult(context.Context, *BatchGetResultRequest) (*BatchGetResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetResult not implemented")
}
func (UnimplementedTasksServer) GetRequest(context.Context, *TaskIdRequest) (*TaskRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRequest not implemented")
}
func (UnimplementedTasksServer) CancelTask(context.Context, *TaskCancelRequest) (*CancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedTasksServer) GetStdout(context.Context, *TaskIdWithOffsetRequest) (*TaskOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStdout not implemented")
}
func (UnimplementedTasksServer) NewTask(context.Context, *NewTaskRequest) (*TaskRequestMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewTask not implemented")
}
func (UnimplementedTasksServer) ListTasks(context.Context, *TasksWithPerfRequest) (*TaskListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedTasksServer) ListTaskStates(context.Context, *TaskStatesRequest) (*TaskStates, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskStates not implemented")
}
func (UnimplementedTasksServer) ListTaskRequests(context.Context, *TasksRequest) (*TaskRequestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskRequests not implemented")
}
func (UnimplementedTasksServer) CancelTasks(context.Context, *TasksCancelRequest) (*TasksCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTasks not implemented")
}
func (UnimplementedTasksServer) CountTasks(context.Context, *TasksCountRequest) (*TasksCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountTasks not implemented")
}
func (UnimplementedTasksServer) mustEmbedUnimplementedTasksServer() {}
func (UnimplementedTasksServer) testEmbeddedByValue()               {}

// UnsafeTasksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TasksServer will
// result in compilation errors.
type UnsafeTasksServer interface {
	mustEmbedUnimplementedTasksServer()
}

func RegisterTasksServer(s grpc.ServiceRegistrar, srv TasksServer) {
	// If the following call pancis, it indicates UnimplementedTasksServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Tasks_ServiceDesc, srv)
}

func _Tasks_GetResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskIdWithPerfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).GetResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_GetResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).GetResult(ctx, req.(*TaskIdWithPerfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_BatchGetResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).BatchGetResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_BatchGetResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).BatchGetResult(ctx, req.(*BatchGetResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_GetRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).GetRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_GetRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).GetRequest(ctx, req.(*TaskIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_CancelTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).CancelTask(ctx, req.(*TaskCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_GetStdout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskIdWithOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).GetStdout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_GetStdout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).GetStdout(ctx, req.(*TaskIdWithOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_NewTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).NewTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_NewTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).NewTask(ctx, req.(*NewTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksWithPerfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).ListTasks(ctx, req.(*TasksWithPerfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_ListTaskStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).ListTaskStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_ListTaskStates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).ListTaskStates(ctx, req.(*TaskStatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_ListTaskRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).ListTaskRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_ListTaskRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).ListTaskRequests(ctx, req.(*TasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_CancelTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).CancelTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_CancelTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).CancelTasks(ctx, req.(*TasksCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tasks_CountTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TasksServer).CountTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tasks_CountTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TasksServer).CountTasks(ctx, req.(*TasksCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Tasks_ServiceDesc is the grpc.ServiceDesc for Tasks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tasks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "swarming.v2.Tasks",
	HandlerType: (*TasksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResult",
			Handler:    _Tasks_GetResult_Handler,
		},
		{
			MethodName: "BatchGetResult",
			Handler:    _Tasks_BatchGetResult_Handler,
		},
		{
			MethodName: "GetRequest",
			Handler:    _Tasks_GetRequest_Handler,
		},
		{
			MethodName: "CancelTask",
			Handler:    _Tasks_CancelTask_Handler,
		},
		{
			MethodName: "GetStdout",
			Handler:    _Tasks_GetStdout_Handler,
		},
		{
			MethodName: "NewTask",
			Handler:    _Tasks_NewTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _Tasks_ListTasks_Handler,
		},
		{
			MethodName: "ListTaskStates",
			Handler:    _Tasks_ListTaskStates_Handler,
		},
		{
			MethodName: "ListTaskRequests",
			Handler:    _Tasks_ListTaskRequests_Handler,
		},
		{
			MethodName: "CancelTasks",
			Handler:    _Tasks_CancelTasks_Handler,
		},
		{
			MethodName: "CountTasks",
			Handler:    _Tasks_CountTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/swarming/proto/api_v2/swarming.proto",
}

const (
	Swarming_GetDetails_FullMethodName     = "/swarming.v2.Swarming/GetDetails"
	Swarming_GetToken_FullMethodName       = "/swarming.v2.Swarming/GetToken"
	Swarming_GetPermissions_FullMethodName = "/swarming.v2.Swarming/GetPermissions"
)

// SwarmingClient is the client API for Swarming service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SwarmingClient interface {
	// GetDetails returns public information about the Swarming instance.
	GetDetails(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServerDetails, error)
	// GetToken returns a token to bootstrap a new bot.
	GetToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BootstrapToken, error)
	// GetPermissions returns the caller's permissions.
	GetPermissions(ctx context.Context, in *PermissionsRequest, opts ...grpc.CallOption) (*ClientPermissions, error)
}

type swarmingClient struct {
	cc grpc.ClientConnInterface
}

func NewSwarmingClient(cc grpc.ClientConnInterface) SwarmingClient {
	return &swarmingClient{cc}
}

func (c *swarmingClient) GetDetails(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServerDetails, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerDetails)
	err := c.cc.Invoke(ctx, Swarming_GetDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swarmingClient) GetToken(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BootstrapToken, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapToken)
	err := c.cc.Invoke(ctx, Swarming_GetToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swarmingClient) GetPermissions(ctx context.Context, in *PermissionsRequest, opts ...grpc.CallOption) (*ClientPermissions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClientPermissions)
	err := c.cc.Invoke(ctx, Swarming_GetPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwarmingServer is the server API for Swarming service.
// All implementations must embed UnimplementedSwarmingServer
// for forward compatibility.
type SwarmingServer interface {
	// GetDetails returns public information about the Swarming instance.
	GetDetails(context.Context, *emptypb.Empty) (*ServerDetails, error)
	// GetToken returns a token to bootstrap a new bot.
	GetToken(context.Context, *emptypb.Empty) (*BootstrapToken, error)
	// GetPermissions returns the caller's permissions.
	GetPermissions(context.Context, *PermissionsRequest) (*ClientPermissions, error)
	mustEmbedUnimplementedSwarmingServer()
}

// UnimplementedSwarmingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSwarmingServer struct{}

func (UnimplementedSwarmingServer) GetDetails(context.Context, *emptypb.Empty) (*ServerDetails, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDetails not implemented")
}
func (UnimplementedSwarmingServer) GetToken(context.Context, *emptypb.Empty) (*BootstrapToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToken not implemented")
}
func (UnimplementedSwarmingServer) GetPermissions(context.Context, *PermissionsRequest) (*ClientPermissions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissions not implemented")
}
func (UnimplementedSwarmingServer) mustEmbedUnimplementedSwarmingServer() {}
func (UnimplementedSwarmingServer) testEmbeddedByValue()                  {}

// UnsafeSwarmingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SwarmingServer will
// result in compilation errors.
type UnsafeSwarmingServer interface {
	mustEmbedUnimplementedSwarmingServer()
}

func RegisterSwarmingServer(s grpc.ServiceRegistrar, srv SwarmingServer) {
	// If the following call pancis, it indicates UnimplementedSwarmingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Swarming_ServiceDesc, srv)
}

func _Swarming_GetDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwarmingServer).GetDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Swarming_GetDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwarmingServer).GetDetails(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swarming_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwarmingServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Swarming_GetToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwarmingServer).GetToken(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swarming_GetPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwarmingServer).GetPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Swarming_GetPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwarmingServer).GetPermissions(ctx, req.(*PermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Swarming_ServiceDesc is the grpc.ServiceDesc for Swarming service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Swarming_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "swarming.v2.Swarming",
	HandlerType: (*SwarmingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDetails",
			Handler:    _Swarming_GetDetails_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _Swarming_GetToken_Handler,
		},
		{
			MethodName: "GetPermissions",
			Handler:    _Swarming_GetPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/swarming/proto/api_v2/swarming.proto",
}
