// Copyright 2025 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * This file is mostly generated by Gemini.
 *
 * The intention is that this will be used to generate fake data for a TurboCI graph while the
 * corresponding Turbo CI QueryNodes API meant to provide this data is still in development. Once
 * the API is available and integrated, we can remove this file.
 *
 * TODO - Remove the fakerjs dependency added in crrev.com/c/7047404 when this file is deleted.
 */

import { faker } from '@faker-js/faker';

import { Duration } from '../proto/google/protobuf/duration.pb';
import {
  BuildCheckOptions,
  Product,
} from '../proto/turboci/data/build/v1/build_check_options.pb';
import { BuildCheckResult } from '../proto/turboci/data/build/v1/build_check_results.pb';
import {
  AccountInfo,
  ChangeMessageInfo,
  FileInfo_Status,
  GerritChangeInfo,
  GerritChangeInfo_Status,
  LabelInfo,
  RevisionInfo,
  RevisionInfo_Kind,
} from '../proto/turboci/data/gerrit/v1/gerrit_change_info.pb';
import {
  GobSourceCheckOptions,
  GobSourceCheckOptions_GerritChange,
  GobSourceCheckOptions_PinnedRepoMounts,
  GobSourceCheckOptions_PinnedRepoMounts_GitCommit,
} from '../proto/turboci/data/gerrit/v1/gob_source_check_options.pb';
import { GobSourceCheckResults } from '../proto/turboci/data/gerrit/v1/gob_source_check_results.pb';
import {
  Identifier,
  WorkPlan,
  Check as CheckId,
  Stage as StageId,
  CheckOption as CheckOptionId,
  CheckResult as CheckResultId,
  CheckResultDatum as CheckResultDatumId,
} from '../proto/turboci/graph/ids/v1/identifier.pb';
import { Actor } from '../proto/turboci/graph/orchestrator/v1/actor.pb';
import {
  Check,
  Check_OptionRef,
  Check_Result,
} from '../proto/turboci/graph/orchestrator/v1/check.pb';
import { CheckDelta } from '../proto/turboci/graph/orchestrator/v1/check_delta.pb';
import { CheckEditView } from '../proto/turboci/graph/orchestrator/v1/check_edit_view.pb';
import { CheckKind } from '../proto/turboci/graph/orchestrator/v1/check_kind.pb';
import { CheckResultView } from '../proto/turboci/graph/orchestrator/v1/check_result_view.pb';
import { CheckState } from '../proto/turboci/graph/orchestrator/v1/check_state.pb';
import { CheckView } from '../proto/turboci/graph/orchestrator/v1/check_view.pb';
import { Datum } from '../proto/turboci/graph/orchestrator/v1/datum.pb';
import {
  Dependencies,
  Dependencies_Group,
  Dependencies_ResolutionEvent,
} from '../proto/turboci/graph/orchestrator/v1/dependencies.pb';
import { Edge } from '../proto/turboci/graph/orchestrator/v1/edge.pb';
import { Edit } from '../proto/turboci/graph/orchestrator/v1/edit.pb';
import { GraphView } from '../proto/turboci/graph/orchestrator/v1/graph_view.pb';
import { Revision } from '../proto/turboci/graph/orchestrator/v1/revision.pb';
import {
  Stage,
  Stage_Attempt,
  Stage_ExecutionPolicyState,
  Stage_StateHistoryEntry,
} from '../proto/turboci/graph/orchestrator/v1/stage.pb';
import { StageAttemptState } from '../proto/turboci/graph/orchestrator/v1/stage_attempt_state.pb';
import { StageDelta } from '../proto/turboci/graph/orchestrator/v1/stage_delta.pb';
import { StageEditView } from '../proto/turboci/graph/orchestrator/v1/stage_edit_view.pb';
import {
  StageExecutionPolicy,
  StageExecutionPolicy_StageTimeoutMode,
} from '../proto/turboci/graph/orchestrator/v1/stage_execution_policy.pb';
import { StageState } from '../proto/turboci/graph/orchestrator/v1/stage_state.pb';
import { StageView } from '../proto/turboci/graph/orchestrator/v1/stage_view.pb';
import { Value } from '../proto/turboci/graph/orchestrator/v1/value.pb';

// Type URLs for the data protos
const TYPE_URL_GOB_SOURCE_OPTIONS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckOptions';
const TYPE_URL_GOB_SOURCE_RESULTS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckResults';
const TYPE_URL_BUILD_OPTIONS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckOptions';
const TYPE_URL_BUILD_RESULTS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckResult';
const TYPE_URL_GENERIC_DATA = 'type.googleapis.com/turboci.demo.GenericData';

// Fake data pools used by Faker.js
const FAKE_GERRIT_HOSTS = [
  'chromium',
  'android',
  'googleplex-android',
  'partner-android',
];
const FAKE_GERRIT_PROJECTS = [
  'device/google/cuttlefish',
  'platform/frameworks/support',
  'platform/frameworks/base',
  'kernel/build',
  'platform/vendor/google/camera',
];
const FAKE_GIT_BRANCHES = ['main', 'androidx-main', 'android14-tests-release'];
const FAKE_MOUNT_PATHS = [
  'src',
  'src/third_party/skia',
  'src/v8',
  'frameworks/base',
  'packages/apps/Settings',
  'system/core',
  'manifest',
  'build/make',
];
const FAKE_ANDROID_BRANCHES = [
  'git-main',
  'git_25Q1-release',
  'git_25Q2-release',
  'git_25Q3-release',
  'git_trunk-release',
];
const FAKE_TARGET_NAMES = [
  'stallion-trunk_staging-userdebug',
  'lynx-trunk_staging-userdebug',
  'husky-trunk_staging-userdebug',
  'komodo-trunk_staging-userdebug',
  'cheetah-trunk_staging-userdebug',
  'cheetah-next-userdebug',
  'yogi-cd1a-userdebug',
  'oriole-trunk_staging-userdebug',
  'rango-trunk_staging-userdebug',
  'tokay-trunk_staging-userdebug',
  'akita-trunk_staging-userdebug',
  'comet-trunk_staging-userdebug',
  'tegu-trunk_staging-userdebug',
];
const FAKE_TEST_NAMES = [
  'v2/pixel-health-guard/device-boot-test',
  'v2/pts-presubmit/device-presubmit-wifi',
  'v2/pixel-camera-automation/pts-presubmit-with-scene-sta5',
  'v2/pixel-camera-automation/cts-presubmit-with-scene-sta5',
  'v2/pc3a/camera_3a/device_unit_tests',
  'v2/android-camera/pact-cfa-pre-mh-tests',
  'v2/android-lyric-code-silo-access/isp-test-health/zumapro/presubmit_eligible_unit_tests',
  'v2/pixel-camera-flextape-team/leakr-scan/lyric',
  'v2/android-test-harness-team/suite/host_unit_tests',
  'v2/sysui/systemui/robo_rng_keyguard_tests',
  'v2/android-crystalball-eng/health/microbench/uibench/uibench-jank-presubmit',
  'v2/faceauth-eng/husky_presubmit_camera',
  'v2/android-multiuser/preinstall-allowlist-test',
  'v2/android-gki/test_mapping_kernel_presubmit',
];

export enum WorkflowType {
  ANDROID = 'ANDROID',
  BROWSER = 'BROWSER',
  BROWSER_FUTURE = 'BROWSER_FUTURE',
}

/**
 * Configuration for the FakeGraphGenerator.
 */
export interface GraphGenerationConfig {
  workPlanIdStr: string;
  workflowType: WorkflowType;
}

interface CheckData {
  optionsRef: Check_OptionRef;
  optionDatum: Datum;
  resultRef?: Check_Result;
  resultView?: CheckResultView;
}

export class FakeGraphGenerator {
  private workPlanId: WorkPlan;
  private sourcePlanningStageId: StageId;
  private buildPlanningStageId: StageId;
  private testPlanningStageId: StageId;

  // Simulated time to ensure Revisions allow logical ordering (createdAt < finalizedAt)
  private currentSimulatedTimeMs = Date.UTC(2024, 0, 1, 12, 0, 0);

  // Accumulators for generated views where the key is the identifier.id
  private checkViews: Record<string, CheckView> = {};
  private stageViews: Record<string, StageView> = {};

  // Accumulators for planning stage assignments
  private sourceCheckIds: CheckId[] = [];
  private buildCheckIds: CheckId[] = [];
  private testCheckIds: CheckId[] = [];

  constructor(private config: GraphGenerationConfig) {
    // Initialize faker seed for reproducible graphs based on workplan ID
    let seed = 0;
    for (let i = 0; i < config.workPlanIdStr.length; i++) {
      seed = (seed << 5) - seed + config.workPlanIdStr.charCodeAt(i);
      seed |= 0;
    }
    faker.seed(seed);

    this.workPlanId = { id: config.workPlanIdStr };
    this.sourcePlanningStageId = this.createStageId('S_Planning_Source');
    this.buildPlanningStageId = this.createStageId('S_Planning_Build');
    this.testPlanningStageId = this.createStageId('S_Planning_Test');
  }

  /**
   * Generates the complete GraphView based on the configuration.
   */
  public generate(): GraphView {
    this.resetState();

    switch (this.config.workflowType) {
      case WorkflowType.ANDROID:
        this.generateAndroid();
        break;
      case WorkflowType.BROWSER:
        this.generateBrowser();
        break;
      case WorkflowType.BROWSER_FUTURE:
        this.generateBrowserFuture();
        break;
      default:
        // Fallback to Android
        this.generateAndroid();
    }

    this.finalizeGraph();

    return {
      identifier: this.workPlanId,
      version: this.nextRevision(),
      checks: this.checkViews,
      stages: this.stageViews,
    };
  }

  private resetState() {
    this.checkViews = {};
    this.stageViews = {};
    this.sourceCheckIds = [];
    this.buildCheckIds = [];
    this.testCheckIds = [];
    this.currentSimulatedTimeMs = Date.UTC(2024, 0, 1, 12, 0, 0);
  }

  private finalizeGraph() {
    this.createPlanningStage(this.sourcePlanningStageId, this.sourceCheckIds);
    this.createPlanningStage(this.buildPlanningStageId, this.buildCheckIds);
    this.createPlanningStage(this.testPlanningStageId, this.testCheckIds);
  }

  // ==========================================
  // Specific Workflow Generators
  // ==========================================

  private generateAndroid() {
    // 1. Source
    const sourceId = this.createGobSourcePair();
    this.sourceCheckIds.push(sourceId);

    // 2. Common test_suites build (LKGB & TOT)
    const commonLkgb = this.createBuildPair('test_suites_LKGB', [
      { check: sourceId },
    ]);
    const commonTot = this.createBuildPair('test_suites_TOT', [
      { check: sourceId },
    ]);
    this.buildCheckIds.push(commonLkgb, commonTot);

    // 3. Builds & Tests
    const numBuilds = 10;
    const testsPerBuild = 5;

    for (let i = 0; i < numBuilds; i++) {
      const lkgb = this.createBuildPair(`Build_${i}_LKGB`, [
        { check: sourceId },
      ]);
      const tot = this.createBuildPair(`Build_${i}_TOT`, [{ check: sourceId }]);
      this.buildCheckIds.push(lkgb, tot);

      for (let j = 0; j < testsPerBuild; j++) {
        // Each test node depends on BOTH the LKGB and TOT
        this.testCheckIds.push(
          this.createTestPair(`D${i}_T${j}`, [
            { check: commonLkgb },
            { check: commonTot },
            { check: lkgb },
            { check: tot },
          ]),
        );
      }
    }
  }

  private generateBrowser() {
    const sourceId = this.createGobSourcePair();
    this.sourceCheckIds.push(sourceId);

    this.generateBrowserPlatformSequence('try/linux-rel', sourceId);
  }

  private generateBrowserFuture() {
    const sourceId = this.createGobSourcePair();
    this.sourceCheckIds.push(sourceId);

    const targetSelectionStageId = this.createStage('S_Target_Selection', [
      { check: sourceId },
    ]);

    // Multiple Platforms
    const platforms = ['try/linux-rel', 'try/mac-rel', 'try/win-rel'];
    for (const platform of platforms) {
      this.generateBrowserPlatformSequence(platform, sourceId, {
        stage: targetSelectionStageId,
      });
    }
  }

  private generateBrowserPlatformSequence(
    platformName: string,
    sourceId: CheckId,
    dependency?: Identifier,
  ) {
    const numTests = faker.number.int({ min: 10, max: 15 });
    const startDeps: Identifier[] = [{ check: sourceId }];
    if (dependency) {
      startDeps.push(dependency);
    }

    // Phase 1: Build w/ Patch -> Tests
    const b1 = this.createBuildPair(`${platformName}_Build_Patch`, startDeps);
    this.buildCheckIds.push(b1);
    const t1s: CheckId[] = [];
    for (let i = 0; i < numTests; i++) {
      t1s.push(
        this.createTestPair(`${platformName}_Test_Patch_${i}`, [{ check: b1 }]),
      );
    }
    this.testCheckIds.push(...t1s);

    // Phase 2: Retry Build w/ Patch -> Tests
    const b2Deps = t1s.map((t) => ({ check: t }));
    const b2 = this.createBuildPair(
      `${platformName}_Build_Patch_Retry`,
      b2Deps,
    );
    this.buildCheckIds.push(b2);
    const t2s: CheckId[] = [];
    for (let i = 0; i < numTests; i++) {
      t2s.push(
        this.createTestPair(`${platformName}_Test_Patch_Retry_${i}`, [
          { check: b2 },
        ]),
      );
    }
    this.testCheckIds.push(...t2s);

    // Phase 3: Build w/o Patch -> Tests
    const b3Deps = t2s.map((t) => ({ check: t }));
    const b3 = this.createBuildPair(`${platformName}_Build_NoPatch`, b3Deps);
    this.buildCheckIds.push(b3);
    const t3s: CheckId[] = [];
    for (let i = 0; i < numTests; i++) {
      t3s.push(
        this.createTestPair(`${platformName}_Test_NoPatch_${i}`, [
          { check: b3 },
        ]),
      );
    }
    this.testCheckIds.push(...t3s);
  }

  // ==========================================
  // Procedural Generation Orchestration
  // ==========================================

  private createGobSourcePair(): CheckId {
    const idStr = 'Source_Gob';
    const checkId = this.createCheckId(`C_${idStr}`);
    const stageId = this.createStageId(`S_${idStr}`);
    const realm = `${idStr}-realm`;

    // Generate Data
    const data = this.generateGobSourceCheckData(checkId, realm, stageId, 3);

    // Generate Views (simulating lifecycle)
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_SOURCE,
      realm,
      [], // No dependencies
      stageId,
      data,
    );
    // Source stages always succeed in this simulation
    this.generateStageView(stageId, realm, [], true, [checkId]);

    return checkId;
  }

  private createBuildPair(idStr: string, dependencies: Identifier[]): CheckId {
    const checkId = this.createCheckId(`C_${idStr}`);
    const stageId = this.createStageId(`S_${idStr}`);
    const realm = `${idStr}-realm`;

    // Random success/failure
    const success = faker.datatype.boolean();

    // Generate Data
    const data = this.generateBuildCheckData(checkId, realm, stageId, success);

    // Generate Views
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_BUILD,
      realm,
      dependencies,
      stageId,
      data,
    );
    this.generateStageView(stageId, realm, dependencies, success, [checkId]);
    return checkId;
  }

  private createTestPair(idStr: string, dependencies: Identifier[]): CheckId {
    const checkId = this.createCheckId(`C_${idStr}`);
    const realm = `${idStr}-realm`;

    const success = faker.datatype.boolean();

    // 10% of the time, create 2-4 stages assigned to the same test check
    const numStages = faker.datatype.boolean(0.1)
      ? faker.number.int({ min: 2, max: 4 })
      : 1;
    const stageIds: StageId[] = [];
    for (let i = 0; i < numStages; i++) {
      const stageId = this.createStageId(
        `S_${idStr}` + (numStages > 1 ? `-${i}` : ''),
      );
      stageIds.push(stageId);
      this.generateStageView(stageId, realm, dependencies, success, [checkId]);
    }

    // If we created multiple stages, we still need one to be the actual editor to FINAL state
    // so just pick the first one.
    const finalizingStageId = stageIds[0];

    // Generate Data
    const data = this.generateGenericCheckData(
      checkId,
      realm,
      finalizingStageId,
    );

    // Generate Views
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_TEST,
      realm,
      dependencies,
      finalizingStageId,
      data,
    );

    return checkId;
  }

  private createStage(idStr: string, dependencies: Identifier[]): StageId {
    const stageId = this.createStageId(idStr);
    const realm = `${idStr}-realm`;

    this.generateStageView(stageId, realm, dependencies, true, []);
    return stageId;
  }

  private createPlanningStage(
    stageId: StageId,
    assignedCheckIds: CheckId[],
  ): void {
    if (assignedCheckIds.length === 0) {
      return;
    }
    this.generateStageView(
      stageId,
      'planning_realm',
      [],
      true,
      assignedCheckIds,
      CheckState.CHECK_STATE_PLANNED,
    );
  }

  // ==========================================
  // Core View Generators (Simulated Lifecycle)
  // ==========================================

  private generateCheckView(
    checkId: CheckId,
    kind: CheckKind,
    realm: string,
    dependencies: Identifier[],
    executingStageId: StageId,
    data: CheckData,
  ): void {
    // Determine the specific planning stage based on kind.
    let planningStageId: StageId;
    switch (kind) {
      case CheckKind.CHECK_KIND_SOURCE:
        planningStageId = this.sourcePlanningStageId;
        break;
      case CheckKind.CHECK_KIND_BUILD:
        planningStageId = this.buildPlanningStageId;
        break;
      case CheckKind.CHECK_KIND_TEST:
        planningStageId = this.testPlanningStageId;
        break;
      default:
        // Fallback, should not happen in this fake generator
        planningStageId = this.sourcePlanningStageId;
    }

    const edits: CheckEditView[] = [];
    const actor: Actor = {
      stageAttempt: { stage: executingStageId },
    };
    const planningActor: Actor = {
      stageAttempt: { stage: planningStageId },
    };

    // Timestamps for lifecycle
    const creationRev = this.nextRevision();
    const plannedRev = this.nextRevision();
    const finalRev = this.nextRevision();

    const deps = buildDependencies(dependencies, finalRev);
    const emptyDeps: Dependencies = {
      edges: [],
      resolutionEvents: {},
    };

    // 1. Creation Edit (PLANNING)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        creationRev,
        'Creation',
        {
          check: {
            state: CheckState.CHECK_STATE_PLANNING,
            options: [data.optionsRef.identifier!],
            dependencies: deps,
            result: [],
          },
        },
        this.getOrchestratorActor(),
      ),
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
    });

    // 2. Planned (by planning stage)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        plannedRev,
        'Planned',
        {
          check: {
            state: CheckState.CHECK_STATE_PLANNED,
            options: [data.optionsRef.identifier!],
            dependencies: deps,
            result: [],
          },
        },
        planningActor,
      ),
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
    });

    // 3. Waiting Edit (simulated orchestration steps)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        plannedRev,
        'Waiting for dependencies',
        {
          check: {
            state: CheckState.CHECK_STATE_WAITING,
            result: [],
            options: [],
            dependencies: emptyDeps,
          },
        },
        this.getOrchestratorActor(),
      ),
      optionData: {},
    });

    // Construct finalized result ref based on generated data and time
    const results: Check_Result[] = [];
    const resultsViewData: Record<number, CheckResultView> = {};

    if (data.resultRef && data.resultView) {
      const finalizedResultRef: Check_Result = {
        identifier: data.resultRef.identifier,
        owner: data.resultRef.owner,
        data: data.resultRef.data,
        createdAt: finalRev,
        finalizedAt: finalRev,
      };

      results.push(finalizedResultRef);
      resultsViewData[data.resultView.identifier!.idx!] = data.resultView;

      // 4. Final Edit by executing stage (Results Posted)
      edits.push({
        edit: this.createEdit(
          { check: checkId },
          realm,
          finalRev,
          'Results posted and finalized',
          {
            check: {
              state: CheckState.CHECK_STATE_FINAL,
              options: [],
              dependencies: emptyDeps,
              result: [
                {
                  identifier: finalizedResultRef.identifier,
                  created: true,
                  finalized: true,
                  data: finalizedResultRef.data.map((d) => d.identifier!),
                },
              ],
            },
          },
          actor,
        ),
        optionData: data.resultView.data,
      });
    }

    // Construct Final Check Object (immutable components + final state)
    const check: Check = {
      identifier: checkId,
      kind: kind,
      realm: realm,
      version: finalRev,
      dependencies: deps,
      options: [data.optionsRef],
      results: results,
      state: CheckState.CHECK_STATE_FINAL,
      stateHistory: [],
    };

    if (!checkId.id) throw new Error('Check ID required');
    this.checkViews[checkId.id] = {
      check: check,
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
      edits: edits,
      results: resultsViewData,
    };
  }

  private generateStageView(
    stageId: StageId,
    realm: string,
    dependencies: Identifier[],
    success: boolean,
    assignments: CheckId[],
    assignmentGoalState = CheckState.CHECK_STATE_FINAL,
  ): void {
    const idStr = stageId.id!;
    const edits: StageEditView[] = [];

    // Timestamps
    const createRev = this.nextRevision();
    const attemptRev = this.nextRevision();
    const finalRev = this.nextRevision();

    // 1. Creation Edit (PLANNED)
    edits.push({
      edit: this.createEdit({ stage: stageId }, realm, createRev, 'Creation', {
        stage: { state: StageState.STAGE_STATE_PLANNED, executionPolicies: [] },
      }),
    });

    // 2. Attempting Edit
    edits.push({
      edit: this.createEdit(
        { stage: stageId },
        realm,
        attemptRev,
        'Dispatched to executor',
        {
          stage: {
            state: StageState.STAGE_STATE_ATTEMPTING,
            executionPolicies: [],
          },
        },
      ),
    });

    // Generate attempt data based on final time
    const attempts = this.generateStageAttempt(
      idStr,
      attemptRev,
      finalRev,
      success,
    );

    // 3. Final Edit
    edits.push({
      edit: this.createEdit(
        { stage: stageId },
        realm,
        finalRev,
        'Execution completed',
        {
          stage: { state: StageState.STAGE_STATE_FINAL, executionPolicies: [] },
        },
      ),
    });

    // Construct Final Stage Object
    const stage: Stage = {
      identifier: stageId,
      realm: realm,
      version: finalRev,
      dependencies: buildDependencies(dependencies, finalRev),
      executionPolicy: this.createExecutionPolicyState(),
      state: StageState.STAGE_STATE_FINAL,
      attempts: attempts,
      assignments: assignments.map((assignment) => ({
        target: assignment,
        goalState: assignmentGoalState,
      })),
      args: this.createValueFromObj(TYPE_URL_GENERIC_DATA, {
        args: faker.hacker.phrase(),
      }),
      stateHistory: [
        { state: StageState.STAGE_STATE_PLANNED, version: createRev },
        { state: StageState.STAGE_STATE_ATTEMPTING, version: attemptRev },
        { state: StageState.STAGE_STATE_FINAL, version: finalRev },
      ] as Stage_StateHistoryEntry[],
    };

    this.stageViews[idStr] = {
      stage: stage,
      edits: edits,
    };
  }

  // ==========================================
  // Check Data Generators (Options & Results)
  // ==========================================

  private generateFakeGitCommit(): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
    return {
      host: faker.helpers.arrayElement(FAKE_GERRIT_HOSTS),
      project: faker.helpers.arrayElement(FAKE_GERRIT_PROJECTS),
      id: faker.git.commitSha(),
      ref: `refs/heads/${faker.helpers.arrayElement(FAKE_GIT_BRANCHES)}`,
    };
  }

  private generateFakeAccount(): AccountInfo {
    const email = faker.internet.email();
    return {
      accountId: faker.number.int({ min: 1000, max: 99999 }).toString(),
      name: faker.person.fullName(),
      email: email,
      username: email.split('@')[0],
      secondaryEmails: [],
      tags: [],
    };
  }

  private generateFakeLabels(): { [key: string]: LabelInfo } {
    const labels: { [key: string]: LabelInfo } = {};
    // Code-Review
    labels['Code-Review'] = {
      all: [
        {
          user: this.generateFakeAccount(),
          value: 2,
          date: faker.date.recent().toISOString(),
        },
        {
          user: this.generateFakeAccount(),
          value: 1,
          date: faker.date.recent().toISOString(),
        },
      ],
      values: {
        '-2': 'Do not submit',
        '-1': "I would prefer that you didn't submit this",
        ' 0': 'No score',
        '+1': 'Looks good to me, but someone else must approve',
        '+2': 'Looks good to me, approved',
      },
      defaultValue: 0,
    };
    // Verified
    labels['Verified'] = {
      all: [
        {
          user: this.generateFakeAccount(),
          value: 1,
          date: faker.date.recent().toISOString(),
        },
      ],
      values: {
        '-1': 'Fails',
        ' 0': 'No score',
        '+1': 'Verified',
      },
      defaultValue: 0,
    };
    return labels;
  }

  private generateFakeMessages(
    startPatchset: number,
    endPatchset: number,
  ): ChangeMessageInfo[] {
    const messages: ChangeMessageInfo[] = [];
    let currentPatchset = startPatchset;
    const numMessages = faker.number.int({ min: 3, max: 8 });

    for (let i = 0; i < numMessages; i++) {
      // Simulate patchsets advancing occasionally
      if (
        i > 0 &&
        currentPatchset < endPatchset &&
        faker.datatype.boolean(0.3)
      ) {
        currentPatchset++;
        messages.push({
          id: faker.string.uuid(),
          author: this.generateFakeAccount(),
          date: faker.date.recent().toISOString(),
          message: `Uploaded patch set ${currentPatchset}.`,
          patchset: currentPatchset,
          accountsInMessage: [],
        });
      }

      messages.push({
        id: faker.string.uuid(),
        author: this.generateFakeAccount(),
        date: faker.date.recent().toISOString(),
        message: faker.lorem.sentences(faker.number.int({ min: 1, max: 3 })),
        patchset: currentPatchset,
        accountsInMessage: [],
      });
    }
    return messages;
  }

  private generateFakeRevisions(endPatchset: number): {
    [key: string]: RevisionInfo;
  } {
    const revisions: { [key: string]: RevisionInfo } = {};
    // Just generate the latest one for now to save space, maybe one previous.
    const startPatchset = Math.max(1, endPatchset - 1);

    for (let i = startPatchset; i <= endPatchset; i++) {
      const commitSha = faker.git.commitSha();
      revisions[commitSha] = {
        kind: RevisionInfo_Kind.KIND_REWORK,
        patchset: i,
        created: faker.date.past().toISOString(),
        uploader: this.generateFakeAccount(),
        ref: `refs/changes/12/123412/${i}`,
        commit: {
          commitId: commitSha,
          subject: faker.git.commitMessage(),
          message: faker.lorem.paragraph(),
          author: this.generateFakeAccount(),
          committer: this.generateFakeAccount(),
          parents: [{ commitId: faker.git.commitSha(), parents: [] }],
        },
        files: {
          [faker.system.filePath()]: {
            status: FileInfo_Status.STATUS_MODIFIED,
            linesInserted: faker.number.int({ min: 1, max: 100 }),
            linesDeleted: faker.number.int({ min: 0, max: 50 }),
          },
          [faker.system.filePath()]: {
            status: FileInfo_Status.STATUS_ADDED,
            linesInserted: faker.number.int({ min: 10, max: 200 }),
          },
        },
      };
    }

    return revisions;
  }

  private generateGobSourceCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
    numChanges: number,
  ): CheckData {
    const gerritChangesInput: GobSourceCheckOptions_GerritChange[] = [];
    const gerritChangesOutput: GerritChangeInfo[] = [];

    for (let i = 0; i < numChanges; i++) {
      const host = faker.helpers.arrayElement(FAKE_GERRIT_HOSTS);
      const project = faker.helpers.arrayElement(FAKE_GERRIT_PROJECTS);
      const changeNum = faker.number
        .int({ min: 100000, max: 999999 })
        .toString();
      const ps = faker.number.int({ min: 2, max: 10 });

      const mountsToApply = faker.helpers.arrayElements(FAKE_MOUNT_PATHS, {
        min: 1,
        max: 3,
      });

      const inputCl: GobSourceCheckOptions_GerritChange = {
        hostname: host,
        changeNumber: changeNum,
        patchset: ps,
        mountsToApply: mountsToApply,
      };
      gerritChangesInput.push(inputCl);

      // Expanded GerritChangeInfo
      const owner = this.generateFakeAccount();
      const outputCl: GerritChangeInfo = {
        host: host,
        project: project,
        branch: faker.helpers.arrayElement(FAKE_GIT_BRANCHES),
        changeNumber: changeNum,
        changeId: `I${faker.string.hexadecimal({ length: 40, prefix: '' }).toLowerCase()}`,
        patchset: ps,
        status: GerritChangeInfo_Status.STATUS_NEW,
        creationTime: faker.date.past().toISOString(),
        lastModificationTime: faker.date.recent().toISOString(),
        owner: owner,
        topic: faker.datatype.boolean() ? faker.hacker.noun() : undefined,
        labels: this.generateFakeLabels(),
        reviewers: {
          REVIEWER: {
            accounts: [this.generateFakeAccount(), this.generateFakeAccount()],
          },
          CC: {
            accounts: [this.generateFakeAccount()],
          },
        },
        revisions: this.generateFakeRevisions(ps),
        messages: this.generateFakeMessages(Math.max(1, ps - 2), ps),
      };
      gerritChangesOutput.push(outputCl);
    }

    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };

    // Randomly decide whether to pin via project commit or manifest commit
    const useManifest = faker.datatype.boolean();

    const basePinnedRepos: GobSourceCheckOptions_PinnedRepoMounts = {
      projectCommit: useManifest ? undefined : this.generateFakeGitCommit(),
      manifestCommit: useManifest
        ? {
            commit: this.generateFakeGitCommit(),
            path: `manifest/${faker.system.commonFileName('xml')}`,
          }
        : undefined,
      mountOverrides: faker.helpers.multiple(
        () => ({
          mount: faker.helpers.arrayElement(FAKE_MOUNT_PATHS),
          override: this.generateFakeGitCommit(),
        }),
        { count: { min: 0, max: 3 } },
      ),
    };

    const sourceOptions: GobSourceCheckOptions = {
      gerritChanges: gerritChangesInput,
      basePinnedRepos: basePinnedRepos,
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_GOB_SOURCE_OPTIONS,
      sourceOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };

    const sourceResults: GobSourceCheckResults = {
      changes: gerritChangesOutput,
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_GOB_SOURCE_RESULTS,
      sourceResults,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  private generateBuildCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
    isSuccess: boolean,
  ): CheckData {
    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const targetName = faker.helpers.arrayElement(FAKE_TARGET_NAMES);
    const buildOptions: BuildCheckOptions = {
      target: {
        name: targetName,
        product: Product.PRODUCT_ANDROID,
        namespace: faker.helpers.arrayElement(FAKE_ANDROID_BRANCHES),
      },
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_BUILD_OPTIONS,
      buildOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };

    const buildId = 'P' + faker.string.numeric(8);

    const buildResult: BuildCheckResult = {
      success: isSuccess,
      displayMessage: {
        message: isSuccess
          ? `Build ${buildId} for ${targetName} completed successfully.`
          : `Build ${buildId} for ${targetName} failed.`,
      },
      viewUrl: `https://android-build.googleplex.com/builds/submitted/${buildId}/${targetName}/latest`,
      gcsArtifacts: {
        [faker.system.commonFileType()]: {
          rootDirectoryUri: faker.system.directoryPath(),
          filesByCategory: {
            [faker.system.commonFileExt()]: {
              files: faker.helpers.multiple(faker.system.filePath, {
                count: 5,
              }),
            },
          },
        },
      },
      androidBuildArtifacts: {
        buildId: buildId,
        target: targetName,
        buildAttempt: 'latest',
      },
      casManifest: {
        manifest: {
          [faker.system.commonFileName()]: faker.git.commitSha(),
          [faker.system.commonFileName()]: faker.git.commitSha(),
          [faker.system.commonFileName()]: faker.git.commitSha(),
        },
        casInstance: 'projects/android-build-farm/instances/default_instance',
        casService: 'remotebuildexecution.googleapis.com:443',
        clientVersion: '1.0',
      },
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_BUILD_RESULTS,
      buildResult,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  private generateGenericCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
  ): CheckData {
    const typeUrl = TYPE_URL_GENERIC_DATA;
    const testName = faker.helpers.arrayElement(FAKE_TEST_NAMES);
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      typeUrl,
      {
        description: `Generic options for ${testName}`,
        value: faker.lorem.sentence(),
      },
    );

    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };
    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      typeUrl,
      {
        description: `Generic result for ${testName}`,
        summary: faker.lorem.sentence(),
      },
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  // Helper to package options and results into a data interface used for constructing Checks.
  private assembleCheckData(
    optId: CheckOptionId,
    optDatum: Datum,
    resId: CheckResultId,
    datumId: CheckResultDatumId,
    resDatum: Datum,
    stageId: StageId,
  ): CheckData {
    const checkResult: Check_Result = {
      identifier: resId,
      owner: { stageAttempt: { stage: stageId } },
      data: [
        {
          identifier: datumId,
          typeUrl: this.getTypeUrlFromDatum(resDatum),
        },
      ],
    };

    return {
      optionsRef: {
        identifier: optId,
        typeUrl: this.getTypeUrlFromDatum(optDatum),
      },
      optionDatum: optDatum,
      resultRef: checkResult,
      resultView: {
        identifier: resId,
        data: { [this.getTypeUrlFromDatum(resDatum)]: resDatum },
      },
    };
  }

  private getTypeUrlFromDatum(datum: Datum): string {
    if (datum.value && datum.value.valueJson) {
      try {
        const obj = JSON.parse(datum.value.valueJson);
        return obj['@type'] || '';
      } catch {
        return '';
      }
    }
    return '';
  }

  // ==========================================
  // ID & Dependency / Edge Logic
  // ==========================================

  private createCheckId(id: string): CheckId {
    return { workPlan: this.workPlanId, id: id };
  }

  private createStageId(id: string): StageId {
    return { workPlan: this.workPlanId, id: id };
  }

  // ==========================================
  // Complex Sub-Object Generators
  // ==========================================

  private generateStageAttempt(
    stageIdStr: string,
    startRev: Revision,
    endRev: Revision,
    success: boolean,
  ): Stage_Attempt[] {
    const state = success
      ? StageAttemptState.STAGE_ATTEMPT_STATE_COMPLETE
      : StageAttemptState.STAGE_ATTEMPT_STATE_INCOMPLETE;
    const msg = success ? 'Complete' : 'Failed';

    const attempt: Stage_Attempt = {
      state: state,
      version: endRev,
      processUid: `worker-pool-REGION-1:${stageIdStr}:attempt-2`,
      details: [
        this.createValueFromObj(TYPE_URL_GENERIC_DATA, {
          url: faker.internet.url(),
          label: 'Executor Logs',
        }),
      ],
      progress: [
        { msg: 'Scheduled', version: startRev, details: [] },
        { msg: 'Running', version: startRev, details: [] },
        { msg: msg, version: endRev, details: [] },
      ],
      stateHistory: [],
    };

    return [attempt];
  }

  private createExecutionPolicyState(): Stage_ExecutionPolicyState {
    const policy = this.createExecutionPolicy();
    return {
      requested: policy,
      validated: policy, // Assume accepted as-is
    };
  }

  private createExecutionPolicy(): StageExecutionPolicy {
    return {
      retry: { maxRetries: 3 },
      stageTimeout: this.createDuration(7200),
      stageTimeoutMode:
        StageExecutionPolicy_StageTimeoutMode.STAGE_TIMEOUT_MODE_FINISH_CURRENT_ATTEMPT,
    };
  }

  // ==========================================
  // Edit and Delta Generators
  // ==========================================

  private createEdit(
    forNode: Identifier,
    realm: string,
    version: Revision,
    reasonMsg: string,
    delta: { check?: CheckDelta; stage?: StageDelta },
    editor?: Actor,
  ): Edit {
    // Hardcoded expiries roughly 30/180 days in future based on start time
    const futureTime = this.currentSimulatedTimeMs + 30 * 24 * 60 * 60 * 1000;
    const expireStr = new Date(futureTime).toISOString();

    return {
      forNode: forNode,
      version: version,
      expireAt: expireStr, // Roughly +180 days
      dataExpireAt: expireStr, // Roughly +30 days
      realm: realm,
      editor: editor || this.getOrchestratorActor(),
      transactionalSet: [forNode],
      reasons: [
        {
          realm: realm,
          reason: reasonMsg,
          details: [],
        },
      ],
      check: delta.check,
      stage: delta.stage,
    };
  }

  // ==========================================
  // Primitive & Common Type Helpers
  // ==========================================

  /** Advances internal timer and returns a new Revision string */
  private nextRevision(): Revision {
    this.currentSimulatedTimeMs += 1000; // Advance 1 second per call
    // Format: T<seconds>/<nanos> or ISO string depending on impl.
    // Using ISO for standard readability.
    return { ts: new Date(this.currentSimulatedTimeMs).toISOString() };
  }

  private createDuration(seconds: number): Duration {
    return {
      seconds: seconds.toString(),
      nanos: 0,
    };
  }

  private getOrchestratorActor(): Actor {
    return { orchestrator: {} };
  }

  private createDatum(
    id: Identifier,
    realm: string,
    typeUrl: string,
    payloadObj: object,
  ): Datum {
    return {
      identifier: id,
      realm: realm,
      version: this.nextRevision(),
      value: this.createValueFromObj(typeUrl, payloadObj),
    };
  }

  /**
   * Creates a Value proto from a plain JS object.
   * Simulates ProtoJSON serialization by adding the @type field.
   */
  private createValueFromObj(typeUrl: string, payloadObj: object): Value {
    const jsonPayload = {
      '@type': typeUrl,
      ...payloadObj,
    };

    return {
      hasUnknownFields: false,
      valueJson: JSON.stringify(jsonPayload),
    };
  }
}

function buildDependencies(
  targets: Identifier[],
  resolvedAt: Revision,
): Dependencies {
  if (!targets || targets.length === 0) {
    return { edges: [], resolutionEvents: {} };
  }

  const edges: Edge[] = targets.map((t) => {
    if (t.check) {
      return { check: { identifier: t.check } };
    }
    if (t.stage) {
      return { stage: { identifier: t.stage } };
    }
    throw new Error(`Invalid dependency target: ${JSON.stringify(t)}`);
  });
  const predicate: Dependencies_Group = {
    edges: edges.map((_, idx) => idx),
    groups: [],
  };

  const resolutionEvents: { [key: number]: Dependencies_ResolutionEvent } = {};
  edges.forEach((_, idx) => {
    resolutionEvents[idx] = {
      version: resolvedAt,
    };
  });

  return {
    edges,
    predicate,
    resolutionEvents,
  };
}
