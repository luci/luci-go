// Copyright 2025 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * This file is mostly generated by Gemini.
 *
 * The intention is that this will be used to generate fake data for a TurboCI graph while the
 * corresponding Turbo CI QueryNodes API meant to provide this data is still in development. Once
 * the API is available and integrated, we can remove this file.
 *
 * TODO - Remove the fakerjs dependency added in crrev.com/c/7047404 when this file is deleted.
 */

import { faker } from '@faker-js/faker';

import { Duration } from '../proto/google/protobuf/duration.pb';
import {
  BuildCheckOptions,
  Product,
} from '../proto/turboci/data/build/v1/build_check_options.pb';
import { BuildCheckResult } from '../proto/turboci/data/build/v1/build_check_results.pb';
import {
  GerritChangeInfo,
  GerritChangeInfo_Status,
} from '../proto/turboci/data/gerrit/v1/gerrit_change_info.pb';
import {
  GobSourceCheckOptions,
  GobSourceCheckOptions_GerritChange,
} from '../proto/turboci/data/gerrit/v1/gob_source_check_options.pb';
import { GobSourceCheckResults } from '../proto/turboci/data/gerrit/v1/gob_source_check_results.pb';
import {
  Identifier,
  WorkPlan,
  Check as CheckId,
  Stage as StageId,
  CheckOption as CheckOptionId,
  CheckResult as CheckResultId,
  CheckResultDatum as CheckResultDatumId,
} from '../proto/turboci/graph/ids/v1/identifier.pb';
import { Actor } from '../proto/turboci/graph/orchestrator/v1/actor.pb';
import {
  Check,
  Check_OptionRef,
  Check_Result,
} from '../proto/turboci/graph/orchestrator/v1/check.pb';
import { CheckDelta } from '../proto/turboci/graph/orchestrator/v1/check_delta.pb';
import { CheckEditView } from '../proto/turboci/graph/orchestrator/v1/check_edit_view.pb';
import { CheckKind } from '../proto/turboci/graph/orchestrator/v1/check_kind.pb';
import { CheckResultView } from '../proto/turboci/graph/orchestrator/v1/check_result_view.pb';
import {
  CheckState,
  checkStateToJSON,
} from '../proto/turboci/graph/orchestrator/v1/check_state.pb';
import { CheckView } from '../proto/turboci/graph/orchestrator/v1/check_view.pb';
import { Datum } from '../proto/turboci/graph/orchestrator/v1/datum.pb';
import {
  Edge,
  Edge_Resolution,
} from '../proto/turboci/graph/orchestrator/v1/edge.pb';
import { EdgeGroup } from '../proto/turboci/graph/orchestrator/v1/edge_group.pb';
import { Edit } from '../proto/turboci/graph/orchestrator/v1/edit.pb';
import {
  ExecutionPolicy,
  ExecutionPolicy_StageTimeoutMode,
} from '../proto/turboci/graph/orchestrator/v1/execution_policy.pb';
import { GraphView } from '../proto/turboci/graph/orchestrator/v1/graph_view.pb';
import { Revision } from '../proto/turboci/graph/orchestrator/v1/revision.pb';
import {
  Stage,
  Stage_Assignment,
  Stage_Attempt,
  Stage_ExecutionPolicyState,
} from '../proto/turboci/graph/orchestrator/v1/stage.pb';
import { StageAttemptState } from '../proto/turboci/graph/orchestrator/v1/stage_attempt_state.pb';
import { StageDelta } from '../proto/turboci/graph/orchestrator/v1/stage_delta.pb';
import { StageEditView } from '../proto/turboci/graph/orchestrator/v1/stage_edit_view.pb';
import { StageView } from '../proto/turboci/graph/orchestrator/v1/stage_view.pb';
import { Value } from '../proto/turboci/graph/orchestrator/v1/value.pb';

// Type URLs for the data protos
const TYPE_URL_GOB_SOURCE_OPTIONS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckOptions';
const TYPE_URL_GOB_SOURCE_RESULTS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckResults';
const TYPE_URL_BUILD_OPTIONS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckOptions';
const TYPE_URL_BUILD_RESULTS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckResult';

// Fake data pools used by Faker.js
const FAKE_GERRIT_HOSTS = [
  'chromium',
  'android',
  'googleplex-android',
  'partner-android',
];
const FAKE_GERRIT_PROJECTS = [
  'device/google/cuttlefish',
  'platform/frameworks/support',
  'platform/frameworks/base',
  'kernel/build',
];
const FAKE_GIT_BRANCHES = ['main', 'androidx-main', 'android14-tests-release'];
const FAKE_TARGET_NAMES = [
  'husky-userdebug',
  'shiba-userdebug',
  'oriole-userdebug',
  'raven-userdebug',
  'rango-userdebug',
  'mustang-userdebug',
];
const FAKE_ANDROID_BRANCHES = [
  'git-main',
  'git_25Q1-release',
  'git_25Q2-release',
  'git_25Q3-release',
  'git_trunk-release',
];

/**
 * Configuration for the FakeGraphGenerator.
 */
export interface GraphGenerationConfig {
  workPlanIdStr: string;
  /** List of unique string IDs for Checks */
  checkIds: string[];
  /** List of unique string IDs for Stages */
  stageIds: string[];
  /**
   * Adjacency list for dependencies.
   * Key is the ID of the node (Check or Stage) that has dependencies.
   * Value is a list of IDs (Checks or Stages) that it depends on.
   */
  dependencies: Record<string, string[]>;
  /**
   * Optional mapping of Check ID to its CheckKind.
   * If not provided, defaults to CHECK_KIND_BUILD.
   */
  checkKinds?: Record<string, CheckKind>;
  /**
   * Optional list of check edits.
   * Each edit represents a stage editing a check's state.
   */
  checkEdits?: { stageId: string; checkId: string; state: CheckState }[];
}

interface CheckData {
  optionsRefs: Check_OptionRef[];
  optionDatums: Datum[];
  results: Check_Result[];
  resultViews: CheckResultView[];
}

export class FakeGraphGenerator {
  private workPlanId: WorkPlan;
  private checkIdMap: Map<string, CheckId> = new Map();
  private stageIdMap: Map<string, StageId> = new Map();
  private genericIdMap: Map<string, Identifier> = new Map();

  // Simulated time to ensure Revisions allow logical ordering (createdAt < finalizedAt)
  private currentSimulatedTimeMs = Date.UTC(2024, 0, 1, 12, 0, 0);

  constructor(private config: GraphGenerationConfig) {
    // Initialize faker seed for reproducible graphs based on workplan ID
    let seed = 0;
    for (let i = 0; i < config.workPlanIdStr.length; i++) {
      seed = (seed << 5) - seed + config.workPlanIdStr.charCodeAt(i);
      seed |= 0;
    }
    faker.seed(seed);

    // 1. Initialize base Identifiers
    this.workPlanId = { id: config.workPlanIdStr };

    // 2. Create all Node Identifiers first so dependencies can be resolved.
    for (const id of config.checkIds) {
      const checkId: CheckId = { workPlan: this.workPlanId, id: id };
      this.checkIdMap.set(id, checkId);
      this.genericIdMap.set(id, { check: checkId });
    }

    for (const id of config.stageIds) {
      // Ensure ID format complies with proto comments (S or N prefix)
      const formattedId = id.match(/^[SN]/) ? id : `S_${id}`;
      const stageId: StageId = { workPlan: this.workPlanId, id: formattedId };
      this.stageIdMap.set(id, stageId);
      this.genericIdMap.set(id, { stage: stageId });
    }
  }

  /**
   * Generates the complete GraphView based on the configuration.
   */
  public generate(): GraphView {
    const checkViews: CheckView[] = this.config.checkIds.map((id) =>
      this.generateCheckView(id),
    );
    const stageViews: StageView[] = this.config.stageIds.map((id) =>
      this.generateStageView(id),
    );

    return {
      version: this.nextRevision(),
      checks: checkViews,
      stages: stageViews,
    };
  }

  // ==========================================
  // Core View Generators
  // ==========================================

  private generateCheckView(idStr: string): CheckView {
    const checkId = this.checkIdMap.get(idStr)!;
    const realm = `${idStr}-realm`; // Deterministic realm
    const kind = this.config.checkKinds?.[idStr] ?? CheckKind.CHECK_KIND_BUILD;

    // Generate data based on CheckKind
    let data: CheckData;
    if (kind === CheckKind.CHECK_KIND_SOURCE) {
      data = this.generateSourceCheckData(checkId, realm);
    } else if (kind === CheckKind.CHECK_KIND_BUILD) {
      data = this.generateBuildCheckData(checkId, realm);
    } else {
      // Fallback for other kinds not yet specified
      data = this.generateGenericCheckData(checkId, realm, idStr);
    }

    // Generate foundational Check structure
    const check: Check = {
      identifier: checkId,
      kind: kind,
      realm: realm,
      version: this.nextRevision(),
      dependencies: this.resolveDependencies(idStr),
      options: data.optionsRefs,
      results: data.results,
    };

    // Generate edits for this check
    const edits: CheckEditView[] = this.generateCheckEdits(
      idStr,
      checkId,
      realm,
    );

    return {
      check: check,
      optionData: data.optionDatums,
      edits: edits,
      results: data.resultViews,
    };
  }

  private generateStageView(idStr: string): StageView {
    const stageId = this.stageIdMap.get(idStr)!;
    const realm = `${idStr}-realm`;
    const stage: Stage = {
      identifier: stageId,
      realm: realm,
      createTs: this.nextRevision(),
      version: this.nextRevision(),
      dependencies: this.resolveDependencies(idStr),
      executionPolicy: this.createExecutionPolicyState(),
      attempts: this.generateActiveStageAttempt(idStr),
      assignments: this.generateSampleAssignment(),
      continuationGroup: [], // Kept empty for simplicity
    };

    const edits: StageEditView[] = this.generateSampleStageEdit(stageId, realm);

    return {
      stage: stage,
      edits: edits,
    };
  }

  // ==========================================
  // Check Data Generators (Options & Results)
  // ==========================================

  private generateSourceCheckData(checkId: CheckId, realm: string): CheckData {
    const host = faker.helpers.arrayElement(FAKE_GERRIT_HOSTS);
    const project = faker.helpers.arrayElement(FAKE_GERRIT_PROJECTS);

    // Generate 1-2 input CLs
    const numCls = faker.number.int({ min: 1, max: 2 });
    const gerritChangesInput: GobSourceCheckOptions_GerritChange[] = [];
    const gerritChangesOutput: GerritChangeInfo[] = [];

    for (let i = 0; i < numCls; i++) {
      const changeNum = faker.number
        .int({ min: 100000, max: 999999 })
        .toString();
      const ps = faker.number.int({ min: 1, max: 10 });

      const inputCl: GobSourceCheckOptions_GerritChange = {
        hostname: host,
        changeNumber: changeNum,
        patchset: ps,
        mountsToApply: [], // Apply to all
      };
      gerritChangesInput.push(inputCl);

      // Expanded GerritChangeInfo
      const ownerEmail = faker.internet.email();
      const outputCl: GerritChangeInfo = {
        host: host,
        project: project,
        branch: faker.helpers.arrayElement(FAKE_GIT_BRANCHES),
        changeNumber: changeNum,
        patchset: ps,
        status: GerritChangeInfo_Status.STATUS_NEW,
        creationTime: faker.date.recent().toISOString(),
        owner: {
          email: ownerEmail,
          name: faker.person.fullName(),
          username: ownerEmail.split('@')[0],
          secondaryEmails: [],
          tags: [],
        },
        // Other fields omitted for brevity in fake data
        revisions: {},
        reviewers: {},
        labels: {},
        messages: [],
      };
      gerritChangesOutput.push(outputCl);
    }

    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const sourceOptions: GobSourceCheckOptions = {
      gerritChanges: gerritChangesInput,
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_GOB_SOURCE_OPTIONS,
      sourceOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };

    const sourceResults: GobSourceCheckResults = {
      changes: gerritChangesOutput,
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_GOB_SOURCE_RESULTS,
      sourceResults,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
    );
  }

  private generateBuildCheckData(checkId: CheckId, realm: string): CheckData {
    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const buildOptions: BuildCheckOptions = {
      target: {
        name: faker.helpers.arrayElement(FAKE_TARGET_NAMES),
        product: faker.helpers.enumValue(Product),
        namespace: faker.helpers.arrayElement(FAKE_ANDROID_BRANCHES),
      },
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_BUILD_OPTIONS,
      buildOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };
    const isSuccess = faker.datatype.boolean({ probability: 0.8 });

    const buildId = faker.string.numeric(16);

    const buildResult: BuildCheckResult = {
      success: isSuccess,
      displayMessage: {
        message: isSuccess
          ? 'Build completed successfully.'
          : `Build failed: ${faker.hacker.phrase()}`,
      },
      viewUrl: faker.internet.url({ appendSlash: false }) + `/b/${buildId}`,
      gcsArtifacts: {},
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_BUILD_RESULTS,
      buildResult,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
    );
  }

  private generateGenericCheckData(
    checkId: CheckId,
    realm: string,
    idStr: string,
  ): CheckData {
    const typeUrl = 'type.googleapis.com/turboci.demo.GenericData';

    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      typeUrl,
      {
        description: `Generic options for ${idStr}`,
        value: faker.lorem.sentence(),
      },
    );

    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };
    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      typeUrl,
      {
        description: `Generic result for ${idStr}`,
        summary: faker.lorem.sentence(),
      },
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
    );
  }

  // Helper to package options and results into a data interface used for constructing Checks.
  private assembleCheckData(
    optId: CheckOptionId,
    optDatum: Datum,
    resId: CheckResultId,
    datumId: CheckResultDatumId,
    resDatum: Datum,
  ): CheckData {
    const checkResult: Check_Result = {
      identifier: resId,
      owner: this.getOrchestratorActor(),
      createdAt: this.nextRevision(),
      data: [
        {
          identifier: datumId,
          typeUrl: this.getTypeUrlFromDatum(resDatum),
        },
      ],
      finalizedAt: this.nextRevision(),
    };

    return {
      optionsRefs: [
        {
          identifier: optId,
          typeUrl: this.getTypeUrlFromDatum(optDatum),
        },
      ],
      optionDatums: [optDatum],
      results: [checkResult],
      resultViews: [{ data: [resDatum] }],
    };
  }

  private getTypeUrlFromDatum(datum: Datum): string {
    if (datum.value && datum.value.valueJson) {
      try {
        const obj = JSON.parse(datum.value.valueJson);
        return obj['@type'] || '';
      } catch {
        return '';
      }
    }
    return '';
  }

  // ==========================================
  // Dependency / Edge Logic
  // ==========================================

  private resolveDependencies(sourceIdStr: string): EdgeGroup[] {
    const targetIds = this.config.dependencies[sourceIdStr];
    if (!targetIds || targetIds.length === 0) {
      return [];
    }

    // Create a simple AND group of all dependencies, all resolved.
    const edges: Edge[] = targetIds.map((targetIdStr) => {
      const targetIdentifier = this.genericIdMap.get(targetIdStr);
      if (!targetIdentifier) {
        throw new Error(
          `Dependency target ID specified but not found in configured IDs: ${targetIdStr}`,
        );
      }
      return this.createResolvedEdge(targetIdentifier);
    });

    return [
      {
        edges: edges,
        groups: [],
        threshold: undefined, // Implies AND all edges
        resolution: this.createResolution(), // Group is resolved
      },
    ];
  }

  private createResolvedEdge(target: Identifier): Edge {
    return {
      target: target,
      resolution: this.createResolution(),
    };
  }

  private createResolution(): Edge_Resolution {
    const targetV = this.nextRevision();
    return {
      satisfied: true,
      targetVersion: targetV,
      at: this.nextRevision(), // 'at' must be >= targetVersion
    };
  }

  // ==========================================
  // Complex Sub-Object Generators
  // ==========================================

  private generateActiveStageAttempt(stageIdStr: string): Stage_Attempt[] {
    // One historical successful attempt
    const rev = this.nextRevision();
    const attempt: Stage_Attempt = {
      state: StageAttemptState.STAGE_ATTEMPT_STATE_COMPLETE,
      version: rev,
      processUid: `worker-${faker.string.alphanumeric(8)}:${stageIdStr}:1`,
      details: [
        this.createValueFromObj(
          'type.googleapis.com/turboci.demo.ExecutorLink',
          {
            url: faker.internet.url(),
            label: 'Swarming Task',
          },
        ),
      ],
      progress: [
        { msg: 'Initialized', version: rev, details: [] },
        { msg: 'Running', version: rev, details: [] },
        { msg: 'Complete', version: rev, details: [] },
      ],
    };

    return [attempt];
  }

  private generateSampleAssignment(): Stage_Assignment[] {
    // If there are checks, assign this stage to the first one as a sample.
    if (this.config.checkIds.length > 0) {
      return [
        {
          target: this.checkIdMap.get(this.config.checkIds[0]),
          goalState: CheckState.CHECK_STATE_PLANNED,
        },
      ];
    }
    return [];
  }

  private createExecutionPolicyState(): Stage_ExecutionPolicyState {
    const policy = this.createExecutionPolicy();
    return {
      requested: policy,
      validated: policy, // Assume accepted as-is
    };
  }

  private createExecutionPolicy(): ExecutionPolicy {
    return {
      // Standard hardcoded timeouts
      attemptHeartbeat: { running: this.createDuration(60) },
      attemptTimeout: { running: this.createDuration(3600) },
      retry: { maxRetries: 3 },
      stageTimeout: this.createDuration(7200),
      stageTimeoutMode:
        ExecutionPolicy_StageTimeoutMode.STAGE_TIMEOUT_MODE_FINISH_CURRENT_ATTEMPT,
    };
  }

  // ==========================================
  // Edit and Delta Generators
  // ==========================================

  private generateCheckEdits(
    idStr: string,
    checkId: CheckId,
    realm: string,
  ): CheckEditView[] {
    const edits: CheckEditView[] = [];
    const confEdits = this.config.checkEdits?.filter(
      (e) => e.checkId === idStr,
    );

    if (confEdits) {
      for (const editInfo of confEdits) {
        const stageId = this.stageIdMap.get(editInfo.stageId);
        if (!stageId) {
          // Normally an error, but for fake data gen, skip if not found.
          continue;
        }

        const editVersion = this.nextRevision();
        const checkDelta: CheckDelta = {
          state: editInfo.state,
          dependencies: [],
          options: [],
          result: [],
        };

        const editor: Actor = {
          stageAttempt: {
            stage: stageId,
            attemptsIdx: 1,
          },
        };

        const edit: Edit = this.createEdit(
          { check: checkId },
          realm,
          editVersion,
          `State changed to ${checkStateToJSON(editInfo.state)}`,
          { check: checkDelta },
          editor,
        );

        edits.push({ edit: edit, optionData: [] });
      }
    }
    return edits;
  }

  private generateSampleStageEdit(
    stageId: StageId,
    realm: string,
  ): StageEditView[] {
    const editVersion = this.nextRevision();

    // An edit that updated policy
    const delta: StageDelta = {
      executionPolicies: [this.createExecutionPolicy()],
    };

    const edit: Edit = this.createEdit(
      { stage: stageId },
      realm,
      editVersion,
      'Executor validated policies',
      { stage: delta },
    );

    return [{ edit: edit }];
  }

  private createEdit(
    forNode: Identifier,
    realm: string,
    version: Revision,
    reasonMsg: string,
    delta: { check?: CheckDelta; stage?: StageDelta },
    editor?: Actor,
  ): Edit {
    // Hardcoded expiries roughly 30/180 days in future based on start time
    const futureTime = this.currentSimulatedTimeMs + 30 * 24 * 60 * 60 * 1000;
    const expireStr = new Date(futureTime).toISOString();

    return {
      forNode: forNode,
      version: version,
      expireAt: expireStr, // Roughly +180 days
      dataExpireAt: expireStr, // Roughly +30 days
      realm: realm,
      editor: editor || this.getOrchestratorActor(),
      transactionalSet: [forNode],
      reasons: [
        {
          realm: realm,
          reason: reasonMsg,
          details: [],
        },
      ],
      check: delta.check,
      stage: delta.stage,
    };
  }

  // ==========================================
  // Primitive & Common Type Helpers
  // ==========================================

  /** Advances internal timer and returns a new Revision string */
  private nextRevision(): Revision {
    this.currentSimulatedTimeMs += 1000; // Advance 1 second per call
    // Format: T<seconds>/<nanos> or ISO string depending on impl.
    // Using ISO for standard readability.
    return { ts: new Date(this.currentSimulatedTimeMs).toISOString() };
  }

  private createDuration(seconds: number): Duration {
    return {
      seconds: seconds.toString(),
      nanos: 0,
    };
  }

  private getOrchestratorActor(): Actor {
    return { orchestrator: {} };
  }

  private createDatum(
    id: Identifier,
    realm: string,
    typeUrl: string,
    payloadObj: object,
  ): Datum {
    return {
      identifier: id,
      realm: realm,
      version: this.nextRevision(),
      value: this.createValueFromObj(typeUrl, payloadObj),
    };
  }

  /**
   * Creates a Value proto from a plain JS object.
   * Simulates ProtoJSON serialization by adding the @type field.
   */
  private createValueFromObj(typeUrl: string, payloadObj: object): Value {
    const jsonPayload = {
      '@type': typeUrl,
      ...payloadObj,
    };

    return {
      hasUnknownFields: false,
      valueJson: JSON.stringify(jsonPayload),
    };
  }
}
