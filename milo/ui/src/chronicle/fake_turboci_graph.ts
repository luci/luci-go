// Copyright 2025 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * This file is mostly generated by Gemini.
 *
 * The intention is that this will be used to generate fake data for a TurboCI graph while the
 * corresponding Turbo CI QueryNodes API meant to provide this data is still in development. Once
 * the API is available and integrated, we can remove this file.
 *
 * TODO - Remove the fakerjs dependency added in crrev.com/c/7047404 when this file is deleted.
 */

import { faker } from '@faker-js/faker';

import { Duration } from '../proto/google/protobuf/duration.pb';
import {
  BuildCheckOptions,
  Product,
} from '../proto/turboci/data/build/v1/build_check_options.pb';
import { BuildCheckResult } from '../proto/turboci/data/build/v1/build_check_results.pb';
import {
  GerritChangeInfo,
  GerritChangeInfo_Status,
} from '../proto/turboci/data/gerrit/v1/gerrit_change_info.pb';
import {
  GobSourceCheckOptions,
  GobSourceCheckOptions_GerritChange,
} from '../proto/turboci/data/gerrit/v1/gob_source_check_options.pb';
import { GobSourceCheckResults } from '../proto/turboci/data/gerrit/v1/gob_source_check_results.pb';
import {
  Identifier,
  WorkPlan,
  Check as CheckId,
  Stage as StageId,
  CheckOption as CheckOptionId,
  CheckResult as CheckResultId,
  CheckResultDatum as CheckResultDatumId,
} from '../proto/turboci/graph/ids/v1/identifier.pb';
import { Actor } from '../proto/turboci/graph/orchestrator/v1/actor.pb';
import {
  Check,
  Check_OptionRef,
  Check_Result,
} from '../proto/turboci/graph/orchestrator/v1/check.pb';
import { CheckDelta } from '../proto/turboci/graph/orchestrator/v1/check_delta.pb';
import { CheckEditView } from '../proto/turboci/graph/orchestrator/v1/check_edit_view.pb';
import { CheckKind } from '../proto/turboci/graph/orchestrator/v1/check_kind.pb';
import { CheckResultView } from '../proto/turboci/graph/orchestrator/v1/check_result_view.pb';
import { CheckState } from '../proto/turboci/graph/orchestrator/v1/check_state.pb';
import { CheckView } from '../proto/turboci/graph/orchestrator/v1/check_view.pb';
import { Datum } from '../proto/turboci/graph/orchestrator/v1/datum.pb';
import {
  Dependencies,
  Dependencies_Group,
  Dependencies_ResolutionEvent,
} from '../proto/turboci/graph/orchestrator/v1/dependencies.pb';
import { Edge } from '../proto/turboci/graph/orchestrator/v1/edge.pb';
import { Edit } from '../proto/turboci/graph/orchestrator/v1/edit.pb';
import { GraphView } from '../proto/turboci/graph/orchestrator/v1/graph_view.pb';
import { Revision } from '../proto/turboci/graph/orchestrator/v1/revision.pb';
import {
  Stage,
  Stage_Attempt,
  Stage_ExecutionPolicyState,
} from '../proto/turboci/graph/orchestrator/v1/stage.pb';
import { StageAttemptState } from '../proto/turboci/graph/orchestrator/v1/stage_attempt_state.pb';
import { StageDelta } from '../proto/turboci/graph/orchestrator/v1/stage_delta.pb';
import { StageEditView } from '../proto/turboci/graph/orchestrator/v1/stage_edit_view.pb';
import {
  StageExecutionPolicy,
  StageExecutionPolicy_StageTimeoutMode,
} from '../proto/turboci/graph/orchestrator/v1/stage_execution_policy.pb';
import { StageState } from '../proto/turboci/graph/orchestrator/v1/stage_state.pb';
import { StageView } from '../proto/turboci/graph/orchestrator/v1/stage_view.pb';
import { Value } from '../proto/turboci/graph/orchestrator/v1/value.pb';

// Type URLs for the data protos
const TYPE_URL_GOB_SOURCE_OPTIONS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckOptions';
const TYPE_URL_GOB_SOURCE_RESULTS =
  'type.googleapis.com/turboci.data.gerrit.v1.GobSourceCheckResults';
const TYPE_URL_BUILD_OPTIONS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckOptions';
const TYPE_URL_BUILD_RESULTS =
  'type.googleapis.com/turboci.data.build.v1.BuildCheckResult';
const TYPE_URL_GENERIC_DATA = 'type.googleapis.com/turboci.demo.GenericData';

// Fake data pools used by Faker.js
const FAKE_GERRIT_HOSTS = [
  'chromium',
  'android',
  'googleplex-android',
  'partner-android',
];
const FAKE_GERRIT_PROJECTS = [
  'device/google/cuttlefish',
  'platform/frameworks/support',
  'platform/frameworks/base',
  'kernel/build',
  'platform/vendor/google/camera',
];
const FAKE_GIT_BRANCHES = ['main', 'androidx-main', 'android14-tests-release'];
const FAKE_ANDROID_BRANCHES = [
  'git-main',
  'git_25Q1-release',
  'git_25Q2-release',
  'git_25Q3-release',
  'git_trunk-release',
];
const FAKE_TARGET_NAMES = [
  'stallion-trunk_staging-userdebug',
  'lynx-trunk_staging-userdebug',
  'husky-trunk_staging-userdebug',
  'komodo-trunk_staging-userdebug',
  'cheetah-trunk_staging-userdebug',
  'cheetah-next-userdebug',
  'yogi-cd1a-userdebug',
  'oriole-trunk_staging-userdebug',
  'rango-trunk_staging-userdebug',
  'tokay-trunk_staging-userdebug',
  'akita-trunk_staging-userdebug',
  'comet-trunk_staging-userdebug',
  'tegu-trunk_staging-userdebug',
];
const FAKE_TEST_NAMES = [
  'v2/pixel-health-guard/device-boot-test',
  'v2/pts-presubmit/device-presubmit-wifi',
  'v2/pixel-camera-automation/pts-presubmit-with-scene-sta5',
  'v2/pixel-camera-automation/cts-presubmit-with-scene-sta5',
  'v2/pc3a/camera_3a/device_unit_tests',
  'v2/android-camera/pact-cfa-pre-mh-tests',
  'v2/android-lyric-code-silo-access/isp-test-health/zumapro/presubmit_eligible_unit_tests',
  'v2/pixel-camera-flextape-team/leakr-scan/lyric',
  'v2/android-test-harness-team/suite/host_unit_tests',
  'v2/sysui/systemui/robo_rng_keyguard_tests',
  'v2/android-crystalball-eng/health/microbench/uibench/uibench-jank-presubmit',
  'v2/faceauth-eng/husky_presubmit_camera',
  'v2/android-multiuser/preinstall-allowlist-test',
  'v2/android-gki/test_mapping_kernel_presubmit',
];

/**
 * Configuration for the FakeGraphGenerator.
 */
export interface GraphGenerationConfig {
  workPlanIdStr: string;
  /** Number of Gerrit changes to include in the source check. */
  numSourceChanges: number;
  /** Number of distinct build targets to simulate. */
  numBuilds: number;
  /** Average number of tests dependent on each build. */
  avgTestsPerBuild: number;
}

interface CheckData {
  optionsRef: Check_OptionRef;
  optionDatum: Datum;
  resultRef: Check_Result;
  resultView: CheckResultView;
}

export class FakeGraphGenerator {
  private workPlanId: WorkPlan;
  private sourcePlanningStageId: StageId;
  private buildPlanningStageId: StageId;
  private testPlanningStageId: StageId;

  // Simulated time to ensure Revisions allow logical ordering (createdAt < finalizedAt)
  private currentSimulatedTimeMs = Date.UTC(2024, 0, 1, 12, 0, 0);

  // Accumulators for generated views where the key is the identifier.id
  private checkViews: Record<string, CheckView> = {};
  private stageViews: Record<string, StageView> = {};

  constructor(private config: GraphGenerationConfig) {
    // Initialize faker seed for reproducible graphs based on workplan ID
    let seed = 0;
    for (let i = 0; i < config.workPlanIdStr.length; i++) {
      seed = (seed << 5) - seed + config.workPlanIdStr.charCodeAt(i);
      seed |= 0;
    }
    faker.seed(seed);

    this.workPlanId = { id: config.workPlanIdStr };
    this.sourcePlanningStageId = this.createStageId('S_Planning_Source');
    this.buildPlanningStageId = this.createStageId('S_Planning_Build');
    this.testPlanningStageId = this.createStageId('S_Planning_Test');
  }

  /**
   * Generates the complete GraphView based on the configuration.
   */
  public generate(): GraphView {
    this.checkViews = {};
    this.stageViews = {};
    // Reset time for each generation to maintain reproducibility based on seed
    this.currentSimulatedTimeMs = Date.UTC(2024, 0, 1, 12, 0, 0);

    const sourceCheckIds: CheckId[] = [];
    const buildCheckIds: CheckId[] = [];
    const testCheckIds: CheckId[] = [];

    // 1. Generate Source Node (1 Check, 1 Stage)
    const sourceId = this.createSourcePair();
    sourceCheckIds.push(sourceId);

    // 2. Generate Build Nodes, dependent on Source
    for (let i = 0; i < this.config.numBuilds; i++) {
      buildCheckIds.push(this.createBuildPair(i, sourceId));
    }

    // 3. Generate Test Nodes, dependent on Builds
    for (let i = 0; i < buildCheckIds.length; i++) {
      // Vary number of tests per build slightly
      const numTests = faker.number.int({
        min: Math.max(1, this.config.avgTestsPerBuild - 2),
        max: this.config.avgTestsPerBuild + 2,
      });

      for (let j = 0; j < numTests; j++) {
        testCheckIds.push(this.createTestPair(i, j, buildCheckIds[i]));
      }
    }

    // 4. Create Planning Stages per check type.
    this.createPlanningStage(this.sourcePlanningStageId, sourceCheckIds);
    this.createPlanningStage(this.buildPlanningStageId, buildCheckIds);
    this.createPlanningStage(this.testPlanningStageId, testCheckIds);

    return {
      identifier: this.workPlanId,
      version: this.nextRevision(),
      checks: this.checkViews,
      stages: this.stageViews,
    };
  }

  // ==========================================
  // Procedural Generation Orchestration
  // ==========================================

  private createSourcePair(): CheckId {
    const idStr = 'Source';
    const checkId = this.createCheckId(`C_${idStr}`);
    const stageId = this.createStageId(`S_${idStr}`);
    const realm = `${idStr}-realm`;

    // Generate Data
    const data = this.generateSourceCheckData(checkId, realm, stageId);

    // Generate Views (simulating lifecycle)
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_SOURCE,
      realm,
      [], // No dependencies
      stageId,
      data,
    );
    // Source stages always succeed in this simulation
    this.generateStageView(stageId, realm, [], true, [checkId]);

    return checkId;
  }

  private createBuildPair(index: number, sourceCheckId: CheckId): CheckId {
    const idStr = `Build_${index}`;
    const checkId = this.createCheckId(`C_${idStr}`);
    const stageId = this.createStageId(`S_${idStr}`);
    const realm = `${idStr}-realm`;

    // Random success/failure
    const success = faker.datatype.boolean();

    // Generate Data
    const data = this.generateBuildCheckData(checkId, realm, stageId, success);

    // Generate Views
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_BUILD,
      realm,
      [{ check: sourceCheckId }],
      stageId,
      data,
    );
    this.generateStageView(
      stageId,
      realm,
      [{ check: sourceCheckId }],
      success,
      [checkId],
    );
    return checkId;
  }

  private createTestPair(
    buildIndex: number,
    testIndex: number,
    buildCheckId: CheckId,
  ): CheckId {
    const idStr = `Build_${buildIndex}_Test_${testIndex}`;
    const checkId = this.createCheckId(`C_${idStr}`);
    const realm = `${idStr}-realm`;

    const success = faker.datatype.boolean();

    // 10% of the time, create 2-4 stages assigned to the same test check
    const numStages = faker.datatype.boolean(0.1)
      ? faker.number.int({ min: 2, max: 4 })
      : 1;
    const stageIds: StageId[] = [];
    for (let i = 0; i < numStages; i++) {
      const stageId = this.createStageId(
        `S_${idStr}` + (numStages > 1 ? `-${i}` : ''),
      );
      stageIds.push(stageId);
      this.generateStageView(
        stageId,
        realm,
        [{ check: buildCheckId }],
        success,
        [checkId],
      );
    }

    // If we created multiple stages, we still need one to be the actual editor to FINAL state
    // so just pick the first one.
    const finalizingStageId = stageIds[0];

    // Generate Data
    const data = this.generateGenericCheckData(
      checkId,
      realm,
      finalizingStageId,
    );

    // Generate Views
    this.generateCheckView(
      checkId,
      CheckKind.CHECK_KIND_TEST,
      realm,
      [{ check: buildCheckId }],
      finalizingStageId,
      data,
    );

    return checkId;
  }

  private createPlanningStage(
    stageId: StageId,
    assignedCheckIds: CheckId[],
  ): void {
    if (assignedCheckIds.length === 0) {
      return;
    }
    this.generateStageView(
      stageId,
      'planning_realm',
      [],
      true,
      assignedCheckIds,
      CheckState.CHECK_STATE_PLANNED,
    );
  }

  // ==========================================
  // Core View Generators (Simulated Lifecycle)
  // ==========================================

  private generateCheckView(
    checkId: CheckId,
    kind: CheckKind,
    realm: string,
    dependencies: Identifier[],
    executingStageId: StageId,
    data: CheckData,
  ): void {
    // Determine the specific planning stage based on kind.
    let planningStageId: StageId;
    switch (kind) {
      case CheckKind.CHECK_KIND_SOURCE:
        planningStageId = this.sourcePlanningStageId;
        break;
      case CheckKind.CHECK_KIND_BUILD:
        planningStageId = this.buildPlanningStageId;
        break;
      case CheckKind.CHECK_KIND_TEST:
        planningStageId = this.testPlanningStageId;
        break;
      default:
        // Fallback, should not happen in this fake generator
        planningStageId = this.sourcePlanningStageId;
    }

    const edits: CheckEditView[] = [];
    const actor: Actor = {
      stageAttempt: { stage: executingStageId },
    };
    const planningActor: Actor = {
      stageAttempt: { stage: planningStageId },
    };

    // Timestamps for lifecycle
    const creationRev = this.nextRevision();
    const plannedRev = this.nextRevision();
    const finalRev = this.nextRevision();

    const deps = buildDependencies(dependencies, finalRev);
    const emptyDeps: Dependencies = {
      edges: [],
      resolutionEvents: {},
    };

    // 1. Creation Edit (PLANNING)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        creationRev,
        'Creation',
        {
          check: {
            state: CheckState.CHECK_STATE_PLANNING,
            options: [data.optionsRef.identifier!],
            dependencies: deps,
            result: [],
          },
        },
        this.getOrchestratorActor(),
      ),
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
    });

    // 2. Planned (by planning stage)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        plannedRev,
        'Planned',
        {
          check: {
            state: CheckState.CHECK_STATE_PLANNED,
            options: [data.optionsRef.identifier!],
            dependencies: deps,
            result: [],
          },
        },
        planningActor,
      ),
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
    });

    // 3. Waiting Edit (simulated orchestration steps)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        plannedRev,
        'Waiting for dependencies',
        {
          check: {
            state: CheckState.CHECK_STATE_WAITING,
            result: [],
            options: [],
            dependencies: emptyDeps,
          },
        },
        this.getOrchestratorActor(),
      ),
      optionData: {},
    });

    // Construct finalized result ref based on generated data and time
    const finalizedResultRef: Check_Result = {
      identifier: data.resultRef.identifier,
      owner: data.resultRef.owner,
      data: data.resultRef.data,
      createdAt: finalRev,
      finalizedAt: finalRev,
    };

    // 4. Final Edit by executing stage (Results Posted)
    edits.push({
      edit: this.createEdit(
        { check: checkId },
        realm,
        finalRev,
        'Results posted and finalized',
        {
          check: {
            state: CheckState.CHECK_STATE_FINAL,
            options: [],
            dependencies: emptyDeps,
            result: [
              {
                identifier: finalizedResultRef.identifier,
                created: true,
                finalized: true,
                data: finalizedResultRef.data.map((d) => d.identifier!),
              },
            ],
          },
        },
        actor,
      ),
      optionData: data.resultView.data,
    });

    // Construct Final Check Object (immutable components + final state)
    const check: Check = {
      identifier: checkId,
      kind: kind,
      realm: realm,
      version: finalRev,
      dependencies: deps,
      options: [data.optionsRef],
      results: [finalizedResultRef],
      state: CheckState.CHECK_STATE_FINAL,
    };

    if (!checkId.id) throw new Error('Check ID required');
    this.checkViews[checkId.id] = {
      check: check,
      optionData: { [data.optionsRef.typeUrl!]: data.optionDatum },
      edits: edits,
      results: { [data.resultView.identifier!.idx!]: data.resultView },
    };
  }

  private generateStageView(
    stageId: StageId,
    realm: string,
    dependencies: Identifier[],
    success: boolean,
    assignments: CheckId[],
    assignmentGoalState = CheckState.CHECK_STATE_FINAL,
  ): void {
    const idStr = stageId.id!;
    const edits: StageEditView[] = [];

    // Timestamps
    const createRev = this.nextRevision();
    const attemptRev = this.nextRevision();
    const finalRev = this.nextRevision();

    // 1. Creation Edit (PLANNED)
    edits.push({
      edit: this.createEdit({ stage: stageId }, realm, createRev, 'Creation', {
        stage: { state: StageState.STAGE_STATE_PLANNED, executionPolicies: [] },
      }),
    });

    // 2. Attempting Edit
    edits.push({
      edit: this.createEdit(
        { stage: stageId },
        realm,
        attemptRev,
        'Dispatched to executor',
        {
          stage: {
            state: StageState.STAGE_STATE_ATTEMPTING,
            executionPolicies: [],
          },
        },
      ),
    });

    // Generate attempt data based on final time
    const attempts = this.generateStageAttempt(
      idStr,
      attemptRev,
      finalRev,
      success,
    );

    // 3. Final Edit
    edits.push({
      edit: this.createEdit(
        { stage: stageId },
        realm,
        finalRev,
        'Execution completed',
        {
          stage: { state: StageState.STAGE_STATE_FINAL, executionPolicies: [] },
        },
      ),
    });

    // Construct Final Stage Object
    const stage: Stage = {
      identifier: stageId,
      realm: realm,
      createTs: createRev,
      version: finalRev,
      dependencies: buildDependencies(dependencies, finalRev),
      executionPolicy: this.createExecutionPolicyState(),
      state: StageState.STAGE_STATE_FINAL,
      attempts: attempts,
      assignments: assignments.map((assignment) => ({
        target: assignment,
        goalState: assignmentGoalState,
      })),
      continuationGroup: [],
      args: this.createValueFromObj(TYPE_URL_GENERIC_DATA, {
        args: faker.hacker.phrase(),
      }),
    };

    this.stageViews[idStr] = {
      stage: stage,
      edits: edits,
    };
  }

  // ==========================================
  // Check Data Generators (Options & Results)
  // ==========================================

  private generateSourceCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
  ): CheckData {
    const host = faker.helpers.arrayElement(FAKE_GERRIT_HOSTS);
    const project = faker.helpers.arrayElement(FAKE_GERRIT_PROJECTS);

    const gerritChangesInput: GobSourceCheckOptions_GerritChange[] = [];
    const gerritChangesOutput: GerritChangeInfo[] = [];

    for (let i = 0; i < this.config.numSourceChanges; i++) {
      const changeNum = faker.number
        .int({ min: 100000, max: 999999 })
        .toString();
      const ps = faker.number.int({ min: 1, max: 10 });

      const inputCl: GobSourceCheckOptions_GerritChange = {
        hostname: host,
        changeNumber: changeNum,
        patchset: ps,
        mountsToApply: [], // Apply to all
      };
      gerritChangesInput.push(inputCl);

      // Expanded GerritChangeInfo
      const ownerEmail = faker.internet.email();
      const outputCl: GerritChangeInfo = {
        host: host,
        project: project,
        branch: faker.helpers.arrayElement(FAKE_GIT_BRANCHES),
        changeNumber: changeNum,
        patchset: ps,
        status: GerritChangeInfo_Status.STATUS_NEW,
        creationTime: faker.date.recent().toISOString(),
        owner: {
          email: ownerEmail,
          name: faker.person.fullName(),
          username: ownerEmail.split('@')[0],
          secondaryEmails: [],
          tags: [],
        },
        // Other fields omitted for brevity in fake data
        revisions: {},
        reviewers: {},
        labels: {},
        messages: [],
      };
      gerritChangesOutput.push(outputCl);
    }

    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const sourceOptions: GobSourceCheckOptions = {
      gerritChanges: gerritChangesInput,
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_GOB_SOURCE_OPTIONS,
      sourceOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };

    const sourceResults: GobSourceCheckResults = {
      changes: gerritChangesOutput,
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_GOB_SOURCE_RESULTS,
      sourceResults,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  private generateBuildCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
    isSuccess: boolean,
  ): CheckData {
    // --- Options ---
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const targetName = faker.helpers.arrayElement(FAKE_TARGET_NAMES);
    const buildOptions: BuildCheckOptions = {
      target: {
        name: targetName,
        product: Product.PRODUCT_ANDROID,
        namespace: faker.helpers.arrayElement(FAKE_ANDROID_BRANCHES),
      },
    };

    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      TYPE_URL_BUILD_OPTIONS,
      buildOptions,
    );

    // --- Results ---
    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };

    const buildId = 'P' + faker.string.numeric(8);

    const buildResult: BuildCheckResult = {
      success: isSuccess,
      displayMessage: {
        message: isSuccess
          ? `Build ${buildId} for ${targetName} completed successfully.`
          : `Build ${buildId} for ${targetName} failed.`,
      },
      viewUrl: `https://android-build.googleplex.com/builds/submitted/${buildId}/${targetName}/latest`,
      gcsArtifacts: {
        [faker.system.commonFileType()]: {
          rootDirectoryUri: faker.system.directoryPath(),
          filesByCategory: {
            [faker.system.commonFileExt()]: {
              files: faker.helpers.multiple(faker.system.filePath, {
                count: 5,
              }),
            },
          },
        },
      },
      androidBuildArtifacts: {
        buildId: buildId,
        target: targetName,
        buildAttempt: 'latest',
      },
      casManifest: {
        manifest: {
          [faker.system.commonFileName()]: faker.git.commitSha(),
          [faker.system.commonFileName()]: faker.git.commitSha(),
          [faker.system.commonFileName()]: faker.git.commitSha(),
        },
        casInstance: 'projects/android-build-farm/instances/default_instance',
        casService: 'remotebuildexecution.googleapis.com:443',
        clientVersion: '1.0',
      },
    };

    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      TYPE_URL_BUILD_RESULTS,
      buildResult,
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  private generateGenericCheckData(
    checkId: CheckId,
    realm: string,
    stageId: StageId,
  ): CheckData {
    const typeUrl = TYPE_URL_GENERIC_DATA;
    const testName = faker.helpers.arrayElement(FAKE_TEST_NAMES);
    const optId: CheckOptionId = { check: checkId, idx: 1 };
    const optionDatum = this.createDatum(
      { checkOption: optId },
      realm,
      typeUrl,
      {
        description: `Generic options for ${testName}`,
        value: faker.lorem.sentence(),
      },
    );

    const resId: CheckResultId = { check: checkId, idx: 1 };
    const datumId: CheckResultDatumId = { result: resId, idx: 1 };
    const resultDatum = this.createDatum(
      { checkResultDatum: datumId },
      realm,
      typeUrl,
      {
        description: `Generic result for ${testName}`,
        summary: faker.lorem.sentence(),
      },
    );

    return this.assembleCheckData(
      optId,
      optionDatum,
      resId,
      datumId,
      resultDatum,
      stageId,
    );
  }

  // Helper to package options and results into a data interface used for constructing Checks.
  private assembleCheckData(
    optId: CheckOptionId,
    optDatum: Datum,
    resId: CheckResultId,
    datumId: CheckResultDatumId,
    resDatum: Datum,
    stageId: StageId,
  ): CheckData {
    const checkResult: Check_Result = {
      identifier: resId,
      owner: { stageAttempt: { stage: stageId } },
      data: [
        {
          identifier: datumId,
          typeUrl: this.getTypeUrlFromDatum(resDatum),
        },
      ],
    };

    return {
      optionsRef: {
        identifier: optId,
        typeUrl: this.getTypeUrlFromDatum(optDatum),
      },
      optionDatum: optDatum,
      resultRef: checkResult,
      resultView: {
        identifier: resId,
        data: { [this.getTypeUrlFromDatum(resDatum)]: resDatum },
      },
    };
  }

  private getTypeUrlFromDatum(datum: Datum): string {
    if (datum.value && datum.value.valueJson) {
      try {
        const obj = JSON.parse(datum.value.valueJson);
        return obj['@type'] || '';
      } catch {
        return '';
      }
    }
    return '';
  }

  // ==========================================
  // ID & Dependency / Edge Logic
  // ==========================================

  private createCheckId(id: string): CheckId {
    return { workPlan: this.workPlanId, id: id };
  }

  private createStageId(id: string): StageId {
    return { workPlan: this.workPlanId, id: id };
  }

  // ==========================================
  // Complex Sub-Object Generators
  // ==========================================

  private generateStageAttempt(
    stageIdStr: string,
    startRev: Revision,
    endRev: Revision,
    success: boolean,
  ): Stage_Attempt[] {
    const state = success
      ? StageAttemptState.STAGE_ATTEMPT_STATE_COMPLETE
      : StageAttemptState.STAGE_ATTEMPT_STATE_INCOMPLETE;
    const msg = success ? 'Complete' : 'Failed';

    const attempt: Stage_Attempt = {
      state: state,
      version: endRev,
      processUid: `worker-pool-REGION-1:${stageIdStr}:attempt-2`,
      details: [
        this.createValueFromObj(TYPE_URL_GENERIC_DATA, {
          url: faker.internet.url(),
          label: 'Executor Logs',
        }),
      ],
      progress: [
        { msg: 'Scheduled', version: startRev, details: [] },
        { msg: 'Running', version: startRev, details: [] },
        { msg: msg, version: endRev, details: [] },
      ],
    };

    return [attempt];
  }

  private createExecutionPolicyState(): Stage_ExecutionPolicyState {
    const policy = this.createExecutionPolicy();
    return {
      requested: policy,
      validated: policy, // Assume accepted as-is
    };
  }

  private createExecutionPolicy(): StageExecutionPolicy {
    return {
      retry: { maxRetries: 3 },
      stageTimeout: this.createDuration(7200),
      stageTimeoutMode:
        StageExecutionPolicy_StageTimeoutMode.STAGE_TIMEOUT_MODE_FINISH_CURRENT_ATTEMPT,
    };
  }

  // ==========================================
  // Edit and Delta Generators
  // ==========================================

  private createEdit(
    forNode: Identifier,
    realm: string,
    version: Revision,
    reasonMsg: string,
    delta: { check?: CheckDelta; stage?: StageDelta },
    editor?: Actor,
  ): Edit {
    // Hardcoded expiries roughly 30/180 days in future based on start time
    const futureTime = this.currentSimulatedTimeMs + 30 * 24 * 60 * 60 * 1000;
    const expireStr = new Date(futureTime).toISOString();

    return {
      forNode: forNode,
      version: version,
      expireAt: expireStr, // Roughly +180 days
      dataExpireAt: expireStr, // Roughly +30 days
      realm: realm,
      editor: editor || this.getOrchestratorActor(),
      transactionalSet: [forNode],
      reasons: [
        {
          realm: realm,
          reason: reasonMsg,
          details: [],
        },
      ],
      check: delta.check,
      stage: delta.stage,
    };
  }

  // ==========================================
  // Primitive & Common Type Helpers
  // ==========================================

  /** Advances internal timer and returns a new Revision string */
  private nextRevision(): Revision {
    this.currentSimulatedTimeMs += 1000; // Advance 1 second per call
    // Format: T<seconds>/<nanos> or ISO string depending on impl.
    // Using ISO for standard readability.
    return { ts: new Date(this.currentSimulatedTimeMs).toISOString() };
  }

  private createDuration(seconds: number): Duration {
    return {
      seconds: seconds.toString(),
      nanos: 0,
    };
  }

  private getOrchestratorActor(): Actor {
    return { orchestrator: {} };
  }

  private createDatum(
    id: Identifier,
    realm: string,
    typeUrl: string,
    payloadObj: object,
  ): Datum {
    return {
      identifier: id,
      realm: realm,
      version: this.nextRevision(),
      value: this.createValueFromObj(typeUrl, payloadObj),
    };
  }

  /**
   * Creates a Value proto from a plain JS object.
   * Simulates ProtoJSON serialization by adding the @type field.
   */
  private createValueFromObj(typeUrl: string, payloadObj: object): Value {
    const jsonPayload = {
      '@type': typeUrl,
      ...payloadObj,
    };

    return {
      hasUnknownFields: false,
      valueJson: JSON.stringify(jsonPayload),
    };
  }
}

function buildDependencies(
  targets: Identifier[],
  resolvedAt: Revision,
): Dependencies {
  if (!targets || targets.length === 0) {
    return { edges: [], resolutionEvents: {} };
  }

  const edges: Edge[] = targets.map((t) => ({ target: t }));
  const predicate: Dependencies_Group = {
    edges: edges.map((_, idx) => idx),
    groups: [],
  };

  const resolutionEvents: { [key: number]: Dependencies_ResolutionEvent } = {};
  edges.forEach((_, idx) => {
    resolutionEvents[idx] = {
      version: resolvedAt,
      satisfied: true,
    };
  });

  return {
    edges,
    predicate,
    resolutionEvents,
    resolved: predicate,
  };
}
