// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/data/gerrit/v1/gerrit_change_info.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp.pb";

export const protobufPackage = "turboci.data.gerrit.v1";

/**
 * These fields should roughly match Gerrit ChangeInfo.
 * https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#change-info
 * Please see the Gerrit documentation for details on which fields are required/optional and when
 * certain fields are populated/left empty.
 *
 * Note that the main purpose here is to replicate the ChangeInfo fields from the Gerrit Change Detail API
 * response, and to ensure the same fields available in legacy CI systems are also available here, even if
 * some fields may not have an immediate use for CI purposes. Therefore the fields in this message and its
 * sub-messages are expected to be populated from the Gerrit API response rather than directly by workflows.
 */
export interface GerritChangeInfo {
  /**
   * Which Gerrit instance this change is hosted on. This should not include the
   * ".googlesource.com" hostname suffix as the suffix may be different depending on how it's
   * accessed (eg. ".git.corp.google.com")
   *
   * Example:
   *   https://android.googlesource.com/ -> "android"
   */
  readonly host?:
    | string
    | undefined;
  /**
   * Which project.
   *
   * Example:
   *   https://android.googlesource.com/device/google/cuttlefish/ ->
   *     "device/google/cuttlefish"
   */
  readonly project?:
    | string
    | undefined;
  /** Which branch. The refs/heads/ prefix is omitted. */
  readonly branch?:
    | string
    | undefined;
  /**
   * The gerrit assigned change number for this change.
   *
   * Example:
   *   https://chromium-review.googlesource.com/c/infra/turboci/proto/+/6990802/2
   *     -> 6990802
   */
  readonly changeNumber?:
    | string
    | undefined;
  /**
   * The latest patchset number for this change at the time of the request for this change information.
   * This should be equivalent to the RevisionInfo.patchset field for the latest revision.
   * Example:
   *   https://chromium-review.googlesource.com/c/infra/turboci/proto/+/6990802/2
   *     -> 2
   */
  readonly patchset?:
    | number
    | undefined;
  /** The status of the change. */
  readonly status?:
    | GerritChangeInfo_Status
    | undefined;
  /** The timestamp of when the change was created. */
  readonly creationTime?:
    | string
    | undefined;
  /**
   * Last time this change was modified.
   * This includes new comments, label changes, etc.
   */
  readonly lastModificationTime?:
    | string
    | undefined;
  /** The time when this change was submitted in gerrit. */
  readonly submittedTime?:
    | string
    | undefined;
  /** The commit ID of the current patch set of this change. */
  readonly currentRevision?:
    | string
    | undefined;
  /**
   * All patch sets of this change as of the time its metadata was retrieved from Gerrit,
   * if ALL_REVISIONS was specified when retrieving. Otherwise this contains only the
   * Revision corresponding to the current_revision.
   * This is stored as a map where the key is the commit ID and the value is the RevisionInfo.
   */
  readonly revisions: { [key: string]: RevisionInfo };
  /** The ChangeInfo.owner from Gerrit, representing the person who created the change. */
  readonly owner?:
    | AccountInfo
    | undefined;
  /**
   * The reviewers of this change as a map where the key is the reviewer state and the value
   * is a list of AccountInfos.
   * Possible reviewer states are "REVIEWER" and "CC".
   * "REVIEWER": Users with at least one non-zero vote on the change.
   * "CC": Users that were added to the change, but have not voted
   */
  readonly reviewers: { [key: string]: AccountInfos };
  /**
   * The label info associated with the change as a map where the key is the full name of the label
   * (e.g., "Code-Review", not "CR") and the value is the LabelInfo.
   */
  readonly labels: { [key: string]: LabelInfo };
  /**
   * The comments posted at the change-level. This does not include comments left at specific
   * lines within the changed files.
   */
  readonly messages: readonly ChangeMessageInfo[];
  /**
   * The Change-Id of the change.
   * Eg. "I8473b95934b5732ac55d26311a706c9c2bde9940"
   */
  readonly changeId?:
    | string
    | undefined;
  /** The topic to which this change belongs. */
  readonly topic?:
    | string
    | undefined;
  /**
   * Whether this change info was created for a local change.
   * Some clients may create a fake ChangeInfo for changes in their local workspace.
   * If true, this ChangeInfo is likely manually-created for local testing purposes so expect
   * many fields to be omitted.
   */
  readonly local?:
    | boolean
    | undefined;
  /** Whether the owner of the CL is a bot or not. */
  readonly isOwnerBot?: boolean | undefined;
}

/** Possible statuses for changes. */
export enum GerritChangeInfo_Status {
  /** STATUS_UNKNOWN - Unknown status. */
  STATUS_UNKNOWN = 0,
  /** STATUS_NEW - Change is in progress. */
  STATUS_NEW = 1,
  /** STATUS_MERGED - Change has been merged into branch. */
  STATUS_MERGED = 2,
  /** STATUS_ABANDONED - Change has been abandoned. */
  STATUS_ABANDONED = 3,
  /** STATUS_MERGE_CONFLICT - The change has a merge conflict. */
  STATUS_MERGE_CONFLICT = 4,
}

export function gerritChangeInfo_StatusFromJSON(object: any): GerritChangeInfo_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return GerritChangeInfo_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_NEW":
      return GerritChangeInfo_Status.STATUS_NEW;
    case 2:
    case "STATUS_MERGED":
      return GerritChangeInfo_Status.STATUS_MERGED;
    case 3:
    case "STATUS_ABANDONED":
      return GerritChangeInfo_Status.STATUS_ABANDONED;
    case 4:
    case "STATUS_MERGE_CONFLICT":
      return GerritChangeInfo_Status.STATUS_MERGE_CONFLICT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GerritChangeInfo_Status");
  }
}

export function gerritChangeInfo_StatusToJSON(object: GerritChangeInfo_Status): string {
  switch (object) {
    case GerritChangeInfo_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case GerritChangeInfo_Status.STATUS_NEW:
      return "STATUS_NEW";
    case GerritChangeInfo_Status.STATUS_MERGED:
      return "STATUS_MERGED";
    case GerritChangeInfo_Status.STATUS_ABANDONED:
      return "STATUS_ABANDONED";
    case GerritChangeInfo_Status.STATUS_MERGE_CONFLICT:
      return "STATUS_MERGE_CONFLICT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GerritChangeInfo_Status");
  }
}

export interface GerritChangeInfo_RevisionsEntry {
  readonly key: string;
  readonly value: RevisionInfo | undefined;
}

export interface GerritChangeInfo_ReviewersEntry {
  readonly key: string;
  readonly value: AccountInfos | undefined;
}

export interface GerritChangeInfo_LabelsEntry {
  readonly key: string;
  readonly value: LabelInfo | undefined;
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-accounts.html#account-info */
export interface AccountInfo {
  /** The numeric ID of the account. */
  readonly accountId?:
    | string
    | undefined;
  /** The full name of the user. */
  readonly name?:
    | string
    | undefined;
  /** The display name of the user. */
  readonly displayName?:
    | string
    | undefined;
  /** The email address the user prefers to be contacted through. */
  readonly email?:
    | string
    | undefined;
  /** The secondary emails of the user. */
  readonly secondaryEmails: readonly string[];
  /** The username of the user. */
  readonly username?:
    | string
    | undefined;
  /** Status message of the account. */
  readonly status?:
    | string
    | undefined;
  /** Whether the account is inactive. */
  readonly inactive?:
    | boolean
    | undefined;
  /** Whether the account is deleted. */
  readonly deleted?:
    | boolean
    | undefined;
  /** List of additional tags that this account has (e.g., SERVICE_USER). */
  readonly tags: readonly string[];
}

/** Wrapper for repeated AccountInfo */
export interface AccountInfos {
  /** Multiple AccountInfos. */
  readonly accounts: readonly AccountInfo[];
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#approval-info */
export interface ApprovalInfo {
  /** The account info of the user who made the approval. */
  readonly user?:
    | AccountInfo
    | undefined;
  /** The vote that the user has given for the label. */
  readonly value?:
    | number
    | undefined;
  /** The timestamp when the approval was made. */
  readonly date?:
    | string
    | undefined;
  /**
   * The value of the tag field from the ReviewInput that was set while posting the review,
   * if a tag was set. See more details in
   * https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#approval-info
   */
  readonly tag?:
    | string
    | undefined;
  /** If true, this vote was made after the change was submitted. */
  readonly postSubmit?: boolean | undefined;
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#change-message-info */
export interface ChangeMessageInfo {
  /** The ID of the message. */
  readonly id?:
    | string
    | undefined;
  /** Author of the message. Unset if written by the Gerrit system. */
  readonly author?:
    | AccountInfo
    | undefined;
  /** Real author of the message. Only set if the message was posted on behalf of another user. */
  readonly realAuthor?:
    | AccountInfo
    | undefined;
  /** The timestamp this message was posted. */
  readonly date?:
    | string
    | undefined;
  /**
   * The text left by the user or Gerrit system. Accounts are served as account IDs inlined in
   * the text as <GERRIT_ACCOUNT_18419>. All accounts, used in message, can be found in
   * accounts_in_message field.
   */
  readonly message?:
    | string
    | undefined;
  /** Accounts used in message. */
  readonly accountsInMessage: readonly AccountInfo[];
  /**
   * Value of the tag field from ReviewInput set while posting the review.
   * See "tag" field under https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#change-message-info
   */
  readonly tag?:
    | string
    | undefined;
  /** Which patchset (if any) generated this message. */
  readonly patchset?: number | undefined;
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#commit-info */
export interface CommitInfo {
  /** The commit ID. */
  readonly commitId?:
    | string
    | undefined;
  /** The parent commits of this commit. In each parent only the commit and subject fields are populated. */
  readonly parents: readonly CommitInfo[];
  /** The author of this commit. */
  readonly author?:
    | AccountInfo
    | undefined;
  /** The committer of this commit. */
  readonly committer?:
    | AccountInfo
    | undefined;
  /** The subject of the commit (header line of the commit message). */
  readonly subject?:
    | string
    | undefined;
  /** The commit message. */
  readonly message?: string | undefined;
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#file-info */
export interface FileInfo {
  /** The old file path. Only set if the file was renamed or copied. */
  readonly oldPath?:
    | string
    | undefined;
  /** The status of the file. */
  readonly status?:
    | FileInfo_Status
    | undefined;
  /** Number of inserted lines. */
  readonly linesInserted?:
    | number
    | undefined;
  /** Number of deleted lines. */
  readonly linesDeleted?: number | undefined;
}

/** Possible statuses for file changes. */
export enum FileInfo_Status {
  /** STATUS_UNKNOWN - Unknown status. */
  STATUS_UNKNOWN = 0,
  /** STATUS_ADDED - The file was added. */
  STATUS_ADDED = 1,
  /** STATUS_DELETED - The file was deleted. */
  STATUS_DELETED = 2,
  /** STATUS_MODIFIED - The file was modified. */
  STATUS_MODIFIED = 3,
  /** STATUS_RENAMED - The file was renamed. */
  STATUS_RENAMED = 4,
  /** STATUS_COPIED - The file was copied. */
  STATUS_COPIED = 5,
  /** STATUS_REWRITTEN - The file was rewritten. */
  STATUS_REWRITTEN = 6,
}

export function fileInfo_StatusFromJSON(object: any): FileInfo_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return FileInfo_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_ADDED":
      return FileInfo_Status.STATUS_ADDED;
    case 2:
    case "STATUS_DELETED":
      return FileInfo_Status.STATUS_DELETED;
    case 3:
    case "STATUS_MODIFIED":
      return FileInfo_Status.STATUS_MODIFIED;
    case 4:
    case "STATUS_RENAMED":
      return FileInfo_Status.STATUS_RENAMED;
    case 5:
    case "STATUS_COPIED":
      return FileInfo_Status.STATUS_COPIED;
    case 6:
    case "STATUS_REWRITTEN":
      return FileInfo_Status.STATUS_REWRITTEN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FileInfo_Status");
  }
}

export function fileInfo_StatusToJSON(object: FileInfo_Status): string {
  switch (object) {
    case FileInfo_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case FileInfo_Status.STATUS_ADDED:
      return "STATUS_ADDED";
    case FileInfo_Status.STATUS_DELETED:
      return "STATUS_DELETED";
    case FileInfo_Status.STATUS_MODIFIED:
      return "STATUS_MODIFIED";
    case FileInfo_Status.STATUS_RENAMED:
      return "STATUS_RENAMED";
    case FileInfo_Status.STATUS_COPIED:
      return "STATUS_COPIED";
    case FileInfo_Status.STATUS_REWRITTEN:
      return "STATUS_REWRITTEN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FileInfo_Status");
  }
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#label-info */
export interface LabelInfo {
  /** The description of the label. */
  readonly description?:
    | string
    | undefined;
  /** The voting value of the user who recommended/disliked this label. */
  readonly value?:
    | number
    | undefined;
  /** The default voting value for the label. */
  readonly defaultValue?:
    | number
    | undefined;
  /** List of all approvals for this label. */
  readonly all: readonly ApprovalInfo[];
  /**
   * A map of all values that are allowed for this label.
   * The map keys are the vote values (e.g., "-2", "-1", " 0", "+1", "+2")
   * and the map values are the descriptions.
   */
  readonly values: { [key: string]: string };
}

export interface LabelInfo_ValuesEntry {
  readonly key: string;
  readonly value: string;
}

/** Sourced from https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#revision-info */
export interface RevisionInfo {
  /** The kind of change for this revision. */
  readonly kind?:
    | RevisionInfo_Kind
    | undefined;
  /** The patch set number, or edit if the patch set is an edit. */
  readonly patchset?:
    | number
    | undefined;
  /** When the patchset was created. */
  readonly created?:
    | string
    | undefined;
  /** The uploader of the patchset. */
  readonly uploader?:
    | AccountInfo
    | undefined;
  /** The Git reference for the patchset. */
  readonly ref?:
    | string
    | undefined;
  /** The commit of the patchset. */
  readonly commit?:
    | CommitInfo
    | undefined;
  /**
   * The files of the patchset as a map where the key is the path to the file and
   * the value is the FileInfo.
   */
  readonly files: { [key: string]: FileInfo };
}

/**
 * Possible kinds of changes.
 * See https://gerrit-review.googlesource.com/Documentation/config-labels.html for more detailed
 * descriptions of each enum type.
 */
export enum RevisionInfo_Kind {
  /** KIND_UNKNOWN - Default value. */
  KIND_UNKNOWN = 0,
  /** KIND_REWORK - Rework change. */
  KIND_REWORK = 1,
  /** KIND_TRIVIAL_REBASE - Trivial rebase change. */
  KIND_TRIVIAL_REBASE = 2,
  /** KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE - Trivial rebase change with message update. */
  KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE = 3,
  /** KIND_MERGE_FIRST_PARENT_UPDATE - Parents changed. */
  KIND_MERGE_FIRST_PARENT_UPDATE = 4,
  /** KIND_NO_CODE_CHANGE - No code change (eg. commit message update). */
  KIND_NO_CODE_CHANGE = 5,
  /** KIND_NO_CHANGE - No change. */
  KIND_NO_CHANGE = 6,
}

export function revisionInfo_KindFromJSON(object: any): RevisionInfo_Kind {
  switch (object) {
    case 0:
    case "KIND_UNKNOWN":
      return RevisionInfo_Kind.KIND_UNKNOWN;
    case 1:
    case "KIND_REWORK":
      return RevisionInfo_Kind.KIND_REWORK;
    case 2:
    case "KIND_TRIVIAL_REBASE":
      return RevisionInfo_Kind.KIND_TRIVIAL_REBASE;
    case 3:
    case "KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE":
      return RevisionInfo_Kind.KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE;
    case 4:
    case "KIND_MERGE_FIRST_PARENT_UPDATE":
      return RevisionInfo_Kind.KIND_MERGE_FIRST_PARENT_UPDATE;
    case 5:
    case "KIND_NO_CODE_CHANGE":
      return RevisionInfo_Kind.KIND_NO_CODE_CHANGE;
    case 6:
    case "KIND_NO_CHANGE":
      return RevisionInfo_Kind.KIND_NO_CHANGE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RevisionInfo_Kind");
  }
}

export function revisionInfo_KindToJSON(object: RevisionInfo_Kind): string {
  switch (object) {
    case RevisionInfo_Kind.KIND_UNKNOWN:
      return "KIND_UNKNOWN";
    case RevisionInfo_Kind.KIND_REWORK:
      return "KIND_REWORK";
    case RevisionInfo_Kind.KIND_TRIVIAL_REBASE:
      return "KIND_TRIVIAL_REBASE";
    case RevisionInfo_Kind.KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE:
      return "KIND_TRIVIAL_REBASE_WITH_MESSAGE_UPDATE";
    case RevisionInfo_Kind.KIND_MERGE_FIRST_PARENT_UPDATE:
      return "KIND_MERGE_FIRST_PARENT_UPDATE";
    case RevisionInfo_Kind.KIND_NO_CODE_CHANGE:
      return "KIND_NO_CODE_CHANGE";
    case RevisionInfo_Kind.KIND_NO_CHANGE:
      return "KIND_NO_CHANGE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RevisionInfo_Kind");
  }
}

export interface RevisionInfo_FilesEntry {
  readonly key: string;
  readonly value: FileInfo | undefined;
}

function createBaseGerritChangeInfo(): GerritChangeInfo {
  return {
    host: undefined,
    project: undefined,
    branch: undefined,
    changeNumber: undefined,
    patchset: undefined,
    status: undefined,
    creationTime: undefined,
    lastModificationTime: undefined,
    submittedTime: undefined,
    currentRevision: undefined,
    revisions: {},
    owner: undefined,
    reviewers: {},
    labels: {},
    messages: [],
    changeId: undefined,
    topic: undefined,
    local: undefined,
    isOwnerBot: undefined,
  };
}

export const GerritChangeInfo: MessageFns<GerritChangeInfo> = {
  encode(message: GerritChangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== undefined) {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== undefined) {
      writer.uint32(18).string(message.project);
    }
    if (message.branch !== undefined) {
      writer.uint32(26).string(message.branch);
    }
    if (message.changeNumber !== undefined) {
      writer.uint32(32).int64(message.changeNumber);
    }
    if (message.patchset !== undefined) {
      writer.uint32(40).int32(message.patchset);
    }
    if (message.status !== undefined) {
      writer.uint32(48).int32(message.status);
    }
    if (message.creationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.creationTime), writer.uint32(58).fork()).join();
    }
    if (message.lastModificationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastModificationTime), writer.uint32(66).fork()).join();
    }
    if (message.submittedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submittedTime), writer.uint32(74).fork()).join();
    }
    if (message.currentRevision !== undefined) {
      writer.uint32(82).string(message.currentRevision);
    }
    Object.entries(message.revisions).forEach(([key, value]) => {
      GerritChangeInfo_RevisionsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.owner !== undefined) {
      AccountInfo.encode(message.owner, writer.uint32(98).fork()).join();
    }
    Object.entries(message.reviewers).forEach(([key, value]) => {
      GerritChangeInfo_ReviewersEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      GerritChangeInfo_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    for (const v of message.messages) {
      ChangeMessageInfo.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.changeId !== undefined) {
      writer.uint32(130).string(message.changeId);
    }
    if (message.topic !== undefined) {
      writer.uint32(138).string(message.topic);
    }
    if (message.local !== undefined) {
      writer.uint32(144).bool(message.local);
    }
    if (message.isOwnerBot !== undefined) {
      writer.uint32(152).bool(message.isOwnerBot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChangeInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.changeNumber = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.patchset = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.creationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastModificationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.submittedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currentRevision = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = GerritChangeInfo_RevisionsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.revisions[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.owner = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = GerritChangeInfo_ReviewersEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.reviewers[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = GerritChangeInfo_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.messages.push(ChangeMessageInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.changeId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.local = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isOwnerBot = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChangeInfo {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      project: isSet(object.project) ? globalThis.String(object.project) : undefined,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      changeNumber: isSet(object.changeNumber) ? globalThis.String(object.changeNumber) : undefined,
      patchset: isSet(object.patchset) ? globalThis.Number(object.patchset) : undefined,
      status: isSet(object.status) ? gerritChangeInfo_StatusFromJSON(object.status) : undefined,
      creationTime: isSet(object.creationTime) ? globalThis.String(object.creationTime) : undefined,
      lastModificationTime: isSet(object.lastModificationTime)
        ? globalThis.String(object.lastModificationTime)
        : undefined,
      submittedTime: isSet(object.submittedTime) ? globalThis.String(object.submittedTime) : undefined,
      currentRevision: isSet(object.currentRevision) ? globalThis.String(object.currentRevision) : undefined,
      revisions: isObject(object.revisions)
        ? Object.entries(object.revisions).reduce<{ [key: string]: RevisionInfo }>((acc, [key, value]) => {
          acc[key] = RevisionInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      owner: isSet(object.owner) ? AccountInfo.fromJSON(object.owner) : undefined,
      reviewers: isObject(object.reviewers)
        ? Object.entries(object.reviewers).reduce<{ [key: string]: AccountInfos }>((acc, [key, value]) => {
          acc[key] = AccountInfos.fromJSON(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: LabelInfo }>((acc, [key, value]) => {
          acc[key] = LabelInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChangeMessageInfo.fromJSON(e))
        : [],
      changeId: isSet(object.changeId) ? globalThis.String(object.changeId) : undefined,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : undefined,
      local: isSet(object.local) ? globalThis.Boolean(object.local) : undefined,
      isOwnerBot: isSet(object.isOwnerBot) ? globalThis.Boolean(object.isOwnerBot) : undefined,
    };
  },

  toJSON(message: GerritChangeInfo): unknown {
    const obj: any = {};
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.project !== undefined) {
      obj.project = message.project;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.changeNumber !== undefined) {
      obj.changeNumber = message.changeNumber;
    }
    if (message.patchset !== undefined) {
      obj.patchset = Math.round(message.patchset);
    }
    if (message.status !== undefined) {
      obj.status = gerritChangeInfo_StatusToJSON(message.status);
    }
    if (message.creationTime !== undefined) {
      obj.creationTime = message.creationTime;
    }
    if (message.lastModificationTime !== undefined) {
      obj.lastModificationTime = message.lastModificationTime;
    }
    if (message.submittedTime !== undefined) {
      obj.submittedTime = message.submittedTime;
    }
    if (message.currentRevision !== undefined) {
      obj.currentRevision = message.currentRevision;
    }
    if (message.revisions) {
      const entries = Object.entries(message.revisions);
      if (entries.length > 0) {
        obj.revisions = {};
        entries.forEach(([k, v]) => {
          obj.revisions[k] = RevisionInfo.toJSON(v);
        });
      }
    }
    if (message.owner !== undefined) {
      obj.owner = AccountInfo.toJSON(message.owner);
    }
    if (message.reviewers) {
      const entries = Object.entries(message.reviewers);
      if (entries.length > 0) {
        obj.reviewers = {};
        entries.forEach(([k, v]) => {
          obj.reviewers[k] = AccountInfos.toJSON(v);
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = LabelInfo.toJSON(v);
        });
      }
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChangeMessageInfo.toJSON(e));
    }
    if (message.changeId !== undefined) {
      obj.changeId = message.changeId;
    }
    if (message.topic !== undefined) {
      obj.topic = message.topic;
    }
    if (message.local !== undefined) {
      obj.local = message.local;
    }
    if (message.isOwnerBot !== undefined) {
      obj.isOwnerBot = message.isOwnerBot;
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChangeInfo>): GerritChangeInfo {
    return GerritChangeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChangeInfo>): GerritChangeInfo {
    const message = createBaseGerritChangeInfo() as any;
    message.host = object.host ?? undefined;
    message.project = object.project ?? undefined;
    message.branch = object.branch ?? undefined;
    message.changeNumber = object.changeNumber ?? undefined;
    message.patchset = object.patchset ?? undefined;
    message.status = object.status ?? undefined;
    message.creationTime = object.creationTime ?? undefined;
    message.lastModificationTime = object.lastModificationTime ?? undefined;
    message.submittedTime = object.submittedTime ?? undefined;
    message.currentRevision = object.currentRevision ?? undefined;
    message.revisions = Object.entries(object.revisions ?? {}).reduce<{ [key: string]: RevisionInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = RevisionInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.owner = (object.owner !== undefined && object.owner !== null)
      ? AccountInfo.fromPartial(object.owner)
      : undefined;
    message.reviewers = Object.entries(object.reviewers ?? {}).reduce<{ [key: string]: AccountInfos }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AccountInfos.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: LabelInfo }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = LabelInfo.fromPartial(value);
      }
      return acc;
    }, {});
    message.messages = object.messages?.map((e) => ChangeMessageInfo.fromPartial(e)) || [];
    message.changeId = object.changeId ?? undefined;
    message.topic = object.topic ?? undefined;
    message.local = object.local ?? undefined;
    message.isOwnerBot = object.isOwnerBot ?? undefined;
    return message;
  },
};

function createBaseGerritChangeInfo_RevisionsEntry(): GerritChangeInfo_RevisionsEntry {
  return { key: "", value: undefined };
}

export const GerritChangeInfo_RevisionsEntry: MessageFns<GerritChangeInfo_RevisionsEntry> = {
  encode(message: GerritChangeInfo_RevisionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RevisionInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChangeInfo_RevisionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChangeInfo_RevisionsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = RevisionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChangeInfo_RevisionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RevisionInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GerritChangeInfo_RevisionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RevisionInfo.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChangeInfo_RevisionsEntry>): GerritChangeInfo_RevisionsEntry {
    return GerritChangeInfo_RevisionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChangeInfo_RevisionsEntry>): GerritChangeInfo_RevisionsEntry {
    const message = createBaseGerritChangeInfo_RevisionsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RevisionInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGerritChangeInfo_ReviewersEntry(): GerritChangeInfo_ReviewersEntry {
  return { key: "", value: undefined };
}

export const GerritChangeInfo_ReviewersEntry: MessageFns<GerritChangeInfo_ReviewersEntry> = {
  encode(message: GerritChangeInfo_ReviewersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AccountInfos.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChangeInfo_ReviewersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChangeInfo_ReviewersEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = AccountInfos.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChangeInfo_ReviewersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AccountInfos.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GerritChangeInfo_ReviewersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AccountInfos.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChangeInfo_ReviewersEntry>): GerritChangeInfo_ReviewersEntry {
    return GerritChangeInfo_ReviewersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChangeInfo_ReviewersEntry>): GerritChangeInfo_ReviewersEntry {
    const message = createBaseGerritChangeInfo_ReviewersEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AccountInfos.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGerritChangeInfo_LabelsEntry(): GerritChangeInfo_LabelsEntry {
  return { key: "", value: undefined };
}

export const GerritChangeInfo_LabelsEntry: MessageFns<GerritChangeInfo_LabelsEntry> = {
  encode(message: GerritChangeInfo_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LabelInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChangeInfo_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChangeInfo_LabelsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LabelInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChangeInfo_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LabelInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GerritChangeInfo_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LabelInfo.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChangeInfo_LabelsEntry>): GerritChangeInfo_LabelsEntry {
    return GerritChangeInfo_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChangeInfo_LabelsEntry>): GerritChangeInfo_LabelsEntry {
    const message = createBaseGerritChangeInfo_LabelsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LabelInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAccountInfo(): AccountInfo {
  return {
    accountId: undefined,
    name: undefined,
    displayName: undefined,
    email: undefined,
    secondaryEmails: [],
    username: undefined,
    status: undefined,
    inactive: undefined,
    deleted: undefined,
    tags: [],
  };
}

export const AccountInfo: MessageFns<AccountInfo> = {
  encode(message: AccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== undefined) {
      writer.uint32(8).int64(message.accountId);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.displayName !== undefined) {
      writer.uint32(26).string(message.displayName);
    }
    if (message.email !== undefined) {
      writer.uint32(34).string(message.email);
    }
    for (const v of message.secondaryEmails) {
      writer.uint32(42).string(v!);
    }
    if (message.username !== undefined) {
      writer.uint32(50).string(message.username);
    }
    if (message.status !== undefined) {
      writer.uint32(58).string(message.status);
    }
    if (message.inactive !== undefined) {
      writer.uint32(64).bool(message.inactive);
    }
    if (message.deleted !== undefined) {
      writer.uint32(72).bool(message.deleted);
    }
    for (const v of message.tags) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secondaryEmails.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.inactive = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      secondaryEmails: globalThis.Array.isArray(object?.secondaryEmails)
        ? object.secondaryEmails.map((e: any) => globalThis.String(e))
        : [],
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      inactive: isSet(object.inactive) ? globalThis.Boolean(object.inactive) : undefined,
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AccountInfo): unknown {
    const obj: any = {};
    if (message.accountId !== undefined) {
      obj.accountId = message.accountId;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.secondaryEmails?.length) {
      obj.secondaryEmails = message.secondaryEmails;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.inactive !== undefined) {
      obj.inactive = message.inactive;
    }
    if (message.deleted !== undefined) {
      obj.deleted = message.deleted;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountInfo>): AccountInfo {
    return AccountInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountInfo>): AccountInfo {
    const message = createBaseAccountInfo() as any;
    message.accountId = object.accountId ?? undefined;
    message.name = object.name ?? undefined;
    message.displayName = object.displayName ?? undefined;
    message.email = object.email ?? undefined;
    message.secondaryEmails = object.secondaryEmails?.map((e) => e) || [];
    message.username = object.username ?? undefined;
    message.status = object.status ?? undefined;
    message.inactive = object.inactive ?? undefined;
    message.deleted = object.deleted ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseAccountInfos(): AccountInfos {
  return { accounts: [] };
}

export const AccountInfos: MessageFns<AccountInfos> = {
  encode(message: AccountInfos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      AccountInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountInfos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountInfos() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(AccountInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountInfos {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => AccountInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountInfos): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => AccountInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccountInfos>): AccountInfos {
    return AccountInfos.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountInfos>): AccountInfos {
    const message = createBaseAccountInfos() as any;
    message.accounts = object.accounts?.map((e) => AccountInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseApprovalInfo(): ApprovalInfo {
  return { user: undefined, value: undefined, date: undefined, tag: undefined, postSubmit: undefined };
}

export const ApprovalInfo: MessageFns<ApprovalInfo> = {
  encode(message: ApprovalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      AccountInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      writer.uint32(16).int32(message.value);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(26).fork()).join();
    }
    if (message.tag !== undefined) {
      writer.uint32(34).string(message.tag);
    }
    if (message.postSubmit !== undefined) {
      writer.uint32(40).bool(message.postSubmit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovalInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.postSubmit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovalInfo {
    return {
      user: isSet(object.user) ? AccountInfo.fromJSON(object.user) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : undefined,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      postSubmit: isSet(object.postSubmit) ? globalThis.Boolean(object.postSubmit) : undefined,
    };
  },

  toJSON(message: ApprovalInfo): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = AccountInfo.toJSON(message.user);
    }
    if (message.value !== undefined) {
      obj.value = Math.round(message.value);
    }
    if (message.date !== undefined) {
      obj.date = message.date;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.postSubmit !== undefined) {
      obj.postSubmit = message.postSubmit;
    }
    return obj;
  },

  create(base?: DeepPartial<ApprovalInfo>): ApprovalInfo {
    return ApprovalInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApprovalInfo>): ApprovalInfo {
    const message = createBaseApprovalInfo() as any;
    message.user = (object.user !== undefined && object.user !== null)
      ? AccountInfo.fromPartial(object.user)
      : undefined;
    message.value = object.value ?? undefined;
    message.date = object.date ?? undefined;
    message.tag = object.tag ?? undefined;
    message.postSubmit = object.postSubmit ?? undefined;
    return message;
  },
};

function createBaseChangeMessageInfo(): ChangeMessageInfo {
  return {
    id: undefined,
    author: undefined,
    realAuthor: undefined,
    date: undefined,
    message: undefined,
    accountsInMessage: [],
    tag: undefined,
    patchset: undefined,
  };
}

export const ChangeMessageInfo: MessageFns<ChangeMessageInfo> = {
  encode(message: ChangeMessageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.author !== undefined) {
      AccountInfo.encode(message.author, writer.uint32(18).fork()).join();
    }
    if (message.realAuthor !== undefined) {
      AccountInfo.encode(message.realAuthor, writer.uint32(26).fork()).join();
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(34).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    for (const v of message.accountsInMessage) {
      AccountInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.tag !== undefined) {
      writer.uint32(58).string(message.tag);
    }
    if (message.patchset !== undefined) {
      writer.uint32(64).int32(message.patchset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeMessageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeMessageInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.author = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.realAuthor = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accountsInMessage.push(AccountInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.patchset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeMessageInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      author: isSet(object.author) ? AccountInfo.fromJSON(object.author) : undefined,
      realAuthor: isSet(object.realAuthor) ? AccountInfo.fromJSON(object.realAuthor) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      accountsInMessage: globalThis.Array.isArray(object?.accountsInMessage)
        ? object.accountsInMessage.map((e: any) => AccountInfo.fromJSON(e))
        : [],
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      patchset: isSet(object.patchset) ? globalThis.Number(object.patchset) : undefined,
    };
  },

  toJSON(message: ChangeMessageInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.author !== undefined) {
      obj.author = AccountInfo.toJSON(message.author);
    }
    if (message.realAuthor !== undefined) {
      obj.realAuthor = AccountInfo.toJSON(message.realAuthor);
    }
    if (message.date !== undefined) {
      obj.date = message.date;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.accountsInMessage?.length) {
      obj.accountsInMessage = message.accountsInMessage.map((e) => AccountInfo.toJSON(e));
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.patchset !== undefined) {
      obj.patchset = Math.round(message.patchset);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeMessageInfo>): ChangeMessageInfo {
    return ChangeMessageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeMessageInfo>): ChangeMessageInfo {
    const message = createBaseChangeMessageInfo() as any;
    message.id = object.id ?? undefined;
    message.author = (object.author !== undefined && object.author !== null)
      ? AccountInfo.fromPartial(object.author)
      : undefined;
    message.realAuthor = (object.realAuthor !== undefined && object.realAuthor !== null)
      ? AccountInfo.fromPartial(object.realAuthor)
      : undefined;
    message.date = object.date ?? undefined;
    message.message = object.message ?? undefined;
    message.accountsInMessage = object.accountsInMessage?.map((e) => AccountInfo.fromPartial(e)) || [];
    message.tag = object.tag ?? undefined;
    message.patchset = object.patchset ?? undefined;
    return message;
  },
};

function createBaseCommitInfo(): CommitInfo {
  return {
    commitId: undefined,
    parents: [],
    author: undefined,
    committer: undefined,
    subject: undefined,
    message: undefined,
  };
}

export const CommitInfo: MessageFns<CommitInfo> = {
  encode(message: CommitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commitId !== undefined) {
      writer.uint32(10).string(message.commitId);
    }
    for (const v of message.parents) {
      CommitInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.author !== undefined) {
      AccountInfo.encode(message.author, writer.uint32(26).fork()).join();
    }
    if (message.committer !== undefined) {
      AccountInfo.encode(message.committer, writer.uint32(34).fork()).join();
    }
    if (message.subject !== undefined) {
      writer.uint32(42).string(message.subject);
    }
    if (message.message !== undefined) {
      writer.uint32(50).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parents.push(CommitInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.author = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.committer = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitInfo {
    return {
      commitId: isSet(object.commitId) ? globalThis.String(object.commitId) : undefined,
      parents: globalThis.Array.isArray(object?.parents) ? object.parents.map((e: any) => CommitInfo.fromJSON(e)) : [],
      author: isSet(object.author) ? AccountInfo.fromJSON(object.author) : undefined,
      committer: isSet(object.committer) ? AccountInfo.fromJSON(object.committer) : undefined,
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: CommitInfo): unknown {
    const obj: any = {};
    if (message.commitId !== undefined) {
      obj.commitId = message.commitId;
    }
    if (message.parents?.length) {
      obj.parents = message.parents.map((e) => CommitInfo.toJSON(e));
    }
    if (message.author !== undefined) {
      obj.author = AccountInfo.toJSON(message.author);
    }
    if (message.committer !== undefined) {
      obj.committer = AccountInfo.toJSON(message.committer);
    }
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CommitInfo>): CommitInfo {
    return CommitInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitInfo>): CommitInfo {
    const message = createBaseCommitInfo() as any;
    message.commitId = object.commitId ?? undefined;
    message.parents = object.parents?.map((e) => CommitInfo.fromPartial(e)) || [];
    message.author = (object.author !== undefined && object.author !== null)
      ? AccountInfo.fromPartial(object.author)
      : undefined;
    message.committer = (object.committer !== undefined && object.committer !== null)
      ? AccountInfo.fromPartial(object.committer)
      : undefined;
    message.subject = object.subject ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseFileInfo(): FileInfo {
  return { oldPath: undefined, status: undefined, linesInserted: undefined, linesDeleted: undefined };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldPath !== undefined) {
      writer.uint32(10).string(message.oldPath);
    }
    if (message.status !== undefined) {
      writer.uint32(16).int32(message.status);
    }
    if (message.linesInserted !== undefined) {
      writer.uint32(24).int32(message.linesInserted);
    }
    if (message.linesDeleted !== undefined) {
      writer.uint32(32).int32(message.linesDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.linesInserted = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linesDeleted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      oldPath: isSet(object.oldPath) ? globalThis.String(object.oldPath) : undefined,
      status: isSet(object.status) ? fileInfo_StatusFromJSON(object.status) : undefined,
      linesInserted: isSet(object.linesInserted) ? globalThis.Number(object.linesInserted) : undefined,
      linesDeleted: isSet(object.linesDeleted) ? globalThis.Number(object.linesDeleted) : undefined,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.oldPath !== undefined) {
      obj.oldPath = message.oldPath;
    }
    if (message.status !== undefined) {
      obj.status = fileInfo_StatusToJSON(message.status);
    }
    if (message.linesInserted !== undefined) {
      obj.linesInserted = Math.round(message.linesInserted);
    }
    if (message.linesDeleted !== undefined) {
      obj.linesDeleted = Math.round(message.linesDeleted);
    }
    return obj;
  },

  create(base?: DeepPartial<FileInfo>): FileInfo {
    return FileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInfo>): FileInfo {
    const message = createBaseFileInfo() as any;
    message.oldPath = object.oldPath ?? undefined;
    message.status = object.status ?? undefined;
    message.linesInserted = object.linesInserted ?? undefined;
    message.linesDeleted = object.linesDeleted ?? undefined;
    return message;
  },
};

function createBaseLabelInfo(): LabelInfo {
  return { description: undefined, value: undefined, defaultValue: undefined, all: [], values: {} };
}

export const LabelInfo: MessageFns<LabelInfo> = {
  encode(message: LabelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    if (message.value !== undefined) {
      writer.uint32(16).int32(message.value);
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(24).int32(message.defaultValue);
    }
    for (const v of message.all) {
      ApprovalInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.values).forEach(([key, value]) => {
      LabelInfo_ValuesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defaultValue = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.all.push(ApprovalInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = LabelInfo_ValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.values[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelInfo {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
      defaultValue: isSet(object.defaultValue) ? globalThis.Number(object.defaultValue) : undefined,
      all: globalThis.Array.isArray(object?.all) ? object.all.map((e: any) => ApprovalInfo.fromJSON(e)) : [],
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LabelInfo): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.value !== undefined) {
      obj.value = Math.round(message.value);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = Math.round(message.defaultValue);
    }
    if (message.all?.length) {
      obj.all = message.all.map((e) => ApprovalInfo.toJSON(e));
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<LabelInfo>): LabelInfo {
    return LabelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelInfo>): LabelInfo {
    const message = createBaseLabelInfo() as any;
    message.description = object.description ?? undefined;
    message.value = object.value ?? undefined;
    message.defaultValue = object.defaultValue ?? undefined;
    message.all = object.all?.map((e) => ApprovalInfo.fromPartial(e)) || [];
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseLabelInfo_ValuesEntry(): LabelInfo_ValuesEntry {
  return { key: "", value: "" };
}

export const LabelInfo_ValuesEntry: MessageFns<LabelInfo_ValuesEntry> = {
  encode(message: LabelInfo_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelInfo_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelInfo_ValuesEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelInfo_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LabelInfo_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LabelInfo_ValuesEntry>): LabelInfo_ValuesEntry {
    return LabelInfo_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelInfo_ValuesEntry>): LabelInfo_ValuesEntry {
    const message = createBaseLabelInfo_ValuesEntry() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRevisionInfo(): RevisionInfo {
  return {
    kind: undefined,
    patchset: undefined,
    created: undefined,
    uploader: undefined,
    ref: undefined,
    commit: undefined,
    files: {},
  };
}

export const RevisionInfo: MessageFns<RevisionInfo> = {
  encode(message: RevisionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== undefined) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.patchset !== undefined) {
      writer.uint32(16).int32(message.patchset);
    }
    if (message.created !== undefined) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(26).fork()).join();
    }
    if (message.uploader !== undefined) {
      AccountInfo.encode(message.uploader, writer.uint32(34).fork()).join();
    }
    if (message.ref !== undefined) {
      writer.uint32(42).string(message.ref);
    }
    if (message.commit !== undefined) {
      CommitInfo.encode(message.commit, writer.uint32(50).fork()).join();
    }
    Object.entries(message.files).forEach(([key, value]) => {
      RevisionInfo_FilesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevisionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevisionInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.patchset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uploader = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.commit = CommitInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = RevisionInfo_FilesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.files[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevisionInfo {
    return {
      kind: isSet(object.kind) ? revisionInfo_KindFromJSON(object.kind) : undefined,
      patchset: isSet(object.patchset) ? globalThis.Number(object.patchset) : undefined,
      created: isSet(object.created) ? globalThis.String(object.created) : undefined,
      uploader: isSet(object.uploader) ? AccountInfo.fromJSON(object.uploader) : undefined,
      ref: isSet(object.ref) ? globalThis.String(object.ref) : undefined,
      commit: isSet(object.commit) ? CommitInfo.fromJSON(object.commit) : undefined,
      files: isObject(object.files)
        ? Object.entries(object.files).reduce<{ [key: string]: FileInfo }>((acc, [key, value]) => {
          acc[key] = FileInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RevisionInfo): unknown {
    const obj: any = {};
    if (message.kind !== undefined) {
      obj.kind = revisionInfo_KindToJSON(message.kind);
    }
    if (message.patchset !== undefined) {
      obj.patchset = Math.round(message.patchset);
    }
    if (message.created !== undefined) {
      obj.created = message.created;
    }
    if (message.uploader !== undefined) {
      obj.uploader = AccountInfo.toJSON(message.uploader);
    }
    if (message.ref !== undefined) {
      obj.ref = message.ref;
    }
    if (message.commit !== undefined) {
      obj.commit = CommitInfo.toJSON(message.commit);
    }
    if (message.files) {
      const entries = Object.entries(message.files);
      if (entries.length > 0) {
        obj.files = {};
        entries.forEach(([k, v]) => {
          obj.files[k] = FileInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RevisionInfo>): RevisionInfo {
    return RevisionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevisionInfo>): RevisionInfo {
    const message = createBaseRevisionInfo() as any;
    message.kind = object.kind ?? undefined;
    message.patchset = object.patchset ?? undefined;
    message.created = object.created ?? undefined;
    message.uploader = (object.uploader !== undefined && object.uploader !== null)
      ? AccountInfo.fromPartial(object.uploader)
      : undefined;
    message.ref = object.ref ?? undefined;
    message.commit = (object.commit !== undefined && object.commit !== null)
      ? CommitInfo.fromPartial(object.commit)
      : undefined;
    message.files = Object.entries(object.files ?? {}).reduce<{ [key: string]: FileInfo }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = FileInfo.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRevisionInfo_FilesEntry(): RevisionInfo_FilesEntry {
  return { key: "", value: undefined };
}

export const RevisionInfo_FilesEntry: MessageFns<RevisionInfo_FilesEntry> = {
  encode(message: RevisionInfo_FilesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FileInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevisionInfo_FilesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevisionInfo_FilesEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FileInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevisionInfo_FilesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FileInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RevisionInfo_FilesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FileInfo.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RevisionInfo_FilesEntry>): RevisionInfo_FilesEntry {
    return RevisionInfo_FilesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevisionInfo_FilesEntry>): RevisionInfo_FilesEntry {
    const message = createBaseRevisionInfo_FilesEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FileInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
