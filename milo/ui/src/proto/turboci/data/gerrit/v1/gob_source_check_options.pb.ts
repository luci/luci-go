// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/data/gerrit/v1/gob_source_check_options.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "turboci.data.gerrit.v1";

/**
 * GobSourceCheckOptions provides instructions on how to checkout a GoB source.
 * 1. Checkout the pinned revisions of all repos referenced in the PinnedRepoMounts.
 * 2. Apply zero or more repo-level (mount) overrides to checkout revisions different from
 *    the pinned manifest if needed.
 * 3. Apply zero or more CLs on top of the base.
 */
export interface GobSourceCheckOptions {
  /**
   * A list of Gerrit changes relevant to this run.
   * Essentially just the gerrit host, change number and patchset.
   * Required for presubmit workflows, must not be set in postsubmit where we're building
   * an already committed source.
   *
   * Sorted in the order in which the CLs should be patched, with the first CL in the list
   * being the first to be patched.
   *
   * For changes which modify the superproject/manifest, these should be patched on to the
   * top-level superproject first before applying any of the mount overrides to ensure
   * the child repos are synced in accordance with the manifest changes.
   */
  readonly gerritChanges: readonly GobSourceCheckOptions_GerritChange[];
  /**
   * A "base" checkout state on which we apply changes.
   * For a postsubmit workflow, this just represents the committed source we want to build
   * and likely won't have any additional changes to apply.
   *
   * If the original input options (e.g. for presubmit workflow) did not set a base_pinned_repos,
   * it will be populated by a CheckEdit once the SourceCheck is processed.
   * The one exception is for Android presubmit workflows, where we potentially select different
   * reference builds for different build targets and we want to avoid duplicating the ChangeInfos
   * (which can be be very large for merge commits) by making separate Source Checks for each build
   * target. In those cases, we will store the build_id for the selected reference build in the
   * Build Check, and any Stages looking to understand the source code being referenced will need
   * to understand that relationship and pull the reference build_id from the Build Check and then
   * use that to get the manifest it used, to combine with the info in the Source Check.
   */
  readonly basePinnedRepos?: GobSourceCheckOptions_PinnedRepoMounts | undefined;
}

/** Information to reference a Gerrit change at a specific patchset. */
export interface GobSourceCheckOptions_GerritChange {
  /**
   * Which Gerrit instance this change is hosted on. This should not include suffixes or prefixes
   * outside of the actual "host" name.
   * Eg. Use "chromium", NOT "chromium-review" or "chromium-review.git.corp.google.com"
   */
  readonly hostname?:
    | string
    | undefined;
  /** Gerrit Change number, as an integer (e.g. 215798). */
  readonly changeNumber?:
    | string
    | undefined;
  /** Gerrit patchset number, as an integer. */
  readonly patchset?:
    | number
    | undefined;
  /**
   * A list of paths to local repos ("mounts") where this change should be applied to.
   * This is needed to support cases where there may be different versions of the
   * same remote repo checked out, and a change should only be applied to a specific
   * version. If not provided, the change will be applied to all mounts of the CL's repo.
   *
   * The order of GerritChanges also controls the patching order for each mount.
   * This means that the patching order is the same for every repo. If you have a use case
   * that requires a different order per repo, reach out to the Turbo CI team by filing a
   * go/turbo-ci-bug.
   */
  readonly mountsToApply: readonly string[];
}

/**
 * References a single group of mounts with all repo refs pinned. This can be a superproject
 * commit, a commit from a branch containing a manifest, or a list of root-level projects.
 *
 * You can also specify per-mount commits that override those in the commit via either inline
 * overrides or a reference to pinned manifest metadata stored in Android's manifest
 * store service.
 */
export interface GobSourceCheckOptions_PinnedRepoMounts {
  /**
   * This is the commit for a project which may or may not be a superproject that contain other
   * projects. If it is a superproject, it could have pinned revisions or floating refs
   * (which will then be pinned by mount_overrides) for all subprojects.
   *
   * If you have multiple root-level projects to checkout, use multiple SourceChecks.
   */
  readonly projectCommit?:
    | GobSourceCheckOptions_PinnedRepoMounts_GitCommit
    | undefined;
  /** Commit for a manifest with the path to the manifest file. */
  readonly manifestCommit?:
    | GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit
    | undefined;
  /**
   * Per-mount overrides for the revisions listed by the superproject/manifest.
   * Used if a workflow needs to check out a different revision than what is pinned
   * by the superproject/manifest, or to specify pins if the manifest specifies
   * branches rather than pinned commits. Could be used to specify per-repo commits
   * without specifying a manifest or superproject, though we're not aware of any
   * PDEIO workflows that currently need this.
   *
   * Order matters here. Overrides will be performed from first to last index.
   * If you need an override to happen before another, order them appropriately.
   * If your ordering becomes too complex to represent here, talk to the CIC team.
   *
   * An example of an override use case that does not work well here is overriding
   * submodules nested within other submodules. If the parent submodule commit is
   * overridden, we would need to re-evaluate its child submodules and potentially
   * override them again. We do not anticipate a use case for this today, but if you
   * have one, talk to the CIC team.
   */
  readonly mountOverrides: readonly GobSourceCheckOptions_PinnedRepoMounts_MountOverride[];
}

/** References a landed Git commit. */
export interface GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
  /**
   * GoB host without the ".googlesource.com" hostname suffix as the suffix may
   * be different depending on how it's accessed (eg. ".git.corp.google.com")
   * while still referring to the same repo.
   */
  readonly host?:
    | string
    | undefined;
  /** Repository name on the host, e.g. "chromium/src". */
  readonly project?:
    | string
    | undefined;
  /** Commit ID (eg. HEX SHA1). */
  readonly id?:
    | string
    | undefined;
  /**
   * Commit ref, e.g. "refs/heads/main".
   * NOT a branch name: if specified, MUST start with "refs/".
   * If no id is set, the referenced commit is HEAD on the ref.
   * If both ref and id are set, the commit id specifies which commit to use, and the
   * ref is simply informative to describe which branch the commit is found on.
   * If id is set and ref is not, this means to use the commit ID on the branch whose
   * ref is in the manifest.
   */
  readonly ref?: string | undefined;
}

/**
 * Commit for a manifest with the path to the manifest file. This manifest may be
 * pinned (all mounts referencing a fixed commit), or it may be unpinned (some mounts
 * referencing a branch ref) in which case the per-repo commits need to be provided
 * via mount_overrides.
 */
export interface GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
  /** The git commit for the manifest. */
  readonly commit?:
    | GobSourceCheckOptions_PinnedRepoMounts_GitCommit
    | undefined;
  /** Path to the manifest file within the repo for the given commit. */
  readonly path?: string | undefined;
}

/** Used to override a repo checkout on disk (mount) to a specific commit ID. */
export interface GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
  /** This should point to the commit ID you want to override with. */
  readonly override?:
    | GobSourceCheckOptions_PinnedRepoMounts_GitCommit
    | undefined;
  /** The local path to the repo checkout you want to override. */
  readonly mount?: string | undefined;
}

function createBaseGobSourceCheckOptions(): GobSourceCheckOptions {
  return { gerritChanges: [], basePinnedRepos: undefined };
}

export const GobSourceCheckOptions: MessageFns<GobSourceCheckOptions> = {
  encode(message: GobSourceCheckOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gerritChanges) {
      GobSourceCheckOptions_GerritChange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.basePinnedRepos !== undefined) {
      GobSourceCheckOptions_PinnedRepoMounts.encode(message.basePinnedRepos, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gerritChanges.push(GobSourceCheckOptions_GerritChange.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.basePinnedRepos = GobSourceCheckOptions_PinnedRepoMounts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions {
    return {
      gerritChanges: globalThis.Array.isArray(object?.gerritChanges)
        ? object.gerritChanges.map((e: any) => GobSourceCheckOptions_GerritChange.fromJSON(e))
        : [],
      basePinnedRepos: isSet(object.basePinnedRepos)
        ? GobSourceCheckOptions_PinnedRepoMounts.fromJSON(object.basePinnedRepos)
        : undefined,
    };
  },

  toJSON(message: GobSourceCheckOptions): unknown {
    const obj: any = {};
    if (message.gerritChanges?.length) {
      obj.gerritChanges = message.gerritChanges.map((e) => GobSourceCheckOptions_GerritChange.toJSON(e));
    }
    if (message.basePinnedRepos !== undefined) {
      obj.basePinnedRepos = GobSourceCheckOptions_PinnedRepoMounts.toJSON(message.basePinnedRepos);
    }
    return obj;
  },

  create(base?: DeepPartial<GobSourceCheckOptions>): GobSourceCheckOptions {
    return GobSourceCheckOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GobSourceCheckOptions>): GobSourceCheckOptions {
    const message = createBaseGobSourceCheckOptions() as any;
    message.gerritChanges = object.gerritChanges?.map((e) => GobSourceCheckOptions_GerritChange.fromPartial(e)) || [];
    message.basePinnedRepos = (object.basePinnedRepos !== undefined && object.basePinnedRepos !== null)
      ? GobSourceCheckOptions_PinnedRepoMounts.fromPartial(object.basePinnedRepos)
      : undefined;
    return message;
  },
};

function createBaseGobSourceCheckOptions_GerritChange(): GobSourceCheckOptions_GerritChange {
  return { hostname: undefined, changeNumber: undefined, patchset: undefined, mountsToApply: [] };
}

export const GobSourceCheckOptions_GerritChange: MessageFns<GobSourceCheckOptions_GerritChange> = {
  encode(message: GobSourceCheckOptions_GerritChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== undefined) {
      writer.uint32(10).string(message.hostname);
    }
    if (message.changeNumber !== undefined) {
      writer.uint32(16).int64(message.changeNumber);
    }
    if (message.patchset !== undefined) {
      writer.uint32(24).int32(message.patchset);
    }
    for (const v of message.mountsToApply) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions_GerritChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions_GerritChange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.changeNumber = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patchset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mountsToApply.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions_GerritChange {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      changeNumber: isSet(object.changeNumber) ? globalThis.String(object.changeNumber) : undefined,
      patchset: isSet(object.patchset) ? globalThis.Number(object.patchset) : undefined,
      mountsToApply: globalThis.Array.isArray(object?.mountsToApply)
        ? object.mountsToApply.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GobSourceCheckOptions_GerritChange): unknown {
    const obj: any = {};
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.changeNumber !== undefined) {
      obj.changeNumber = message.changeNumber;
    }
    if (message.patchset !== undefined) {
      obj.patchset = Math.round(message.patchset);
    }
    if (message.mountsToApply?.length) {
      obj.mountsToApply = message.mountsToApply;
    }
    return obj;
  },

  create(base?: DeepPartial<GobSourceCheckOptions_GerritChange>): GobSourceCheckOptions_GerritChange {
    return GobSourceCheckOptions_GerritChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GobSourceCheckOptions_GerritChange>): GobSourceCheckOptions_GerritChange {
    const message = createBaseGobSourceCheckOptions_GerritChange() as any;
    message.hostname = object.hostname ?? undefined;
    message.changeNumber = object.changeNumber ?? undefined;
    message.patchset = object.patchset ?? undefined;
    message.mountsToApply = object.mountsToApply?.map((e) => e) || [];
    return message;
  },
};

function createBaseGobSourceCheckOptions_PinnedRepoMounts(): GobSourceCheckOptions_PinnedRepoMounts {
  return { projectCommit: undefined, manifestCommit: undefined, mountOverrides: [] };
}

export const GobSourceCheckOptions_PinnedRepoMounts: MessageFns<GobSourceCheckOptions_PinnedRepoMounts> = {
  encode(message: GobSourceCheckOptions_PinnedRepoMounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectCommit !== undefined) {
      GobSourceCheckOptions_PinnedRepoMounts_GitCommit.encode(message.projectCommit, writer.uint32(10).fork()).join();
    }
    if (message.manifestCommit !== undefined) {
      GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.encode(message.manifestCommit, writer.uint32(18).fork())
        .join();
    }
    for (const v of message.mountOverrides) {
      GobSourceCheckOptions_PinnedRepoMounts_MountOverride.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions_PinnedRepoMounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectCommit = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.manifestCommit = GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mountOverrides.push(
            GobSourceCheckOptions_PinnedRepoMounts_MountOverride.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions_PinnedRepoMounts {
    return {
      projectCommit: isSet(object.projectCommit)
        ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromJSON(object.projectCommit)
        : undefined,
      manifestCommit: isSet(object.manifestCommit)
        ? GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.fromJSON(object.manifestCommit)
        : undefined,
      mountOverrides: globalThis.Array.isArray(object?.mountOverrides)
        ? object.mountOverrides.map((e: any) => GobSourceCheckOptions_PinnedRepoMounts_MountOverride.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GobSourceCheckOptions_PinnedRepoMounts): unknown {
    const obj: any = {};
    if (message.projectCommit !== undefined) {
      obj.projectCommit = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.toJSON(message.projectCommit);
    }
    if (message.manifestCommit !== undefined) {
      obj.manifestCommit = GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.toJSON(message.manifestCommit);
    }
    if (message.mountOverrides?.length) {
      obj.mountOverrides = message.mountOverrides.map((e) =>
        GobSourceCheckOptions_PinnedRepoMounts_MountOverride.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts>): GobSourceCheckOptions_PinnedRepoMounts {
    return GobSourceCheckOptions_PinnedRepoMounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts>): GobSourceCheckOptions_PinnedRepoMounts {
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts() as any;
    message.projectCommit = (object.projectCommit !== undefined && object.projectCommit !== null)
      ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromPartial(object.projectCommit)
      : undefined;
    message.manifestCommit = (object.manifestCommit !== undefined && object.manifestCommit !== null)
      ? GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.fromPartial(object.manifestCommit)
      : undefined;
    message.mountOverrides =
      object.mountOverrides?.map((e) => GobSourceCheckOptions_PinnedRepoMounts_MountOverride.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGobSourceCheckOptions_PinnedRepoMounts_GitCommit(): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
  return { host: undefined, project: undefined, id: undefined, ref: undefined };
}

export const GobSourceCheckOptions_PinnedRepoMounts_GitCommit: MessageFns<
  GobSourceCheckOptions_PinnedRepoMounts_GitCommit
> = {
  encode(
    message: GobSourceCheckOptions_PinnedRepoMounts_GitCommit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.host !== undefined) {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== undefined) {
      writer.uint32(18).string(message.project);
    }
    if (message.id !== undefined) {
      writer.uint32(26).string(message.id);
    }
    if (message.ref !== undefined) {
      writer.uint32(34).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_GitCommit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      project: isSet(object.project) ? globalThis.String(object.project) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      ref: isSet(object.ref) ? globalThis.String(object.ref) : undefined,
    };
  },

  toJSON(message: GobSourceCheckOptions_PinnedRepoMounts_GitCommit): unknown {
    const obj: any = {};
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.project !== undefined) {
      obj.project = message.project;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.ref !== undefined) {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_GitCommit>,
  ): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
    return GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_GitCommit>,
  ): GobSourceCheckOptions_PinnedRepoMounts_GitCommit {
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_GitCommit() as any;
    message.host = object.host ?? undefined;
    message.project = object.project ?? undefined;
    message.id = object.id ?? undefined;
    message.ref = object.ref ?? undefined;
    return message;
  },
};

function createBaseGobSourceCheckOptions_PinnedRepoMounts_ManifestCommit(): GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
  return { commit: undefined, path: undefined };
}

export const GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit: MessageFns<
  GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit
> = {
  encode(
    message: GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.commit !== undefined) {
      GobSourceCheckOptions_PinnedRepoMounts_GitCommit.encode(message.commit, writer.uint32(10).fork()).join();
    }
    if (message.path !== undefined) {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_ManifestCommit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commit = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
    return {
      commit: isSet(object.commit)
        ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromJSON(object.commit)
        : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
    };
  },

  toJSON(message: GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit): unknown {
    const obj: any = {};
    if (message.commit !== undefined) {
      obj.commit = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.toJSON(message.commit);
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit>,
  ): GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
    return GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit>,
  ): GobSourceCheckOptions_PinnedRepoMounts_ManifestCommit {
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_ManifestCommit() as any;
    message.commit = (object.commit !== undefined && object.commit !== null)
      ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromPartial(object.commit)
      : undefined;
    message.path = object.path ?? undefined;
    return message;
  },
};

function createBaseGobSourceCheckOptions_PinnedRepoMounts_MountOverride(): GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
  return { override: undefined, mount: undefined };
}

export const GobSourceCheckOptions_PinnedRepoMounts_MountOverride: MessageFns<
  GobSourceCheckOptions_PinnedRepoMounts_MountOverride
> = {
  encode(
    message: GobSourceCheckOptions_PinnedRepoMounts_MountOverride,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.override !== undefined) {
      GobSourceCheckOptions_PinnedRepoMounts_GitCommit.encode(message.override, writer.uint32(10).fork()).join();
    }
    if (message.mount !== undefined) {
      writer.uint32(18).string(message.mount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_MountOverride() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.override = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
    return {
      override: isSet(object.override)
        ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromJSON(object.override)
        : undefined,
      mount: isSet(object.mount) ? globalThis.String(object.mount) : undefined,
    };
  },

  toJSON(message: GobSourceCheckOptions_PinnedRepoMounts_MountOverride): unknown {
    const obj: any = {};
    if (message.override !== undefined) {
      obj.override = GobSourceCheckOptions_PinnedRepoMounts_GitCommit.toJSON(message.override);
    }
    if (message.mount !== undefined) {
      obj.mount = message.mount;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_MountOverride>,
  ): GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
    return GobSourceCheckOptions_PinnedRepoMounts_MountOverride.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GobSourceCheckOptions_PinnedRepoMounts_MountOverride>,
  ): GobSourceCheckOptions_PinnedRepoMounts_MountOverride {
    const message = createBaseGobSourceCheckOptions_PinnedRepoMounts_MountOverride() as any;
    message.override = (object.override !== undefined && object.override !== null)
      ? GobSourceCheckOptions_PinnedRepoMounts_GitCommit.fromPartial(object.override)
      : undefined;
    message.mount = object.mount ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
