// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/data/build/v1/build_check_options.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "turboci.data.build.v1";

/** The products currently supported by Turbo CI. */
export enum Product {
  /** PRODUCT_UNKNOWN - Default product. */
  PRODUCT_UNKNOWN = 0,
  /** PRODUCT_ANDROID - Android. */
  PRODUCT_ANDROID = 1,
  /** PRODUCT_BROWSER - Browser. */
  PRODUCT_BROWSER = 2,
  /** PRODUCT_CHROMEOS - ChromeOS. */
  PRODUCT_CHROMEOS = 3,
}

export function productFromJSON(object: any): Product {
  switch (object) {
    case 0:
    case "PRODUCT_UNKNOWN":
      return Product.PRODUCT_UNKNOWN;
    case 1:
    case "PRODUCT_ANDROID":
      return Product.PRODUCT_ANDROID;
    case 2:
    case "PRODUCT_BROWSER":
      return Product.PRODUCT_BROWSER;
    case 3:
    case "PRODUCT_CHROMEOS":
      return Product.PRODUCT_CHROMEOS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Product");
  }
}

export function productToJSON(object: Product): string {
  switch (object) {
    case Product.PRODUCT_UNKNOWN:
      return "PRODUCT_UNKNOWN";
    case Product.PRODUCT_ANDROID:
      return "PRODUCT_ANDROID";
    case Product.PRODUCT_BROWSER:
      return "PRODUCT_BROWSER";
    case Product.PRODUCT_CHROMEOS:
      return "PRODUCT_CHROMEOS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Product");
  }
}

/**
 * BuildCheckOptions provide the necessary information to execute the build, including but not
 * limited to:
 *   * Information specifying the purpose of each of the input dependency Checks.
 *   * External dependencies such as binaries stored in GCS, RBE-CAS etc.
 *   * Information/instructions on how to construct the filesystem for executing the build.
 *
 * The source code to be built will typically be specified via dependencies on Source Checks and
 * don't need to be explicitly referenced in the BuildCheckOptions if there is only one Source
 * Check specified. For situations where multiple Source Checks are needed, stage maintainers
 * are encouraged to create a custom message that maps Source Check identifiers to the purpose
 * they'll be used for.
 */
export interface BuildCheckOptions {
  /**
   * The build target. This will have slightly different meanings for different products but it
   * roughly represents the hardware this build is meant for plus the set of software options
   * (e.g. whether to enable certain build-time software options) to enable for the output
   * artifacts.
   */
  readonly target?: BuildCheckOptions_BuildTarget | undefined;
}

/**
 * A "build target" represents a particular configuration for a build action that will create
 * a set of binaries. Typically the build target, and therefore the binaries produced, will
 * target a specific runtime environment (hardware/architecture, VM environment, etc.) plus
 * optionally a set of software configurations to build into the binaries (features to enable,
 * enabling debug ports, etc.). The build target may also include/imply a particular branch
 * or other specification for which source code should be used when building, though this
 * is not required.
 *
 * A build target will often correspond 1:1 to a builder that will perform a build for that
 * build target, though this is not required. (You could have a single builder that knows how
 * to build many targets, and that accepts the build target name as an input, for example).
 * When builders build only a single build target, often the builder name and the build target
 * name will be the same.
 */
export interface BuildCheckOptions_BuildTarget {
  /**
   * The name for this build target. The exact meaning and format of this value will vary between
   * products, but examples include:
   * * Android: cf_x86_64_phone-trunk_staging-userdebug
   * * Browser: chromium/try/linux-rel
   * * ChromeOS: chromeos/staging/staging-brya-release-main
   */
  readonly name?:
    | string
    | undefined;
  /**
   * The namespace for this build target, which together with the target name uniquely identifies
   * the build target. The exact meaning and format of this value will vary between products,
   * and currently only Android is expected to use it (to hold the target's branch config).
   * Browser and ChromeOS do not currently expect to use it since the values they plan to use for
   * `name` are already believed to be globally unique.
   */
  readonly namespace?:
    | string
    | undefined;
  /** The product (Android, etc.) whose artifacts are built by this build target. */
  readonly product?:
    | Product
    | undefined;
  /**
   * The platform that the artifacts built by this build target are meant to run on.
   * For example, "husky" or "brya".
   *
   * This information will be used to help provide the right image to test execution Stages
   * based on the DUTs they choose to test on when there are multiple choices possible.
   */
  readonly platform?:
    | string
    | undefined;
  /**
   * The device that the artifacts built by this build target is meant to run on.
   * For example, "redrix" or "taniks" within the "brya" platform.
   *
   * This information will be used to help provide the right image to test execution Stages
   * based on the DUTs they choose to test on when there are multiple choices possible.
   * May be omitted for workflows that do not need to build per-device images.
   */
  readonly device?: string | undefined;
}

function createBaseBuildCheckOptions(): BuildCheckOptions {
  return { target: undefined };
}

export const BuildCheckOptions: MessageFns<BuildCheckOptions> = {
  encode(message: BuildCheckOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined) {
      BuildCheckOptions_BuildTarget.encode(message.target, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildCheckOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildCheckOptions() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = BuildCheckOptions_BuildTarget.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildCheckOptions {
    return { target: isSet(object.target) ? BuildCheckOptions_BuildTarget.fromJSON(object.target) : undefined };
  },

  toJSON(message: BuildCheckOptions): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = BuildCheckOptions_BuildTarget.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<BuildCheckOptions>): BuildCheckOptions {
    return BuildCheckOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildCheckOptions>): BuildCheckOptions {
    const message = createBaseBuildCheckOptions() as any;
    message.target = (object.target !== undefined && object.target !== null)
      ? BuildCheckOptions_BuildTarget.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseBuildCheckOptions_BuildTarget(): BuildCheckOptions_BuildTarget {
  return { name: undefined, namespace: undefined, product: undefined, platform: undefined, device: undefined };
}

export const BuildCheckOptions_BuildTarget: MessageFns<BuildCheckOptions_BuildTarget> = {
  encode(message: BuildCheckOptions_BuildTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== undefined) {
      writer.uint32(18).string(message.namespace);
    }
    if (message.product !== undefined) {
      writer.uint32(24).int32(message.product);
    }
    if (message.platform !== undefined) {
      writer.uint32(34).string(message.platform);
    }
    if (message.device !== undefined) {
      writer.uint32(42).string(message.device);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildCheckOptions_BuildTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildCheckOptions_BuildTarget() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.product = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.device = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildCheckOptions_BuildTarget {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      product: isSet(object.product) ? productFromJSON(object.product) : undefined,
      platform: isSet(object.platform) ? globalThis.String(object.platform) : undefined,
      device: isSet(object.device) ? globalThis.String(object.device) : undefined,
    };
  },

  toJSON(message: BuildCheckOptions_BuildTarget): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.product !== undefined) {
      obj.product = productToJSON(message.product);
    }
    if (message.platform !== undefined) {
      obj.platform = message.platform;
    }
    if (message.device !== undefined) {
      obj.device = message.device;
    }
    return obj;
  },

  create(base?: DeepPartial<BuildCheckOptions_BuildTarget>): BuildCheckOptions_BuildTarget {
    return BuildCheckOptions_BuildTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildCheckOptions_BuildTarget>): BuildCheckOptions_BuildTarget {
    const message = createBaseBuildCheckOptions_BuildTarget() as any;
    message.name = object.name ?? undefined;
    message.namespace = object.namespace ?? undefined;
    message.product = object.product ?? undefined;
    message.platform = object.platform ?? undefined;
    message.device = object.device ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
