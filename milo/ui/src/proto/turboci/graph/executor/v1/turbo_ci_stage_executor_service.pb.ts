// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/executor/v1/turbo_ci_stage_executor_service.proto

/* eslint-disable */
import { CancelStageRequest, CancelStageResponse } from "./cancel_stage.pb";
import { RunStageRequest, RunStageResponse } from "./run_stage.pb";
import { ValidateStageRequest, ValidateStageResponse } from "./validate_stage.pb";

export const protobufPackage = "turboci.graph.executor.v1";

/**
 * TurboCIStageExecutor defines the interface that all stage executors must
 * implement.
 *
 * The TurboCI Orchestrator can be configured to use many different services
 * which implement TurboCIStageExecutor to execute stages of different types.
 *
 * TBD: Explain end-user-credential propagation.
 */
export interface TurboCIStageExecutor {
  /**
   * ValidateStage instructs the executor to validate the stage.
   *
   * It is called once (i.e. not per attempt) when the stage is being inserted
   * into the graph. It should check the executor can run the stage at all (this
   * includes checking ACLs if appropriate).
   *
   * If the stage looks good (i.e. this RPC returns OK), the executor has
   * opportunity to adjust some of stages parameters before the stage is
   * inserted into the graph by returning them in ValidateStageResponse
   * (currently contains only turboci.orchestrator.v1.StageExecutionPolicy).
   *
   * If the stage doesn't look good (i.e. this RPC returns an error), the entire
   * WriteNodes transaction that was attempting to insert the stage will be
   * aborted. The graph will be left unchanged.
   *
   * RunStage RPC is generally expected to redo the validation, since the stage
   * parameters may change after the stage is inserted.
   *
   * TBD: Formalize how the error will be propagated back to the client
   * attempting to insert this stage. How would we allow details in the
   * response?
   *
   * Sidenote - do we need to record this failed node insertion somewhere
   * in the graph/ledger for observability?
   *
   * Must have no side effects, since it observes stages that potentially will
   * never exist in the graph for real.
   */
  ValidateStage(request: ValidateStageRequest): Promise<ValidateStageResponse>;
  /**
   * RunStage instructs the executor to run the given stage attempt.
   *
   * This is called per attempt to either run the stage to completion (for
   * "synchronous" stages) or to dispatch it to execute elsewhere (for
   * "asynchronous" stages).
   *
   * RunStage RPC is generally expected to redo the validation done by
   * ValidateStage, since the stage parameters may change after the stage is
   * inserted. If the stage is no longer passing the validation, RunStage should
   * essentially finish it as failed by calling TurboCIOrchestrator.WriteNodes
   * (see below).
   *
   * Expected behavior:
   *   * If the stage is synchronous, at the end of this RPC the executor must
   *     call TurboCIOrchestrator.WriteNodes with StageAttemptToken to do all
   *     the writes in one transaction, including a CurrentStageWrite to mark
   *     the StageAttempt as COMPLETE or INCOMPLETE.
   *   * If the stage is asynchronous, this RPC must call
   *     TurboCIOrchestrator.WriteNodes with CurrentStageWrite to mark the
   *     StageAttempt as SCHEDULED or RUNNING.
   *     * the executor must also write the validated execution policy for the
   *       StageAttempt for the updated state (See
   *       turboci.orchestrator.v1.StageAttemptExecutionPolicy for details).
   *
   * RunStage return value and even status code are essentially ignored.
   * The orchestrator always looks at the state of the stage attempt after
   * RunStage finishes (successfully or not) to decide if the request succeeded
   * or should be retried. This is needed to unify handling of synchronous and
   * asynchronous stages and to simplify handling of a class of race conditions
   * related to RPC peers (or network between them) dying midway through
   * execution.
   */
  RunStage(request: RunStageRequest): Promise<RunStageResponse>;
  /**
   * CancelStage instructs the executor to cancel the given stage attempt.
   *
   * This RPC is used to cancel an asynchronous stage attempt that is in
   * CANCELLING state.
   *
   * To handle this RPC, the executor may
   * * call TurboCIOrchestrator.WriteNodes with CurrentStageWrite to mark the
   *   stage as COMPLETE/INCOMPLETE if it can do so (for example, if the stage
   *   attempt has not started running yet).
   * * call TurboCIOrchestrator.WriteNodes with CurrentStageWrite to mark the
   *   stage as TEARING_DOWN if the execution policy allows this, and there is
   *   some additional work that needs to happen in this state.
   * * communicate with its stage attempt worker (e.g. bbagent) to make a
   *   similar TurboCIOrchestrator.WriteNodes call to transition the stage
   *   attempt to COMPLETE/INCOMPLETE/TEARING_DOWN.
   */
  CancelStage(request: CancelStageRequest): Promise<CancelStageResponse>;
}

export const TurboCIStageExecutorServiceName = "turboci.graph.executor.v1.TurboCIStageExecutor";
export class TurboCIStageExecutorClientImpl implements TurboCIStageExecutor {
  static readonly DEFAULT_SERVICE = TurboCIStageExecutorServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TurboCIStageExecutorServiceName;
    this.rpc = rpc;
    this.ValidateStage = this.ValidateStage.bind(this);
    this.RunStage = this.RunStage.bind(this);
    this.CancelStage = this.CancelStage.bind(this);
  }
  ValidateStage(request: ValidateStageRequest): Promise<ValidateStageResponse> {
    const data = ValidateStageRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ValidateStage", data);
    return promise.then((data) => ValidateStageResponse.fromJSON(data));
  }

  RunStage(request: RunStageRequest): Promise<RunStageResponse> {
    const data = RunStageRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "RunStage", data);
    return promise.then((data) => RunStageResponse.fromJSON(data));
  }

  CancelStage(request: CancelStageRequest): Promise<CancelStageResponse> {
    const data = CancelStageRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CancelStage", data);
    return promise.then((data) => CancelStageResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}
