// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/orchestrator/v1/stage_state.proto

/* eslint-disable */

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * StageState describes the current state of a Stage.
 *
 * This state evolves like:
 *
 *   PLANNED -> ATTEMPTING
 *   ATTEMPTING -> AWAITING_GROUP
 *   AWAITING_GROUP -> FINAL
 *
 * (The transition through AWAITING_GROUP may be instantaneous if the Stage's
 * continuation_group is empty)
 *
 * The Orchestrator entirely manages Stage state evolution.
 *
 * These states have enum values in multiples of 10 in case we need to add more
 * states later which fall between these 4 initial states.
 */
export enum StageState {
  /** STAGE_STATE_UNKNOWN - UNKNOWN is the default, invalid, state. */
  STAGE_STATE_UNKNOWN = 0,
  /**
   * STAGE_STATE_PLANNED - The Stage is inserted into the graph, but still has unresolved
   * dependencies.
   */
  STAGE_STATE_PLANNED = 10,
  /**
   * STAGE_STATE_ATTEMPTING - The Stage's dependencies are resolved and the Orchestrator is trying to
   * coordinate with an external Executor to actually run this Stage.
   *
   * During this state, the Stage.attempts[-1] will contain the status of the
   * current StageAttempt. See StageAttemptState for the StageAttempt state
   * machine.
   */
  STAGE_STATE_ATTEMPTING = 20,
  /**
   * STAGE_STATE_AWAITING_GROUP - The Stage has concluded it's attempts to execute (e.g. the final attempt
   * succeeded or the Stage ran out of retries/time), but during its run one or
   * more StageAttempts emitted additional Stages which it added to
   * Stage.continuation_group, and one or more of those are not yet FINAL.
   */
  STAGE_STATE_AWAITING_GROUP = 30,
  /**
   * STAGE_STATE_FINAL - The Stage has concluded it's attempts to execute (e.g. the final attempt
   * succeeded or the Stage ran out of retries/time) and the
   * Stage.continuation_group is fully resolved (or empty).
   */
  STAGE_STATE_FINAL = 40,
}

export function stageStateFromJSON(object: any): StageState {
  switch (object) {
    case 0:
    case "STAGE_STATE_UNKNOWN":
      return StageState.STAGE_STATE_UNKNOWN;
    case 10:
    case "STAGE_STATE_PLANNED":
      return StageState.STAGE_STATE_PLANNED;
    case 20:
    case "STAGE_STATE_ATTEMPTING":
      return StageState.STAGE_STATE_ATTEMPTING;
    case 30:
    case "STAGE_STATE_AWAITING_GROUP":
      return StageState.STAGE_STATE_AWAITING_GROUP;
    case 40:
    case "STAGE_STATE_FINAL":
      return StageState.STAGE_STATE_FINAL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageState");
  }
}

export function stageStateToJSON(object: StageState): string {
  switch (object) {
    case StageState.STAGE_STATE_UNKNOWN:
      return "STAGE_STATE_UNKNOWN";
    case StageState.STAGE_STATE_PLANNED:
      return "STAGE_STATE_PLANNED";
    case StageState.STAGE_STATE_ATTEMPTING:
      return "STAGE_STATE_ATTEMPTING";
    case StageState.STAGE_STATE_AWAITING_GROUP:
      return "STAGE_STATE_AWAITING_GROUP";
    case StageState.STAGE_STATE_FINAL:
      return "STAGE_STATE_FINAL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageState");
  }
}
