// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/orchestrator/v1/check.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Check as Check1, CheckOption, CheckResult, CheckResultDatum } from "../../ids/v1/identifier.pb";
import { Actor } from "./actor.pb";
import { CheckKind, checkKindFromJSON, checkKindToJSON } from "./check_kind.pb";
import { CheckState, checkStateFromJSON, checkStateToJSON } from "./check_state.pb";
import { EdgeGroup } from "./edge_group.pb";
import { Revision } from "./revision.pb";

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * A Check is a node in a TurboCI graph which ties together:
 *  * A named objective of the Workflow (sometimes thought of as a question).
 *  For example:
 *    * Does source X build for platform Y?
 *    * Do these tests built for Y pass when run on Z?
 *    * Are the aggregate test results good enough to allow this CL to land?
 *  * Options which describe *how* to answer that question. For example:
 *    * Which compile targets should be built?
 *    * Which test cases should be skipped? Or how many times should retry if
 *      they fail?
 *    * What test targets should we consider when evaluating the CL?
 *  * The answers to that question (i.e. the results of the Check)
 *    * Pointers to build artifacts, test results, small bits of workflow
 *      specific output which don't fit nicely elsewhere, etc.
 *
 * Checks are not, themselves, executable, but Stages are the executable nodes
 * which operate to plan and resolve Checks.
 *
 * Options and Result Data are held as protobuf Any messages in Datum objects
 * which are children of this Check. Each Datum can be assigned to a different
 * security realm (allowing for public/private inputs/outputs for the same
 * Check).
 *
 * See also:
 *   * Identifier.Check* (Identifiers for Checks, CheckOptions, etc.)
 *   * CheckView (graph view object for a Check and contained messages)
 *   * CheckEditView (graph view object for Edits of a Check)
 */
export interface Check {
  /**
   * The Check's identifier.
   *
   * `identifier.id` is provided by the Stage which creates this Check.
   */
  readonly identifier?:
    | Check1
    | undefined;
  /**
   * The coarse-grained kind of this Check.
   *
   * Used in UI and Data registration to restrict what data types are usable in
   * `options` and `results.data`.
   *
   * Used as part of a Checks query for a coarse-grained filter.
   */
  readonly kind?:
    | CheckKind
    | undefined;
  /**
   * The security realm for this Check.
   *
   * If unset on creation, then this will be populated with the realm of the
   * Stage which creates this Check.
   */
  readonly realm?:
    | string
    | undefined;
  /**
   * The version of this Check.
   *
   * Updated any time fields in this Check change.
   *
   * Note that changing the data in an existing Check Option or a Check Result
   * Datum does not change any field data in this message, and thus will not
   * change this version number (adding a new entry in `options` or in
   * a `Result.data` would, however).
   */
  readonly version?:
    | Revision
    | undefined;
  /** The current state of the Check. */
  readonly state?:
    | CheckState
    | undefined;
  /**
   * Dependencies on other objects in the graph.
   *
   * All of these dependencies must be satisfied for this Check to be unblocked
   * and advance from the PLANNED to WAITING state.
   *
   * If the dependencies are unsatisfiable, then the Check will be immediately
   * moved to FINAL state and a single Result will be added with type `TBD`.
   *
   * Currently Checks may only depend on other Checks in the same workflow.
   */
  readonly dependencies: readonly EdgeGroup[];
  /**
   * Options form the bulk of 'how to answer this Check'.
   *
   * It is expected that small details (like assignments to specific
   * hardware/devices) will not be present here and will be decided by the
   * Stages which actually produce results for this Check. The balance of what
   * is in the Check options vs. what is in the Stage args is up to the workflow
   * authors. It should be expected that Check options will be consumed by
   * entities external to the Workflow (such as individual developers), and so
   * it's recommended that the option data here be formulated in a way to be
   * useful both in-workflow (to Stages) and to users outside the workflow. If
   * small execution details ARE stored here, it's recommended that they be
   * stored in a secondary data type to make it clear to external users that
   * these details are not intended to be intrinsic for reproduction/replication
   * of the Check results.
   *
   * Orchestrator will ensure that the option types here are registered to be
   * valid for this Check's kind.
   *
   * This field is kept unique by `type_url` and ordered by
   * identifier.options_idx.
   *
   * You can use QueryNodes to get a CheckView which includes this Check and
   * also CheckOptions.
   */
  readonly options: readonly Check_OptionRef[];
  /**
   * The list of Results this Check has.
   *
   * Any time a StageAttempt adds new result *data* for this Check for the first
   * time, a new Result will be added to this list.
   *
   * So, if you had 3 Stages, each with one Stage Attempt, which add result
   * data for this Check, you would see 3 Result messages. Similarly, if you
   * had one Stage with 3 Attempts, all 3 of which add result data for this
   * check, you would see 3 Result messages.
   *
   * Check.version is advanced when a new Result is added, or new data types are
   * added to an existing Result. However, CheckEdits will still be produced for
   * each write to each Result datum.
   */
  readonly results: readonly Check_Result[];
}

/** OptionRef is a reference to a CheckOption. */
export interface Check_OptionRef {
  /** The Identifier for the CheckOption, which is a Datum. */
  readonly identifier?:
    | CheckOption
    | undefined;
  /** The type_url of the data contained for this CheckOption. */
  readonly typeUrl?: string | undefined;
}

/**
 * A Result is a container of result data for a Check.
 *
 * Results belong to exactly one Actor (usually a StageAttempt), and any given
 * Actor may only have one Result per Check.
 *
 * A Check may have multiple Results, and each Result may have multiple pieces
 * of result data. This could occur when multiple Stages all contribute
 * results to the same Check (e.g. sharding, multiple executions, etc.).
 */
export interface Check_Result {
  /** Identifier for this Result. */
  readonly identifier?:
    | CheckResult
    | undefined;
  /** The entity which created this Result. */
  readonly owner?:
    | Actor
    | undefined;
  /**
   * The database revsision (commit timestamp) at which this Result was
   * created.
   */
  readonly createdAt?:
    | Revision
    | undefined;
  /**
   * Data form the bulk of the result.
   *
   * NOTE: Most data should be stored in ResultDB via turboci.ResultStorage.
   *
   * This field is kept unique by `type_url` and ordered by
   * identifier.options_idx.
   *
   * Orchestrator will ensure that the option types here are registered to be
   * valid for this Result's kind.
   *
   * You can use QueryNodes to get a CheckView which includes this Check and
   * also Result Data.
   */
  readonly data: readonly Check_Result_ResultDatumRef[];
  /**
   * The database revsision (commit timestamp) at which this Result is
   * finalized.
   *
   * This is set when:
   *   * A StageAttempt `owner` ends (becomes COMPLETE or INCOMPLETE).
   *   * The `owner` explicitly indicates that their results are final.
   *   * The Check advances to the FINAL state.
   */
  readonly finalizedAt?: Revision | undefined;
}

/** ResultDatumRef is a reference to a CheckResultDatum. */
export interface Check_Result_ResultDatumRef {
  /** The Identifier for the CheckResultDatum. */
  readonly identifier?:
    | CheckResultDatum
    | undefined;
  /** The type_url of the data contained for this CheckResultDatum. */
  readonly typeUrl?: string | undefined;
}

function createBaseCheck(): Check {
  return {
    identifier: undefined,
    kind: undefined,
    realm: undefined,
    version: undefined,
    state: undefined,
    dependencies: [],
    options: [],
    results: [],
  };
}

export const Check: MessageFns<Check> = {
  encode(message: Check, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      Check1.encode(message.identifier, writer.uint32(10).fork()).join();
    }
    if (message.kind !== undefined) {
      writer.uint32(16).int32(message.kind);
    }
    if (message.realm !== undefined) {
      writer.uint32(26).string(message.realm);
    }
    if (message.version !== undefined) {
      Revision.encode(message.version, writer.uint32(34).fork()).join();
    }
    if (message.state !== undefined) {
      writer.uint32(40).int32(message.state);
    }
    for (const v of message.dependencies) {
      EdgeGroup.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.options) {
      Check_OptionRef.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.results) {
      Check_Result.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Check {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheck() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = Check1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.realm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = Revision.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dependencies.push(EdgeGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.options.push(Check_OptionRef.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.results.push(Check_Result.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Check {
    return {
      identifier: isSet(object.identifier) ? Check1.fromJSON(object.identifier) : undefined,
      kind: isSet(object.kind) ? checkKindFromJSON(object.kind) : undefined,
      realm: isSet(object.realm) ? globalThis.String(object.realm) : undefined,
      version: isSet(object.version) ? Revision.fromJSON(object.version) : undefined,
      state: isSet(object.state) ? checkStateFromJSON(object.state) : undefined,
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => EdgeGroup.fromJSON(e))
        : [],
      options: globalThis.Array.isArray(object?.options)
        ? object.options.map((e: any) => Check_OptionRef.fromJSON(e))
        : [],
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => Check_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Check): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = Check1.toJSON(message.identifier);
    }
    if (message.kind !== undefined) {
      obj.kind = checkKindToJSON(message.kind);
    }
    if (message.realm !== undefined) {
      obj.realm = message.realm;
    }
    if (message.version !== undefined) {
      obj.version = Revision.toJSON(message.version);
    }
    if (message.state !== undefined) {
      obj.state = checkStateToJSON(message.state);
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => EdgeGroup.toJSON(e));
    }
    if (message.options?.length) {
      obj.options = message.options.map((e) => Check_OptionRef.toJSON(e));
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => Check_Result.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Check>): Check {
    return Check.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Check>): Check {
    const message = createBaseCheck() as any;
    message.identifier = (object.identifier !== undefined && object.identifier !== null)
      ? Check1.fromPartial(object.identifier)
      : undefined;
    message.kind = object.kind ?? undefined;
    message.realm = object.realm ?? undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? Revision.fromPartial(object.version)
      : undefined;
    message.state = object.state ?? undefined;
    message.dependencies = object.dependencies?.map((e) => EdgeGroup.fromPartial(e)) || [];
    message.options = object.options?.map((e) => Check_OptionRef.fromPartial(e)) || [];
    message.results = object.results?.map((e) => Check_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheck_OptionRef(): Check_OptionRef {
  return { identifier: undefined, typeUrl: undefined };
}

export const Check_OptionRef: MessageFns<Check_OptionRef> = {
  encode(message: Check_OptionRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      CheckOption.encode(message.identifier, writer.uint32(10).fork()).join();
    }
    if (message.typeUrl !== undefined) {
      writer.uint32(18).string(message.typeUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Check_OptionRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheck_OptionRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = CheckOption.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Check_OptionRef {
    return {
      identifier: isSet(object.identifier) ? CheckOption.fromJSON(object.identifier) : undefined,
      typeUrl: isSet(object.typeUrl) ? globalThis.String(object.typeUrl) : undefined,
    };
  },

  toJSON(message: Check_OptionRef): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = CheckOption.toJSON(message.identifier);
    }
    if (message.typeUrl !== undefined) {
      obj.typeUrl = message.typeUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<Check_OptionRef>): Check_OptionRef {
    return Check_OptionRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Check_OptionRef>): Check_OptionRef {
    const message = createBaseCheck_OptionRef() as any;
    message.identifier = (object.identifier !== undefined && object.identifier !== null)
      ? CheckOption.fromPartial(object.identifier)
      : undefined;
    message.typeUrl = object.typeUrl ?? undefined;
    return message;
  },
};

function createBaseCheck_Result(): Check_Result {
  return { identifier: undefined, owner: undefined, createdAt: undefined, data: [], finalizedAt: undefined };
}

export const Check_Result: MessageFns<Check_Result> = {
  encode(message: Check_Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      CheckResult.encode(message.identifier, writer.uint32(10).fork()).join();
    }
    if (message.owner !== undefined) {
      Actor.encode(message.owner, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Revision.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    for (const v of message.data) {
      Check_Result_ResultDatumRef.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.finalizedAt !== undefined) {
      Revision.encode(message.finalizedAt, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Check_Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheck_Result() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = CheckResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = Actor.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Revision.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data.push(Check_Result_ResultDatumRef.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.finalizedAt = Revision.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Check_Result {
    return {
      identifier: isSet(object.identifier) ? CheckResult.fromJSON(object.identifier) : undefined,
      owner: isSet(object.owner) ? Actor.fromJSON(object.owner) : undefined,
      createdAt: isSet(object.createdAt) ? Revision.fromJSON(object.createdAt) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => Check_Result_ResultDatumRef.fromJSON(e))
        : [],
      finalizedAt: isSet(object.finalizedAt) ? Revision.fromJSON(object.finalizedAt) : undefined,
    };
  },

  toJSON(message: Check_Result): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = CheckResult.toJSON(message.identifier);
    }
    if (message.owner !== undefined) {
      obj.owner = Actor.toJSON(message.owner);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = Revision.toJSON(message.createdAt);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Check_Result_ResultDatumRef.toJSON(e));
    }
    if (message.finalizedAt !== undefined) {
      obj.finalizedAt = Revision.toJSON(message.finalizedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<Check_Result>): Check_Result {
    return Check_Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Check_Result>): Check_Result {
    const message = createBaseCheck_Result() as any;
    message.identifier = (object.identifier !== undefined && object.identifier !== null)
      ? CheckResult.fromPartial(object.identifier)
      : undefined;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Actor.fromPartial(object.owner) : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Revision.fromPartial(object.createdAt)
      : undefined;
    message.data = object.data?.map((e) => Check_Result_ResultDatumRef.fromPartial(e)) || [];
    message.finalizedAt = (object.finalizedAt !== undefined && object.finalizedAt !== null)
      ? Revision.fromPartial(object.finalizedAt)
      : undefined;
    return message;
  },
};

function createBaseCheck_Result_ResultDatumRef(): Check_Result_ResultDatumRef {
  return { identifier: undefined, typeUrl: undefined };
}

export const Check_Result_ResultDatumRef: MessageFns<Check_Result_ResultDatumRef> = {
  encode(message: Check_Result_ResultDatumRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== undefined) {
      CheckResultDatum.encode(message.identifier, writer.uint32(10).fork()).join();
    }
    if (message.typeUrl !== undefined) {
      writer.uint32(18).string(message.typeUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Check_Result_ResultDatumRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheck_Result_ResultDatumRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = CheckResultDatum.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Check_Result_ResultDatumRef {
    return {
      identifier: isSet(object.identifier) ? CheckResultDatum.fromJSON(object.identifier) : undefined,
      typeUrl: isSet(object.typeUrl) ? globalThis.String(object.typeUrl) : undefined,
    };
  },

  toJSON(message: Check_Result_ResultDatumRef): unknown {
    const obj: any = {};
    if (message.identifier !== undefined) {
      obj.identifier = CheckResultDatum.toJSON(message.identifier);
    }
    if (message.typeUrl !== undefined) {
      obj.typeUrl = message.typeUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<Check_Result_ResultDatumRef>): Check_Result_ResultDatumRef {
    return Check_Result_ResultDatumRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Check_Result_ResultDatumRef>): Check_Result_ResultDatumRef {
    const message = createBaseCheck_Result_ResultDatumRef() as any;
    message.identifier = (object.identifier !== undefined && object.identifier !== null)
      ? CheckResultDatum.fromPartial(object.identifier)
      : undefined;
    message.typeUrl = object.typeUrl ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
