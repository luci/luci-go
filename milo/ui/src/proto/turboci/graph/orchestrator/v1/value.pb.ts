// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/orchestrator/v1/value.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../google/protobuf/any.pb";

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * Value wraps a google.protobuf.Any but also provides a space for the server to
 * give back an alternate serialization of the Any.
 *
 * The fields other than `value` are only conditionally set if the user
 * requested alternate serialization.
 *
 * These alternate serializations use an eventually-consistent version of the
 * proto, so it's possible for this to be missing fields vs. what is in the
 * binary `value` field. These alternate serializations can be requested via
 * QueryNodes with `alternate_serialization` set. The intent is to allow UIs to
 * generically display this data, or for scripts (potentially including LLMs) to
 * observe the data without having the proto descriptors handy.
 *
 * When writing this type to the server, only `value` is allowed to be
 * populated.
 */
export interface Value {
  /** The actual value. */
  readonly value?:
    | Any
    | undefined;
  /**
   * If true the server knows that `value` contains unknown fields according to
   * the current proto descriptor loaded on the server.
   *
   * This can happen if the server's copy of the proto descriptor for `value` is
   * out of date vs the descriptor used by the writer for this Datum.
   */
  readonly hasUnknownFields?:
    | boolean
    | undefined;
  /** A ProtoJSON-serialized version of `value`. */
  readonly valueJson?: string | undefined;
}

function createBaseValue(): Value {
  return { value: undefined, hasUnknownFields: undefined, valueJson: undefined };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.hasUnknownFields !== undefined) {
      writer.uint32(16).bool(message.hasUnknownFields);
    }
    if (message.valueJson !== undefined) {
      writer.uint32(26).string(message.valueJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasUnknownFields = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.valueJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
      hasUnknownFields: isSet(object.hasUnknownFields) ? globalThis.Boolean(object.hasUnknownFields) : undefined,
      valueJson: isSet(object.valueJson) ? globalThis.String(object.valueJson) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    if (message.hasUnknownFields !== undefined) {
      obj.hasUnknownFields = message.hasUnknownFields;
    }
    if (message.valueJson !== undefined) {
      obj.valueJson = message.valueJson;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue() as any;
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    message.hasUnknownFields = object.hasUnknownFields ?? undefined;
    message.valueJson = object.valueJson ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
