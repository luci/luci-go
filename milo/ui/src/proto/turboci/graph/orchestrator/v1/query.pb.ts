// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/orchestrator/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Identifier, WorkPlan } from "../../ids/v1/identifier.pb";
import { CheckKind, checkKindFromJSON, checkKindToJSON } from "./check_kind.pb";
import { RevisionRange } from "./revision_range.pb";

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * Query describes a simple graph query.
 *
 * This is composed of three phases: selection, expansion and collection.
 *
 * The selection phase queries for a set of nodes within a WorkPlan
 * - effectively a regular SELECT type query on a traditional database.
 *
 * After the selection phase, the expansion phase allows traversal along the
 * edges of the selected nodes. Currently only 'dependency' edge traversal is
 * supported, but other types of relationships could be possible in the future
 * (e.g. 'created_by', 'written_by', etc.).
 *
 * Finally, after the set of nodes has been fully expanded, we collect all the
 * requested data from those Nodes.
 *
 * See QueryNodesRequest.version for how this Query interacts with transactions.
 */
export interface Query {
  /**
   * Type URLs (for Check Option Datum, Check Result Datum, Stage args,
   * CheckEdit Option Datum and CheckEdit Result) that the caller wants to see
   * in the response.  Any child Node whose type URL is not specified here
   * will be omitted in the response.
   *
   * TBD: The special value "*" means that the caller wants to see all type
   * URLs, but this requires an extra permission. Extra permission is needed
   * to encourage clients to be explicit about what they want to reduce
   * bandwidth, coupling and increase auditability.
   */
  readonly typeUrls: readonly string[];
  /** Select an arbitrary set of nodes. */
  readonly select?:
    | Query_Select
    | undefined;
  /** Expand that set of nodes by following their edges. */
  readonly expand?:
    | Query_Expand
    | undefined;
  /** The data to collect from the expanded node set. */
  readonly collect?: Query_Collect | undefined;
}

/** Select picks some set of nodes out of the graph. */
export interface Query_Select {
  /** Which WorkPlans to search across. */
  readonly workplan?:
    | Query_Select_WorkPlanConstraint
    | undefined;
  /**
   * The identifiers of specific nodes to select.
   *
   * This should be used if you already know the identifiers of the nodes you
   * care about.
   */
  readonly nodes: readonly Identifier[];
  /** Select Checks matching these patterns. */
  readonly checkPatterns: readonly Query_Select_CheckPattern[];
  /** Select Stages matching these patterns. */
  readonly stagePatterns: readonly Query_Select_StagePattern[];
}

/**
 * How this selection of nodes should be constrained to one or more
 * WorkPlans.
 */
export interface Query_Select_WorkPlanConstraint {
  /** Constrain this Select to the given WorkPlan(s). */
  readonly inWorkplans: readonly WorkPlan[];
}

/** Select one or more Checks which match this pattern. */
export interface Query_Select_CheckPattern {
  /** Find Checks of this kind (unset means all kinds). */
  readonly kind?:
    | CheckKind
    | undefined;
  /** Find Checks whose `Identifier.Check.id` matches this re2 regex. */
  readonly idRegex?:
    | string
    | undefined;
  /**
   * Find Checks with *any* of these options. Note that you still must set
   * follow.check_options.type_urls to actually get the CheckOptions in the
   * result set.
   */
  readonly withOptionTypes: readonly string[];
}

/** Select one or more Stages which match this pattern. */
export interface Query_Select_StagePattern {
}

/**
 * Expand takes the selected node set and 'expands' it by following edges in
 * the graph from those nodes.
 */
export interface Query_Expand {
  /** Instructs the query to follow dependencies of the selected node(s). */
  readonly dependencies?: Query_Expand_Dependencies | undefined;
}

/** How to follow Check.dependencies and Stage.dependencies. */
export interface Query_Expand_Dependencies {
  /**
   * Follow this many dependents (so for some node X, follow to other
   * nodes which depend-on X up to this distance away).
   *
   * 0 means "do not follow dependents".
   *
   * Must be >= 0.
   */
  readonly dependentsDepth?:
    | number
    | undefined;
  /**
   * Follow this many dependencies (so for some node, follow it's
   * `dependencies` fields up to this distance away).
   *
   * 0 means "do not follow dependencies".
   *
   * Must be >= 0.
   */
  readonly dependenciesDepth?:
    | number
    | undefined;
  /** Includes only resolved edges during traversal. */
  readonly onlyResolved?: boolean | undefined;
}

/** Collect retrieves data from the expanded node set. */
export interface Query_Collect {
  /** Collect options/results/progress data. */
  readonly data?:
    | Query_Collect_Data
    | undefined;
  /** Collect edit records. */
  readonly edits?: Query_Collect_Edits | undefined;
}

/**
 * Data describes what options/results/progress data we want to retrieve
 * from the selected checks/stages.
 */
export interface Query_Collect_Data {
  /** Describes what data the caller wants to see for Checks. */
  readonly check?:
    | Query_Collect_Data_Check
    | undefined;
  /** Describes what data the caller wants to see for Stages. */
  readonly stage?: Query_Collect_Data_Stage | undefined;
}

/** Describes what data the caller wants to see for Checks. */
export interface Query_Collect_Data_Check {
  /** Include CheckOptions filtered by `type_urls` for any selected Checks. */
  readonly options?:
    | boolean
    | undefined;
  /** Include Result data filtered by `type_urls` for any selected Checks. */
  readonly resultData?: boolean | undefined;
}

/** Describes what data the caller wants to see for Stages. */
export interface Query_Collect_Data_Stage {
}

/** Edits describes which edit records we want want to collect. */
export interface Query_Collect_Edits {
  /** Include edits only within this range of Revisions. */
  readonly range?:
    | RevisionRange
    | undefined;
  /** Include Check Edits for any selected Checks in this range. */
  readonly check?:
    | boolean
    | undefined;
  /** Include Stage Edits for any selected Stages in this range. */
  readonly stage?: boolean | undefined;
}

function createBaseQuery(): Query {
  return { typeUrls: [], select: undefined, expand: undefined, collect: undefined };
}

export const Query: MessageFns<Query> = {
  encode(message: Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.typeUrls) {
      writer.uint32(10).string(v!);
    }
    if (message.select !== undefined) {
      Query_Select.encode(message.select, writer.uint32(18).fork()).join();
    }
    if (message.expand !== undefined) {
      Query_Expand.encode(message.expand, writer.uint32(26).fork()).join();
    }
    if (message.collect !== undefined) {
      Query_Collect.encode(message.collect, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typeUrls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.select = Query_Select.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expand = Query_Expand.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collect = Query_Collect.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query {
    return {
      typeUrls: globalThis.Array.isArray(object?.typeUrls) ? object.typeUrls.map((e: any) => globalThis.String(e)) : [],
      select: isSet(object.select) ? Query_Select.fromJSON(object.select) : undefined,
      expand: isSet(object.expand) ? Query_Expand.fromJSON(object.expand) : undefined,
      collect: isSet(object.collect) ? Query_Collect.fromJSON(object.collect) : undefined,
    };
  },

  toJSON(message: Query): unknown {
    const obj: any = {};
    if (message.typeUrls?.length) {
      obj.typeUrls = message.typeUrls;
    }
    if (message.select !== undefined) {
      obj.select = Query_Select.toJSON(message.select);
    }
    if (message.expand !== undefined) {
      obj.expand = Query_Expand.toJSON(message.expand);
    }
    if (message.collect !== undefined) {
      obj.collect = Query_Collect.toJSON(message.collect);
    }
    return obj;
  },

  create(base?: DeepPartial<Query>): Query {
    return Query.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query>): Query {
    const message = createBaseQuery() as any;
    message.typeUrls = object.typeUrls?.map((e) => e) || [];
    message.select = (object.select !== undefined && object.select !== null)
      ? Query_Select.fromPartial(object.select)
      : undefined;
    message.expand = (object.expand !== undefined && object.expand !== null)
      ? Query_Expand.fromPartial(object.expand)
      : undefined;
    message.collect = (object.collect !== undefined && object.collect !== null)
      ? Query_Collect.fromPartial(object.collect)
      : undefined;
    return message;
  },
};

function createBaseQuery_Select(): Query_Select {
  return { workplan: undefined, nodes: [], checkPatterns: [], stagePatterns: [] };
}

export const Query_Select: MessageFns<Query_Select> = {
  encode(message: Query_Select, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workplan !== undefined) {
      Query_Select_WorkPlanConstraint.encode(message.workplan, writer.uint32(10).fork()).join();
    }
    for (const v of message.nodes) {
      Identifier.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.checkPatterns) {
      Query_Select_CheckPattern.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.stagePatterns) {
      Query_Select_StagePattern.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Select {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Select() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workplan = Query_Select_WorkPlanConstraint.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Identifier.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkPatterns.push(Query_Select_CheckPattern.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stagePatterns.push(Query_Select_StagePattern.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Select {
    return {
      workplan: isSet(object.workplan) ? Query_Select_WorkPlanConstraint.fromJSON(object.workplan) : undefined,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Identifier.fromJSON(e)) : [],
      checkPatterns: globalThis.Array.isArray(object?.checkPatterns)
        ? object.checkPatterns.map((e: any) => Query_Select_CheckPattern.fromJSON(e))
        : [],
      stagePatterns: globalThis.Array.isArray(object?.stagePatterns)
        ? object.stagePatterns.map((e: any) => Query_Select_StagePattern.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Query_Select): unknown {
    const obj: any = {};
    if (message.workplan !== undefined) {
      obj.workplan = Query_Select_WorkPlanConstraint.toJSON(message.workplan);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Identifier.toJSON(e));
    }
    if (message.checkPatterns?.length) {
      obj.checkPatterns = message.checkPatterns.map((e) => Query_Select_CheckPattern.toJSON(e));
    }
    if (message.stagePatterns?.length) {
      obj.stagePatterns = message.stagePatterns.map((e) => Query_Select_StagePattern.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Select>): Query_Select {
    return Query_Select.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Select>): Query_Select {
    const message = createBaseQuery_Select() as any;
    message.workplan = (object.workplan !== undefined && object.workplan !== null)
      ? Query_Select_WorkPlanConstraint.fromPartial(object.workplan)
      : undefined;
    message.nodes = object.nodes?.map((e) => Identifier.fromPartial(e)) || [];
    message.checkPatterns = object.checkPatterns?.map((e) => Query_Select_CheckPattern.fromPartial(e)) || [];
    message.stagePatterns = object.stagePatterns?.map((e) => Query_Select_StagePattern.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuery_Select_WorkPlanConstraint(): Query_Select_WorkPlanConstraint {
  return { inWorkplans: [] };
}

export const Query_Select_WorkPlanConstraint: MessageFns<Query_Select_WorkPlanConstraint> = {
  encode(message: Query_Select_WorkPlanConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inWorkplans) {
      WorkPlan.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Select_WorkPlanConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Select_WorkPlanConstraint() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inWorkplans.push(WorkPlan.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Select_WorkPlanConstraint {
    return {
      inWorkplans: globalThis.Array.isArray(object?.inWorkplans)
        ? object.inWorkplans.map((e: any) => WorkPlan.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Query_Select_WorkPlanConstraint): unknown {
    const obj: any = {};
    if (message.inWorkplans?.length) {
      obj.inWorkplans = message.inWorkplans.map((e) => WorkPlan.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Select_WorkPlanConstraint>): Query_Select_WorkPlanConstraint {
    return Query_Select_WorkPlanConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Select_WorkPlanConstraint>): Query_Select_WorkPlanConstraint {
    const message = createBaseQuery_Select_WorkPlanConstraint() as any;
    message.inWorkplans = object.inWorkplans?.map((e) => WorkPlan.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuery_Select_CheckPattern(): Query_Select_CheckPattern {
  return { kind: undefined, idRegex: undefined, withOptionTypes: [] };
}

export const Query_Select_CheckPattern: MessageFns<Query_Select_CheckPattern> = {
  encode(message: Query_Select_CheckPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== undefined) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.idRegex !== undefined) {
      writer.uint32(18).string(message.idRegex);
    }
    for (const v of message.withOptionTypes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Select_CheckPattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Select_CheckPattern() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idRegex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.withOptionTypes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Select_CheckPattern {
    return {
      kind: isSet(object.kind) ? checkKindFromJSON(object.kind) : undefined,
      idRegex: isSet(object.idRegex) ? globalThis.String(object.idRegex) : undefined,
      withOptionTypes: globalThis.Array.isArray(object?.withOptionTypes)
        ? object.withOptionTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Query_Select_CheckPattern): unknown {
    const obj: any = {};
    if (message.kind !== undefined) {
      obj.kind = checkKindToJSON(message.kind);
    }
    if (message.idRegex !== undefined) {
      obj.idRegex = message.idRegex;
    }
    if (message.withOptionTypes?.length) {
      obj.withOptionTypes = message.withOptionTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Select_CheckPattern>): Query_Select_CheckPattern {
    return Query_Select_CheckPattern.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Select_CheckPattern>): Query_Select_CheckPattern {
    const message = createBaseQuery_Select_CheckPattern() as any;
    message.kind = object.kind ?? undefined;
    message.idRegex = object.idRegex ?? undefined;
    message.withOptionTypes = object.withOptionTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseQuery_Select_StagePattern(): Query_Select_StagePattern {
  return {};
}

export const Query_Select_StagePattern: MessageFns<Query_Select_StagePattern> = {
  encode(_: Query_Select_StagePattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Select_StagePattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Select_StagePattern() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Query_Select_StagePattern {
    return {};
  },

  toJSON(_: Query_Select_StagePattern): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Query_Select_StagePattern>): Query_Select_StagePattern {
    return Query_Select_StagePattern.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Query_Select_StagePattern>): Query_Select_StagePattern {
    const message = createBaseQuery_Select_StagePattern() as any;
    return message;
  },
};

function createBaseQuery_Expand(): Query_Expand {
  return { dependencies: undefined };
}

export const Query_Expand: MessageFns<Query_Expand> = {
  encode(message: Query_Expand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dependencies !== undefined) {
      Query_Expand_Dependencies.encode(message.dependencies, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Expand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Expand() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dependencies = Query_Expand_Dependencies.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Expand {
    return {
      dependencies: isSet(object.dependencies) ? Query_Expand_Dependencies.fromJSON(object.dependencies) : undefined,
    };
  },

  toJSON(message: Query_Expand): unknown {
    const obj: any = {};
    if (message.dependencies !== undefined) {
      obj.dependencies = Query_Expand_Dependencies.toJSON(message.dependencies);
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Expand>): Query_Expand {
    return Query_Expand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Expand>): Query_Expand {
    const message = createBaseQuery_Expand() as any;
    message.dependencies = (object.dependencies !== undefined && object.dependencies !== null)
      ? Query_Expand_Dependencies.fromPartial(object.dependencies)
      : undefined;
    return message;
  },
};

function createBaseQuery_Expand_Dependencies(): Query_Expand_Dependencies {
  return { dependentsDepth: undefined, dependenciesDepth: undefined, onlyResolved: undefined };
}

export const Query_Expand_Dependencies: MessageFns<Query_Expand_Dependencies> = {
  encode(message: Query_Expand_Dependencies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dependentsDepth !== undefined) {
      writer.uint32(8).int32(message.dependentsDepth);
    }
    if (message.dependenciesDepth !== undefined) {
      writer.uint32(16).int32(message.dependenciesDepth);
    }
    if (message.onlyResolved !== undefined) {
      writer.uint32(24).bool(message.onlyResolved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Expand_Dependencies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Expand_Dependencies() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dependentsDepth = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dependenciesDepth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.onlyResolved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Expand_Dependencies {
    return {
      dependentsDepth: isSet(object.dependentsDepth) ? globalThis.Number(object.dependentsDepth) : undefined,
      dependenciesDepth: isSet(object.dependenciesDepth) ? globalThis.Number(object.dependenciesDepth) : undefined,
      onlyResolved: isSet(object.onlyResolved) ? globalThis.Boolean(object.onlyResolved) : undefined,
    };
  },

  toJSON(message: Query_Expand_Dependencies): unknown {
    const obj: any = {};
    if (message.dependentsDepth !== undefined) {
      obj.dependentsDepth = Math.round(message.dependentsDepth);
    }
    if (message.dependenciesDepth !== undefined) {
      obj.dependenciesDepth = Math.round(message.dependenciesDepth);
    }
    if (message.onlyResolved !== undefined) {
      obj.onlyResolved = message.onlyResolved;
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Expand_Dependencies>): Query_Expand_Dependencies {
    return Query_Expand_Dependencies.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Expand_Dependencies>): Query_Expand_Dependencies {
    const message = createBaseQuery_Expand_Dependencies() as any;
    message.dependentsDepth = object.dependentsDepth ?? undefined;
    message.dependenciesDepth = object.dependenciesDepth ?? undefined;
    message.onlyResolved = object.onlyResolved ?? undefined;
    return message;
  },
};

function createBaseQuery_Collect(): Query_Collect {
  return { data: undefined, edits: undefined };
}

export const Query_Collect: MessageFns<Query_Collect> = {
  encode(message: Query_Collect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Query_Collect_Data.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.edits !== undefined) {
      Query_Collect_Edits.encode(message.edits, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Collect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Collect() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Query_Collect_Data.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.edits = Query_Collect_Edits.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Collect {
    return {
      data: isSet(object.data) ? Query_Collect_Data.fromJSON(object.data) : undefined,
      edits: isSet(object.edits) ? Query_Collect_Edits.fromJSON(object.edits) : undefined,
    };
  },

  toJSON(message: Query_Collect): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Query_Collect_Data.toJSON(message.data);
    }
    if (message.edits !== undefined) {
      obj.edits = Query_Collect_Edits.toJSON(message.edits);
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Collect>): Query_Collect {
    return Query_Collect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Collect>): Query_Collect {
    const message = createBaseQuery_Collect() as any;
    message.data = (object.data !== undefined && object.data !== null)
      ? Query_Collect_Data.fromPartial(object.data)
      : undefined;
    message.edits = (object.edits !== undefined && object.edits !== null)
      ? Query_Collect_Edits.fromPartial(object.edits)
      : undefined;
    return message;
  },
};

function createBaseQuery_Collect_Data(): Query_Collect_Data {
  return { check: undefined, stage: undefined };
}

export const Query_Collect_Data: MessageFns<Query_Collect_Data> = {
  encode(message: Query_Collect_Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.check !== undefined) {
      Query_Collect_Data_Check.encode(message.check, writer.uint32(18).fork()).join();
    }
    if (message.stage !== undefined) {
      Query_Collect_Data_Stage.encode(message.stage, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Collect_Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Collect_Data() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.check = Query_Collect_Data_Check.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stage = Query_Collect_Data_Stage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Collect_Data {
    return {
      check: isSet(object.check) ? Query_Collect_Data_Check.fromJSON(object.check) : undefined,
      stage: isSet(object.stage) ? Query_Collect_Data_Stage.fromJSON(object.stage) : undefined,
    };
  },

  toJSON(message: Query_Collect_Data): unknown {
    const obj: any = {};
    if (message.check !== undefined) {
      obj.check = Query_Collect_Data_Check.toJSON(message.check);
    }
    if (message.stage !== undefined) {
      obj.stage = Query_Collect_Data_Stage.toJSON(message.stage);
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Collect_Data>): Query_Collect_Data {
    return Query_Collect_Data.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Collect_Data>): Query_Collect_Data {
    const message = createBaseQuery_Collect_Data() as any;
    message.check = (object.check !== undefined && object.check !== null)
      ? Query_Collect_Data_Check.fromPartial(object.check)
      : undefined;
    message.stage = (object.stage !== undefined && object.stage !== null)
      ? Query_Collect_Data_Stage.fromPartial(object.stage)
      : undefined;
    return message;
  },
};

function createBaseQuery_Collect_Data_Check(): Query_Collect_Data_Check {
  return { options: undefined, resultData: undefined };
}

export const Query_Collect_Data_Check: MessageFns<Query_Collect_Data_Check> = {
  encode(message: Query_Collect_Data_Check, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.options !== undefined) {
      writer.uint32(8).bool(message.options);
    }
    if (message.resultData !== undefined) {
      writer.uint32(16).bool(message.resultData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Collect_Data_Check {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Collect_Data_Check() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.options = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.resultData = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Collect_Data_Check {
    return {
      options: isSet(object.options) ? globalThis.Boolean(object.options) : undefined,
      resultData: isSet(object.resultData) ? globalThis.Boolean(object.resultData) : undefined,
    };
  },

  toJSON(message: Query_Collect_Data_Check): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = message.options;
    }
    if (message.resultData !== undefined) {
      obj.resultData = message.resultData;
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Collect_Data_Check>): Query_Collect_Data_Check {
    return Query_Collect_Data_Check.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Collect_Data_Check>): Query_Collect_Data_Check {
    const message = createBaseQuery_Collect_Data_Check() as any;
    message.options = object.options ?? undefined;
    message.resultData = object.resultData ?? undefined;
    return message;
  },
};

function createBaseQuery_Collect_Data_Stage(): Query_Collect_Data_Stage {
  return {};
}

export const Query_Collect_Data_Stage: MessageFns<Query_Collect_Data_Stage> = {
  encode(_: Query_Collect_Data_Stage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Collect_Data_Stage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Collect_Data_Stage() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Query_Collect_Data_Stage {
    return {};
  },

  toJSON(_: Query_Collect_Data_Stage): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Query_Collect_Data_Stage>): Query_Collect_Data_Stage {
    return Query_Collect_Data_Stage.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Query_Collect_Data_Stage>): Query_Collect_Data_Stage {
    const message = createBaseQuery_Collect_Data_Stage() as any;
    return message;
  },
};

function createBaseQuery_Collect_Edits(): Query_Collect_Edits {
  return { range: undefined, check: undefined, stage: undefined };
}

export const Query_Collect_Edits: MessageFns<Query_Collect_Edits> = {
  encode(message: Query_Collect_Edits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.range !== undefined) {
      RevisionRange.encode(message.range, writer.uint32(10).fork()).join();
    }
    if (message.check !== undefined) {
      writer.uint32(16).bool(message.check);
    }
    if (message.stage !== undefined) {
      writer.uint32(24).bool(message.stage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query_Collect_Edits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery_Collect_Edits() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.range = RevisionRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.check = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stage = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Query_Collect_Edits {
    return {
      range: isSet(object.range) ? RevisionRange.fromJSON(object.range) : undefined,
      check: isSet(object.check) ? globalThis.Boolean(object.check) : undefined,
      stage: isSet(object.stage) ? globalThis.Boolean(object.stage) : undefined,
    };
  },

  toJSON(message: Query_Collect_Edits): unknown {
    const obj: any = {};
    if (message.range !== undefined) {
      obj.range = RevisionRange.toJSON(message.range);
    }
    if (message.check !== undefined) {
      obj.check = message.check;
    }
    if (message.stage !== undefined) {
      obj.stage = message.stage;
    }
    return obj;
  },

  create(base?: DeepPartial<Query_Collect_Edits>): Query_Collect_Edits {
    return Query_Collect_Edits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query_Collect_Edits>): Query_Collect_Edits {
    const message = createBaseQuery_Collect_Edits() as any;
    message.range = (object.range !== undefined && object.range !== null)
      ? RevisionRange.fromPartial(object.range)
      : undefined;
    message.check = object.check ?? undefined;
    message.stage = object.stage ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
