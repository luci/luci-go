// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.0
// source: turboci/graph/orchestrator/v1/stage_attempt_state.proto

/* eslint-disable */

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * StageAttemptState describes the current state of a Stage Attempt.
 *
 * This state machine is much more complicated than Check or Stage state
 * because:
 *   * It revolves around synchronous / asynchronous state reconciliation
 *     with external Executors.
 *   * It subsumes a major portion of the historical WorkNode state machine in
 *     a way that will allow us to be compatible with WorkNode state semantics.
 *
 * This state evolves like:
 *
 *   PENDING -> THROTTLED
 *   PENDING -> RUNNING
 *   PENDING -> COMPLETE
 *   PENDING -> INCOMPLETE
 *   PENDING -> SCHEDULED
 *
 *   THROTTLED -> INCOMPLETE
 *   THROTTLED -> PENDING
 *
 *   SCHEDULED -> RUNNING
 *   SCHEDULED -> COMPLETE
 *   SCHEDULED -> INCOMPLETE
 *
 *   RUNNING -> CANCELLING
 *   RUNNING -> TEARING_DOWN
 *   RUNNING -> COMPLETE
 *   RUNNING -> INCOMPLETE
 *
 *   CANCELLING -> TEARING_DOWN
 *   CANCELLING -> INCOMPLETE
 *
 *   TEARING_DOWN -> COMPLETE
 *   TEARING_DOWN -> INCOMPLETE
 *
 *   INCOMPLETE and COMPLETE are terminal states.
 *
 * The Nth Stage Attempt (i.e. any Stage Attempt after the first) may also be
 * created in an AWAITING_RETRY state rather than PENDING.
 *
 *   AWAITING_RETRY -> PENDING
 *   AWAITING_RETRY -> INCOMPLETE
 *
 * The Orchestrator manages Stage Attempt state evolution in conjunction with
 * the Executor, and explicit state transitions made explicitly by the Stage
 * Attempt itself. The only state transition which can be activated by a third
 * party would be transitions to INCOMPLETE or CANCELLING done when the Stage is
 * cancelled.
 *
 * These states have enum values in multiples of 10 in case we need to add more
 * states later which fall between these initial states.
 */
export enum StageAttemptState {
  /** STAGE_ATTEMPT_STATE_UNKNOWN - UNKNOWN is the default, invalid, state. */
  STAGE_ATTEMPT_STATE_UNKNOWN = 0,
  /**
   * STAGE_ATTEMPT_STATE_PENDING - This is an initial state for a Stage Attempt and indicates that the
   * Stage Attempt is available for an Executor, but either:
   *   * The Orchestrator has not yet sent this Stage Attempt to the Executor.
   *   * [WorkNode only] The Executor has advertised this Stage on pub/sub, but
   *     it has not yet been "Popped".
   *
   * This state can transition to THROTTLED, SCHEDULED, RUNNING, COMPLETE or
   * INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_PENDING = 10,
  /**
   * STAGE_ATTEMPT_STATE_THROTTLED - This state indicates that the Stage Attempt was PENDING, but is currently
   * throttled.
   *
   * Throttling happens when the Executor explicitly marks this Stage Attempt as
   * Throttled, or if an external Update/Patch to a WorkNode increases its
   * availability_time_millis.
   *
   * This should be used by an Executor as a way to explicitly acknowledge a
   * RunStage call for a valid stage, but have the orchestrator keep this stage
   * on ice for some specified amount of time, indicated by setting the `until`
   * field when transitioning the current attempt to Throttled.
   *
   * This state can transition to PENDING or INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_THROTTLED = 20,
  /**
   * STAGE_ATTEMPT_STATE_SCHEDULED - This state indicates that the Stage Attempt was PENDING, but is now picked
   * up for execution by an Executor.
   *
   * This state can transition to RUNNING, COMPLETE or INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_SCHEDULED = 30,
  /**
   * STAGE_ATTEMPT_STATE_RUNNING - This state indicates that the Stage Attempt is now actually being executed
   * by an Executor.
   *
   * This state can transition to COMPLETE or INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_RUNNING = 40,
  /**
   * STAGE_ATTEMPT_STATE_CANCELLING - This state indicates that the Stage Attempt has been cancelled, but this
   * has not yet been communicated to the running Stage Attempt.
   *
   * The Stage Attempt must be assumed to internally consider itself to be
   * RUNNING while viewing this state from the API - this means that the
   * `running` heartbeat and timeout still apply during this state.
   *
   * This state will transition to TEARING_DOWN as soon as TurboCI has
   * confirmation that the Stage Attempt knows it's been cancelled.
   *
   * This state is explicitly different than TEARING_DOWN to avoid the
   * possibility that a Stage is cancelled, but the Stage Attempt doesn't see
   * this until its next valid heartbeat - thus effectively losing up to 1.9x
   * the heartbeat interval out of its TEARING_DOWN timeout.
   */
  STAGE_ATTEMPT_STATE_CANCELLING = 50,
  /**
   * STAGE_ATTEMPT_STATE_TEARING_DOWN - This state indicates that the Stage Attempt is doing some work after the
   * 'RUNNING' state.
   *
   * This is meant to model things like:
   *   * doing best-effort cleanup
   *   * exporting logs or other state to other systems
   *   * things like swarming's isolated upload/cache cleanup phase
   *
   * This state will only be used if the stage attempt has execution policy with
   * a non-zero timeout for this state.
   *
   * This state can transition to COMPLETE or INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_TEARING_DOWN = 60,
  /**
   * STAGE_ATTEMPT_STATE_COMPLETE - This is a final state which indicates that this Stage Attempt finished
   * everything the Executor intended it to do.
   *
   * NOTE: 'finished everything the Executor intended it to do' does not imply
   * workflow-level success criteria such as "all tests passed" or "the build
   * successfully compiled". This is more like "the test harness ran all of the
   * tests (regardless of their outcome)" or "the build started and all possible
   * compilation actions were done". These outcomes are highy varied and nuanced
   * (e.g. tests may be graded on flakiness, not simply pass/fail, build may
   * have failed on an optional target but successfully completed the required
   * targets). These workflow-level outcomes are reflected in the Check Results
   * which this Stage Attempt would have written during its execution.
   *
   * This state is terminal.
   */
  STAGE_ATTEMPT_STATE_COMPLETE = 70,
  /**
   * STAGE_ATTEMPT_STATE_INCOMPLETE - This is a final state which indicates that this Stage Attempt was not able
   * to complete everything that the Executor intended it to do.
   *
   * The Orchestrator itself can transition the Stage Attempt to this state in
   * the event of a heartbeat timeout. This state can also be entered by
   * explicit external actions (e.g. the Executor marking the stage as
   * INCOMPLETE, or external cancellation signals).
   *
   * The Orchestrator will consult the StageExecutionPolicy, and if allowed,
   * will make a new Attempt. This can be blocked when using WriteNodes to
   * mark a Stage Attempt as INCOMPLETE by setting the `block_new_attempts`
   *
   * This state is terminal (but if a retry was requested, a new Stage Attempt
   * may be created for this Stage).
   */
  STAGE_ATTEMPT_STATE_INCOMPLETE = 80,
  /**
   * STAGE_ATTEMPT_STATE_AWAITING_RETRY - This is an initial state and indicates that a previous Stage Attempt went
   * to INCOMPLETE and the Stage's execution policy permitted a retry.
   *
   * Transition to PENDING is automatic after the execution policy's computed
   * retry delay.
   *
   * This state can transition to PENDING or INCOMPLETE.
   */
  STAGE_ATTEMPT_STATE_AWAITING_RETRY = 90,
}

export function stageAttemptStateFromJSON(object: any): StageAttemptState {
  switch (object) {
    case 0:
    case "STAGE_ATTEMPT_STATE_UNKNOWN":
      return StageAttemptState.STAGE_ATTEMPT_STATE_UNKNOWN;
    case 10:
    case "STAGE_ATTEMPT_STATE_PENDING":
      return StageAttemptState.STAGE_ATTEMPT_STATE_PENDING;
    case 20:
    case "STAGE_ATTEMPT_STATE_THROTTLED":
      return StageAttemptState.STAGE_ATTEMPT_STATE_THROTTLED;
    case 30:
    case "STAGE_ATTEMPT_STATE_SCHEDULED":
      return StageAttemptState.STAGE_ATTEMPT_STATE_SCHEDULED;
    case 40:
    case "STAGE_ATTEMPT_STATE_RUNNING":
      return StageAttemptState.STAGE_ATTEMPT_STATE_RUNNING;
    case 50:
    case "STAGE_ATTEMPT_STATE_CANCELLING":
      return StageAttemptState.STAGE_ATTEMPT_STATE_CANCELLING;
    case 60:
    case "STAGE_ATTEMPT_STATE_TEARING_DOWN":
      return StageAttemptState.STAGE_ATTEMPT_STATE_TEARING_DOWN;
    case 70:
    case "STAGE_ATTEMPT_STATE_COMPLETE":
      return StageAttemptState.STAGE_ATTEMPT_STATE_COMPLETE;
    case 80:
    case "STAGE_ATTEMPT_STATE_INCOMPLETE":
      return StageAttemptState.STAGE_ATTEMPT_STATE_INCOMPLETE;
    case 90:
    case "STAGE_ATTEMPT_STATE_AWAITING_RETRY":
      return StageAttemptState.STAGE_ATTEMPT_STATE_AWAITING_RETRY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageAttemptState");
  }
}

export function stageAttemptStateToJSON(object: StageAttemptState): string {
  switch (object) {
    case StageAttemptState.STAGE_ATTEMPT_STATE_UNKNOWN:
      return "STAGE_ATTEMPT_STATE_UNKNOWN";
    case StageAttemptState.STAGE_ATTEMPT_STATE_PENDING:
      return "STAGE_ATTEMPT_STATE_PENDING";
    case StageAttemptState.STAGE_ATTEMPT_STATE_THROTTLED:
      return "STAGE_ATTEMPT_STATE_THROTTLED";
    case StageAttemptState.STAGE_ATTEMPT_STATE_SCHEDULED:
      return "STAGE_ATTEMPT_STATE_SCHEDULED";
    case StageAttemptState.STAGE_ATTEMPT_STATE_RUNNING:
      return "STAGE_ATTEMPT_STATE_RUNNING";
    case StageAttemptState.STAGE_ATTEMPT_STATE_CANCELLING:
      return "STAGE_ATTEMPT_STATE_CANCELLING";
    case StageAttemptState.STAGE_ATTEMPT_STATE_TEARING_DOWN:
      return "STAGE_ATTEMPT_STATE_TEARING_DOWN";
    case StageAttemptState.STAGE_ATTEMPT_STATE_COMPLETE:
      return "STAGE_ATTEMPT_STATE_COMPLETE";
    case StageAttemptState.STAGE_ATTEMPT_STATE_INCOMPLETE:
      return "STAGE_ATTEMPT_STATE_INCOMPLETE";
    case StageAttemptState.STAGE_ATTEMPT_STATE_AWAITING_RETRY:
      return "STAGE_ATTEMPT_STATE_AWAITING_RETRY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageAttemptState");
  }
}
