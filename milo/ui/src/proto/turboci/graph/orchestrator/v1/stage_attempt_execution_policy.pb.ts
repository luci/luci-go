// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../google/protobuf/duration.pb";

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * StageAttemptExecutionPolicy describes constraints on how a StageAttempt
 * may be executed by the Orchestrator.
 */
export interface StageAttemptExecutionPolicy {
  /** The heartbeat policies for Attempts of this Stage. */
  readonly attemptHeartbeat?:
    | StageAttemptExecutionPolicy_Heartbeat
    | undefined;
  /** The timeout policies for the StageAttempt. */
  readonly timeout?: StageAttemptExecutionPolicy_Timeout | undefined;
}

/**
 * Heartbeat indicates the minimum heartbeat interval for Stage Attempts in
 * a given state.
 *
 * Heartbeats allow the Orchestrator to detect missing stages sooner than
 * the execution timeout, by declaring non-receipt of a heartbeat message for
 * a certain amount of time to mean that the stage is gone and should be
 * treated accordingly.
 *
 * If, say, `pending` is 30s, it means that the executor must send a Heartbeat
 * RPC to the Orchestrator at least once every 30s while the Stage Attempt is
 * in the PENDING state. It's allowed to heartbeat faster than this interval,
 * but shouldn't be necessary.
 *
 * In addition, we want to ensure that a single lost heartbeat doesn't time
 * out an expensive stage that might be close to completion, so the
 * Orchestrator will allow 1 missed heartbeat before declaring the next
 * non-received heartbeat to mean the stage is gone and should be marked
 * INCOMPLETE. However, missing/late heartbeats will be monitored and alerted
 * on, as they are likely pre-indicators of something about to go wrong.
 *
 * In other words, if the Orchestrator doesn't get an RPC from the Stage
 * Attempt before missing 2 heartbeats the Orchestrator will mark the Stage
 * Attempt as INCOMPLETE.
 *
 * It is expected that clients writing heartbeats will write them at an
 * interval faster than the minimum required here to account for network
 * latency and delays (including contention on a busy client machine).
 * A suggested rule of thumb is to heartbeat at an interval which is 90% of
 * the interval here. So if there is a 30s interval for RUNNING, the client
 * would target doing the RPC to heartbeat every 27 seconds. Ultimately,
 * though, it's up to the Executor how to ensure that a heartbeat gets to the
 * Orchestrator under this deadline.
 *
 * The fields here correspond to StageAttemptState values where a heartbeat
 * is applicable.
 *
 * It is TYPICAL to only define a heartbeat for `running`.
 *
 * Heartbeat intervals, if set, currently cannot exceed 30 minutes.
 */
export interface StageAttemptExecutionPolicy_Heartbeat {
  /**
   * The expected duration that a Stage Attempt can be in the SCHEDULED
   * state without sending a heartbeat.
   *
   * If unset, then there is no required heartbeat cadence, though the stage
   * is still subject to timeouts for the phase.
   */
  readonly scheduled?:
    | Duration
    | undefined;
  /**
   * The expected duration that a Stage Attempt can be in the RUNNING state
   * without sending a heartbeat.
   *
   * If unset, then there is no required heartbeat cadence, though the stage
   * is still subject to timeouts for the phase.
   *
   * NOTE: This heartbeat still applies during the CANCELLING state - it's
   * expected that CANCELLING only applies to Stage Attempts which are
   * RUNNING, but before the Stage Attempt actually knows this.
   */
  readonly running?:
    | Duration
    | undefined;
  /**
   * The expected duration that a Stage Attempt can be in the TEARING_DOWN
   * state without sending a heartbeat.
   *
   * If unset, then there is no required heartbeat cadence, though the stage
   * is still subject to timeouts for the phase.
   */
  readonly tearingDown?: Duration | undefined;
}

/**
 * Timeout describes the maximum amount of time a Stage Attempt can be in a
 * given state (in addition to restrictions imposed by Heartbeat).
 *
 * The Orchestrator will automatically transition a Stage Attempt to
 * INCOMPLETE after the timeout has passed if the Stage Attempt has not yet
 * transitioned to the next state.
 */
export interface StageAttemptExecutionPolicy_Timeout {
  /**
   * The maximum amount of time a Stage Attempt can be in the
   * PENDING/THROTTLED state.
   *
   * It is calculated from the time the Attempt first enters `PENDING` to the
   * time that it leaves `PENDING` for a non-THROTTLED state.
   *
   * If unset, then there is a large default limit on how long a Stage Attempt
   * can be in the PENDING/THROTTLED state.
   */
  readonly pendingThrottled?:
    | Duration
    | undefined;
  /**
   * The maximum amount of time a Stage Attempt can be in the SCHEDULED
   * state.
   *
   * If unset, then there is a large default limit on how long a Stage Attempt
   * can be in the SCHEDULED state.
   */
  readonly scheduled?:
    | Duration
    | undefined;
  /**
   * The maximum amount of time a Stage Attempt can be in the RUNNING state.
   *
   * If unset, then there is a large default limit on how long a Stage Attempt
   * can be in the RUNNING state.
   *
   * NOTE: This timeout still applies during the CANCELLING state - it's
   * expected that CANCELLING only applies to Stage Attempts which are
   * RUNNING, but before the Stage Attempt actually knows this.
   */
  readonly running?:
    | Duration
    | undefined;
  /**
   * The maximum amount of time a Stage Attempt can be in the
   * TEARING_DOWN state.
   *
   * If unset, then there is a large default limit on how long a Stage Attempt can be in
   * the TEARING_DOWN state.
   */
  readonly tearingDown?: Duration | undefined;
}

function createBaseStageAttemptExecutionPolicy(): StageAttemptExecutionPolicy {
  return { attemptHeartbeat: undefined, timeout: undefined };
}

export const StageAttemptExecutionPolicy: MessageFns<StageAttemptExecutionPolicy> = {
  encode(message: StageAttemptExecutionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attemptHeartbeat !== undefined) {
      StageAttemptExecutionPolicy_Heartbeat.encode(message.attemptHeartbeat, writer.uint32(10).fork()).join();
    }
    if (message.timeout !== undefined) {
      StageAttemptExecutionPolicy_Timeout.encode(message.timeout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageAttemptExecutionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageAttemptExecutionPolicy() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attemptHeartbeat = StageAttemptExecutionPolicy_Heartbeat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = StageAttemptExecutionPolicy_Timeout.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageAttemptExecutionPolicy {
    return {
      attemptHeartbeat: isSet(object.attemptHeartbeat)
        ? StageAttemptExecutionPolicy_Heartbeat.fromJSON(object.attemptHeartbeat)
        : undefined,
      timeout: isSet(object.timeout) ? StageAttemptExecutionPolicy_Timeout.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: StageAttemptExecutionPolicy): unknown {
    const obj: any = {};
    if (message.attemptHeartbeat !== undefined) {
      obj.attemptHeartbeat = StageAttemptExecutionPolicy_Heartbeat.toJSON(message.attemptHeartbeat);
    }
    if (message.timeout !== undefined) {
      obj.timeout = StageAttemptExecutionPolicy_Timeout.toJSON(message.timeout);
    }
    return obj;
  },

  create(base?: DeepPartial<StageAttemptExecutionPolicy>): StageAttemptExecutionPolicy {
    return StageAttemptExecutionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageAttemptExecutionPolicy>): StageAttemptExecutionPolicy {
    const message = createBaseStageAttemptExecutionPolicy() as any;
    message.attemptHeartbeat = (object.attemptHeartbeat !== undefined && object.attemptHeartbeat !== null)
      ? StageAttemptExecutionPolicy_Heartbeat.fromPartial(object.attemptHeartbeat)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? StageAttemptExecutionPolicy_Timeout.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

function createBaseStageAttemptExecutionPolicy_Heartbeat(): StageAttemptExecutionPolicy_Heartbeat {
  return { scheduled: undefined, running: undefined, tearingDown: undefined };
}

export const StageAttemptExecutionPolicy_Heartbeat: MessageFns<StageAttemptExecutionPolicy_Heartbeat> = {
  encode(message: StageAttemptExecutionPolicy_Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduled !== undefined) {
      Duration.encode(message.scheduled, writer.uint32(10).fork()).join();
    }
    if (message.running !== undefined) {
      Duration.encode(message.running, writer.uint32(18).fork()).join();
    }
    if (message.tearingDown !== undefined) {
      Duration.encode(message.tearingDown, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageAttemptExecutionPolicy_Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageAttemptExecutionPolicy_Heartbeat() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheduled = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.running = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tearingDown = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageAttemptExecutionPolicy_Heartbeat {
    return {
      scheduled: isSet(object.scheduled) ? Duration.fromJSON(object.scheduled) : undefined,
      running: isSet(object.running) ? Duration.fromJSON(object.running) : undefined,
      tearingDown: isSet(object.tearingDown) ? Duration.fromJSON(object.tearingDown) : undefined,
    };
  },

  toJSON(message: StageAttemptExecutionPolicy_Heartbeat): unknown {
    const obj: any = {};
    if (message.scheduled !== undefined) {
      obj.scheduled = Duration.toJSON(message.scheduled);
    }
    if (message.running !== undefined) {
      obj.running = Duration.toJSON(message.running);
    }
    if (message.tearingDown !== undefined) {
      obj.tearingDown = Duration.toJSON(message.tearingDown);
    }
    return obj;
  },

  create(base?: DeepPartial<StageAttemptExecutionPolicy_Heartbeat>): StageAttemptExecutionPolicy_Heartbeat {
    return StageAttemptExecutionPolicy_Heartbeat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageAttemptExecutionPolicy_Heartbeat>): StageAttemptExecutionPolicy_Heartbeat {
    const message = createBaseStageAttemptExecutionPolicy_Heartbeat() as any;
    message.scheduled = (object.scheduled !== undefined && object.scheduled !== null)
      ? Duration.fromPartial(object.scheduled)
      : undefined;
    message.running = (object.running !== undefined && object.running !== null)
      ? Duration.fromPartial(object.running)
      : undefined;
    message.tearingDown = (object.tearingDown !== undefined && object.tearingDown !== null)
      ? Duration.fromPartial(object.tearingDown)
      : undefined;
    return message;
  },
};

function createBaseStageAttemptExecutionPolicy_Timeout(): StageAttemptExecutionPolicy_Timeout {
  return { pendingThrottled: undefined, scheduled: undefined, running: undefined, tearingDown: undefined };
}

export const StageAttemptExecutionPolicy_Timeout: MessageFns<StageAttemptExecutionPolicy_Timeout> = {
  encode(message: StageAttemptExecutionPolicy_Timeout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingThrottled !== undefined) {
      Duration.encode(message.pendingThrottled, writer.uint32(10).fork()).join();
    }
    if (message.scheduled !== undefined) {
      Duration.encode(message.scheduled, writer.uint32(18).fork()).join();
    }
    if (message.running !== undefined) {
      Duration.encode(message.running, writer.uint32(26).fork()).join();
    }
    if (message.tearingDown !== undefined) {
      Duration.encode(message.tearingDown, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageAttemptExecutionPolicy_Timeout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageAttemptExecutionPolicy_Timeout() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingThrottled = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scheduled = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.running = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tearingDown = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageAttemptExecutionPolicy_Timeout {
    return {
      pendingThrottled: isSet(object.pendingThrottled) ? Duration.fromJSON(object.pendingThrottled) : undefined,
      scheduled: isSet(object.scheduled) ? Duration.fromJSON(object.scheduled) : undefined,
      running: isSet(object.running) ? Duration.fromJSON(object.running) : undefined,
      tearingDown: isSet(object.tearingDown) ? Duration.fromJSON(object.tearingDown) : undefined,
    };
  },

  toJSON(message: StageAttemptExecutionPolicy_Timeout): unknown {
    const obj: any = {};
    if (message.pendingThrottled !== undefined) {
      obj.pendingThrottled = Duration.toJSON(message.pendingThrottled);
    }
    if (message.scheduled !== undefined) {
      obj.scheduled = Duration.toJSON(message.scheduled);
    }
    if (message.running !== undefined) {
      obj.running = Duration.toJSON(message.running);
    }
    if (message.tearingDown !== undefined) {
      obj.tearingDown = Duration.toJSON(message.tearingDown);
    }
    return obj;
  },

  create(base?: DeepPartial<StageAttemptExecutionPolicy_Timeout>): StageAttemptExecutionPolicy_Timeout {
    return StageAttemptExecutionPolicy_Timeout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageAttemptExecutionPolicy_Timeout>): StageAttemptExecutionPolicy_Timeout {
    const message = createBaseStageAttemptExecutionPolicy_Timeout() as any;
    message.pendingThrottled = (object.pendingThrottled !== undefined && object.pendingThrottled !== null)
      ? Duration.fromPartial(object.pendingThrottled)
      : undefined;
    message.scheduled = (object.scheduled !== undefined && object.scheduled !== null)
      ? Duration.fromPartial(object.scheduled)
      : undefined;
    message.running = (object.running !== undefined && object.running !== null)
      ? Duration.fromPartial(object.running)
      : undefined;
    message.tearingDown = (object.tearingDown !== undefined && object.tearingDown !== null)
      ? Duration.fromPartial(object.tearingDown)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
