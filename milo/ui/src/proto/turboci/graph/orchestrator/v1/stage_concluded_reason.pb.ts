// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.0
// source: turboci/graph/orchestrator/v1/stage_concluded_reason.proto

/* eslint-disable */

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * Describes why a stage is not in PLANNED or ATTEMPTING state anymore.
 *
 * Set for stages that are in AWAITING_GROUP or FINAL states.
 */
export enum StageConcludedReason {
  /** STAGE_CONCLUDED_REASON_UNKNOWN - UNKNOWN means the stage is not concluded yet. */
  STAGE_CONCLUDED_REASON_UNKNOWN = 0,
  /**
   * STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE - The last attempt to run the stage finished in STAGE_ATTEMPT_STATE_COMPLETE
   * state.
   */
  STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE = 1,
  /**
   * STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT - The last attempt to run the stage finished in STAGE_ATTEMPT_STATE_INCOMPLETE
   * state and the stage reached max allowed number of attempt retries.
   */
  STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT = 2,
  /**
   * STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY - The last attempt to run the stage finished in STAGE_ATTEMPT_STATE_INCOMPLETE
   * state and the executor indicated that there should be no retry.
   */
  STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY = 3,
  /**
   * STAGE_CONCLUDED_REASON_TIMEOUT - There's no time left to run an attempt per `stage_timeout` in
   * StageExecutionPolicy.
   *
   * Can either happen after retrying an incomplete attempt or before the first
   * attempt (if the stage was in PLANNING state for too long).
   *
   * See StageExecutionPolicy for details.
   */
  STAGE_CONCLUDED_REASON_TIMEOUT = 4,
  /** STAGE_CONCLUDED_REASON_CANCELLED - The Stage was explicitly cancelled via WriteNodes. */
  STAGE_CONCLUDED_REASON_CANCELLED = 5,
}

export function stageConcludedReasonFromJSON(object: any): StageConcludedReason {
  switch (object) {
    case 0:
    case "STAGE_CONCLUDED_REASON_UNKNOWN":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_UNKNOWN;
    case 1:
    case "STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE;
    case 2:
    case "STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT;
    case 3:
    case "STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY;
    case 4:
    case "STAGE_CONCLUDED_REASON_TIMEOUT":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_TIMEOUT;
    case 5:
    case "STAGE_CONCLUDED_REASON_CANCELLED":
      return StageConcludedReason.STAGE_CONCLUDED_REASON_CANCELLED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageConcludedReason");
  }
}

export function stageConcludedReasonToJSON(object: StageConcludedReason): string {
  switch (object) {
    case StageConcludedReason.STAGE_CONCLUDED_REASON_UNKNOWN:
      return "STAGE_CONCLUDED_REASON_UNKNOWN";
    case StageConcludedReason.STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE:
      return "STAGE_CONCLUDED_REASON_ATTEMPT_COMPLETE";
    case StageConcludedReason.STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT:
      return "STAGE_CONCLUDED_REASON_NO_RETRIES_LEFT";
    case StageConcludedReason.STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY:
      return "STAGE_CONCLUDED_REASON_FINAL_ATTEMPT_BLOCKED_RETRY";
    case StageConcludedReason.STAGE_CONCLUDED_REASON_TIMEOUT:
      return "STAGE_CONCLUDED_REASON_TIMEOUT";
    case StageConcludedReason.STAGE_CONCLUDED_REASON_CANCELLED:
      return "STAGE_CONCLUDED_REASON_CANCELLED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StageConcludedReason");
  }
}
