// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.0
// source: turboci/graph/orchestrator/v1/turbo_ci_orchestrator_service.proto

/* eslint-disable */
import { CreateWorkPlanRequest } from "./create_workplan_request.pb";
import { CreateWorkPlanResponse } from "./create_workplan_response.pb";
import { QueryNodesRequest } from "./query_nodes_request.pb";
import { QueryNodesResponse } from "./query_nodes_response.pb";
import { WriteNodesRequest } from "./write_nodes_request.pb";
import { WriteNodesResponse } from "./write_nodes_response.pb";

export const protobufPackage = "turboci.graph.orchestrator.v1";

/**
 * TurboCIOrchestrator is the API for interacting with the TurboCI
 * Orchestrator.
 *
 * These RPCs will require certain permissions, acquired via project-scoped
 * LUCI ACLs (configured via
 * https://chromium.googlesource.com/infra/luci/luci-go/+/refs/heads/main/lucicfg/doc/README.md#luci.binding),
 * for the data being acted upon. A more complete description of the LUCI
 * authorization model is at http://go/luci-authorization (Googlers only),
 * with a more sparse description available to non-Googlers at
 * https://chromium.googlesource.com/infra/luci/luci-go/+/refs/heads/main/lucicfg/doc/README.md#ACLs.
 *
 * Additional notes for understanding Turbo CI's use of this permissions model:
 * * Every message has a LUCI realm (as a `string realm` field in these protos)
 * either in the message or a containing message, and permissions to act on that
 * message are configured for the realm.
 * * Nested messages (e.g. a Check option inside of a Check) may be assigned to
 * a different realm than their parent. Permission to read or write a nested
 * message also requires the corresponding permission for all parent nodes, and
 * for the containing Workplan.
 */
export interface TurboCIOrchestrator {
  /**
   * CreateWorkPlan creates a new WorkPlan and returns a Workplan Creator
   * token, which can be used to create checks and stages in this Workplan.
   *
   * Currently can only create empty work plans that can later be populated via
   * WriteNodes call.
   */
  CreateWorkPlan(request: CreateWorkPlanRequest): Promise<CreateWorkPlanResponse>;
  /**
   * WriteNodes transactionally writes or updates multiple nodes within a
   * WorkPlan.
   *
   * NOTE: Simple workflows can have all Checks, Check options and Stages in the
   * same realm, minimizing the number of required bindings.
   *
   * If a correctly encoded Stage Attempt token is used for
   * WriteNodesRequest.token, then a
   * turboci.graph.orchestrator.v1.StageAttemptCurrentState will be embedded as
   * an error detail, and the client is expected to respect the indicated
   * state.
   */
  WriteNodes(request: WriteNodesRequest): Promise<WriteNodesResponse>;
  /**
   * QueryNodes allows querying nodes in a fairly simple way.
   *
   * In the future we may add a more advanced API to open up more of GQL's
   * underlying expressiveness.
   *
   * If a correctly encoded Stage Attempt token is used for
   * QueryNodesRequest.token, then a
   * turboci.graph.orchestrator.v1.StageAttemptCurrentState will be embedded as
   * an error detail, and the client is expected to respect the indicated
   * state.
   */
  QueryNodes(request: QueryNodesRequest): Promise<QueryNodesResponse>;
}

export const TurboCIOrchestratorServiceName = "turboci.graph.orchestrator.v1.TurboCIOrchestrator";
export class TurboCIOrchestratorClientImpl implements TurboCIOrchestrator {
  static readonly DEFAULT_SERVICE = TurboCIOrchestratorServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TurboCIOrchestratorServiceName;
    this.rpc = rpc;
    this.CreateWorkPlan = this.CreateWorkPlan.bind(this);
    this.WriteNodes = this.WriteNodes.bind(this);
    this.QueryNodes = this.QueryNodes.bind(this);
  }
  CreateWorkPlan(request: CreateWorkPlanRequest): Promise<CreateWorkPlanResponse> {
    const data = CreateWorkPlanRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CreateWorkPlan", data);
    return promise.then((data) => CreateWorkPlanResponse.fromJSON(data));
  }

  WriteNodes(request: WriteNodesRequest): Promise<WriteNodesResponse> {
    const data = WriteNodesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "WriteNodes", data);
    return promise.then((data) => WriteNodesResponse.fromJSON(data));
  }

  QueryNodes(request: QueryNodesRequest): Promise<QueryNodesResponse> {
    const data = QueryNodesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryNodes", data);
    return promise.then((data) => QueryNodesResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}
