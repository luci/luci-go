// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: turboci/graph/ids/v1/identifier.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp.pb";

export const protobufPackage = "turboci.graph.ids.v1";

/**
 * A generic identifier that can be used to identify all TurboCI graph nodes.
 *
 * Within some message (e.g. Check), you may see usage of Identifier.X directly
 * to indicate that the Identifier there can only be a single kind. Having the
 * Identifier container, however, allows for generic structures like Edge which
 * can refer to multiple kinds of nodes in different contexts.
 *
 * No string identifiers here may contain a colon.
 */
export interface Identifier {
  /** A whole WorkPlan. */
  readonly workPlan?:
    | WorkPlan
    | undefined;
  /** A Check within a WorkPlan. */
  readonly check?:
    | Check
    | undefined;
  /** Option data for a Check. */
  readonly checkOption?:
    | CheckOption
    | undefined;
  /** A particular Check.Result. */
  readonly checkResult?:
    | CheckResult
    | undefined;
  /** Data associated with a particular result in a Check. */
  readonly checkResultDatum?:
    | CheckResultDatum
    | undefined;
  /** An edit to a Check. */
  readonly checkEdit?:
    | CheckEdit
    | undefined;
  /** Option data for an edit to a Check. */
  readonly checkEditOption?:
    | CheckEditOption
    | undefined;
  /** A Stage within a WorkPlan. */
  readonly stage?:
    | Stage
    | undefined;
  /** A specific attempt at a Stage. */
  readonly stageAttempt?:
    | StageAttempt
    | undefined;
  /** An edit to a Stage. */
  readonly stageEdit?: StageEdit | undefined;
}

/**
 * Identifies an entire TurboCI WorkPlan.
 *
 * Serialized as JUST "<id>", but this must start with "L".
 *
 * The portion of `id` after "L" will be an integer.
 */
export interface WorkPlan {
  /**
   * Globally unique identifier for this WorkPlan.
   *
   * Has the form "L<digits>" and is generated by the TurboCI service.
   */
  readonly id?: string | undefined;
}

/**
 * Identifies a Check within a WorkPlan.
 *
 * Serialized as "<work_plan>:C<id>".
 *
 * E.g. "<work_plan.id>:C<id>"
 */
export interface Check {
  /** The WorkPlan this check is scoped to. */
  readonly workPlan?:
    | WorkPlan
    | undefined;
  /**
   * An opaque identifier unique within this WorkPlan.
   *
   * Provided by the Stage which added this Check.
   *
   * TBD: Specify the format of this ID as regex - it should have a maximum
   * length and not be allowed to contain a colon at the very least.
   */
  readonly id?: string | undefined;
}

/**
 * Identifies an option associated with a Check within a WorkPlan.
 *
 * Serializes as "<check>:O<idx>".
 *
 * E.g. "<check.work_plan.id>:C<check.id>:O<idx>"
 *
 * A CheckOption is a single `Datum`.
 *
 * This is separate from `Check` because it may reside in a different realm
 * than the Check itself.
 */
export interface CheckOption {
  /** The check that this option belongs to. */
  readonly check?:
    | Check
    | undefined;
  /**
   * The 1-based index of this datum within the Check.options list.
   *
   * This is 1-based to distinguish it from 0/unset (which is invalid).
   */
  readonly idx?: number | undefined;
}

/**
 * Identifies a Check Result within a WorkPlan.
 *
 * Serialized as "<check>:R<results_idx>".
 *
 * E.g. "<check.work_plan.id>:C<check.id>:R<idx>"
 *
 * This is separate from `Check` because it may reside in a different realm
 * than the Check itself.
 */
export interface CheckResult {
  /** The check that this result belongs to. */
  readonly check?:
    | Check
    | undefined;
  /**
   * The 1-based index of this result within the Check.results list.
   *
   * This is 1-based to distinguish it from 0/unset (which is invalid).
   */
  readonly idx?: number | undefined;
}

/**
 * Identifies a Datum for a Check's Result within a WorkPlan.
 *
 * Serialized as "<result>:D<results_data_idx>".
 *
 * E.g. "<result.check.work_plan.id>:C<result.check.id>:R<result.idx>:D<idx>"
 *
 * This is separate from `Check` because it may reside in a different realm
 * than the Check itself.
 */
export interface CheckResultDatum {
  /** The check resunt that this datum belongs to. */
  readonly result?:
    | CheckResult
    | undefined;
  /**
   * The 1-based index of this datum within the Check.Result.data list.
   *
   * This is 1-based to distinguish it from 0/unset (which is invalid).
   */
  readonly idx?: number | undefined;
}

/**
 * Identifies a CheckEdit within a WorkPlan.
 *
 * Serialized as "<check>:E<version>".
 *
 * E.g.
 * "L<check.work_plan.id>:C<check.id>:V<version.seconds>/<version.nanos>"
 */
export interface CheckEdit {
  /** The check that this edit belongs to. */
  readonly check?:
    | Check
    | undefined;
  /** The version of the Check at the time this edit was made. */
  readonly version?: string | undefined;
}

/**
 * Identifies a CheckEditOption within a WorkPlan.
 *
 * Serialized as "<check_edit>:O<idx>".
 *
 * E.g.
 * "L<check_edit.check.work_plan.id>:C<check_edit.check.id>:V<check_edit.version.seconds>/<check_edit.version.nanos>:D<idx>"
 *
 * This is separate from `CheckEdit` because it may reside in a different
 * realm than the CheckEdit itself.
 */
export interface CheckEditOption {
  /** The check that this edit belongs to. */
  readonly checkEdit?:
    | CheckEdit
    | undefined;
  /**
   * The 1-based index of this datum within the check.options list.
   *
   * This is 1-based to distinguish it from 0/unset (which is invalid).
   */
  readonly idx?: number | undefined;
}

/**
 * Identifies a Stage within a WorkPlan.
 *
 * <id> MUST start with either "S" or "N".
 *
 * N-flavored Stages have additional synchronization with the WorkNodes
 * table. These will have digits following the `N` prefix.
 *
 * S-flavored Stages don't have any special treatment and do not have a
 * restricted suffix after the `S` prefix (other than the usual prohibition of
 * the use of colons).
 *
 * Serialized as "<work_plan>:<id>" (note lack of prefix before <id>).
 *
 * E.g. "L<work_plan.id>:<id>"
 *
 * We considered adding a boolean like `is_worknode` to indicate the
 * underlying nature of this Stage, but felt that it would lead to more
 * complexity at callsites, because it would allow some invalid expressions
 * like:
 *   * `{work_plan: ..., id: "123"}` referring to a WorkNode.
 *   * `{work_plan: ..., is_worknode: true, id: "abc"}` referring to a Stage.
 *
 * Instead, the N/S prefix is part of the `id` field - but this means that
 * Identifier.Stage is unsatisfyingly unlike Identifier.Check. The main
 * difference is that for the new Stage API `id` here can be an intentionally
 * meaningful string (like Check.id), whereas in the WorkNode API it's an
 * assigned integer. We strongly want to keep 1:1 Stage:WorkNode mapping, so
 * this compromise allows that with hopefully not-too-much complexity overhead
 * for non-WorkNode stages.
 */
export interface Stage {
  /** The WorkPlan that this Stage belongs to. */
  readonly workPlan?:
    | WorkPlan
    | undefined;
  /**
   * An opaque identifier unique within this WorkPlan.
   *
   * For Android WorkNodes, this will be "N" followed by a decimal integer.
   * Otherwise this will start with "S" and have a suffix supplied by the
   * Stage which added this.
   *
   * If the type of this Stage is WorkNode, then this MAY start with "N"
   * followed by a decimal representation of an integer. If this is the case,
   * then this Stage has special handling in the graph service to keep it
   * synchronized with its identical twin in the WorkNodes table.
   *
   * Otherwise this MUST start with "S".
   */
  readonly id?: string | undefined;
}

/**
 * Identifies a Stage Attempt within a Stage.
 *
 * Note that Stage.Attempt is embedded within a Stage, but we need a reference
 * to it from various places (e.g. Check and Stage Edits), so it has an
 * Identifier here. Most users will use Stage instead.
 *
 * Serialized as "<stage>:A<attempts_idx>".
 *
 * E.g. "<stage.work_plan.id>:<stage.id>:A<attempts_idx>"
 */
export interface StageAttempt {
  /** The Stage that this Stage Attempt belongs to. */
  readonly stage?:
    | Stage
    | undefined;
  /**
   * The 1-based index of this attempt within the Stage.attempts list.
   *
   * This is 1-based to distinguish it from 0/unset (which is invalid).
   */
  readonly idx?: number | undefined;
}

/**
 * Identifies a Stage Edit within a WorkPlan.
 *
 * Serialized as "<stage>:E<version>".
 *
 * E.g.
 * "<stage.work_plan.id>:<stage.id>:V<version.seconds>/<version.nanos>"
 */
export interface StageEdit {
  /** The stage that this edit belongs to. */
  readonly stage?:
    | Stage
    | undefined;
  /** The version of the Stage at the time this edit was made. */
  readonly version?: string | undefined;
}

function createBaseIdentifier(): Identifier {
  return {
    workPlan: undefined,
    check: undefined,
    checkOption: undefined,
    checkResult: undefined,
    checkResultDatum: undefined,
    checkEdit: undefined,
    checkEditOption: undefined,
    stage: undefined,
    stageAttempt: undefined,
    stageEdit: undefined,
  };
}

export const Identifier: MessageFns<Identifier> = {
  encode(message: Identifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workPlan !== undefined) {
      WorkPlan.encode(message.workPlan, writer.uint32(10).fork()).join();
    }
    if (message.check !== undefined) {
      Check.encode(message.check, writer.uint32(18).fork()).join();
    }
    if (message.checkOption !== undefined) {
      CheckOption.encode(message.checkOption, writer.uint32(26).fork()).join();
    }
    if (message.checkResult !== undefined) {
      CheckResult.encode(message.checkResult, writer.uint32(34).fork()).join();
    }
    if (message.checkResultDatum !== undefined) {
      CheckResultDatum.encode(message.checkResultDatum, writer.uint32(42).fork()).join();
    }
    if (message.checkEdit !== undefined) {
      CheckEdit.encode(message.checkEdit, writer.uint32(50).fork()).join();
    }
    if (message.checkEditOption !== undefined) {
      CheckEditOption.encode(message.checkEditOption, writer.uint32(58).fork()).join();
    }
    if (message.stage !== undefined) {
      Stage.encode(message.stage, writer.uint32(66).fork()).join();
    }
    if (message.stageAttempt !== undefined) {
      StageAttempt.encode(message.stageAttempt, writer.uint32(74).fork()).join();
    }
    if (message.stageEdit !== undefined) {
      StageEdit.encode(message.stageEdit, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Identifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentifier() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workPlan = WorkPlan.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.check = Check.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkOption = CheckOption.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checkResult = CheckResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checkResultDatum = CheckResultDatum.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checkEdit = CheckEdit.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checkEditOption = CheckEditOption.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stage = Stage.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.stageAttempt = StageAttempt.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.stageEdit = StageEdit.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Identifier {
    return {
      workPlan: isSet(object.workPlan) ? WorkPlan.fromJSON(object.workPlan) : undefined,
      check: isSet(object.check) ? Check.fromJSON(object.check) : undefined,
      checkOption: isSet(object.checkOption) ? CheckOption.fromJSON(object.checkOption) : undefined,
      checkResult: isSet(object.checkResult) ? CheckResult.fromJSON(object.checkResult) : undefined,
      checkResultDatum: isSet(object.checkResultDatum) ? CheckResultDatum.fromJSON(object.checkResultDatum) : undefined,
      checkEdit: isSet(object.checkEdit) ? CheckEdit.fromJSON(object.checkEdit) : undefined,
      checkEditOption: isSet(object.checkEditOption) ? CheckEditOption.fromJSON(object.checkEditOption) : undefined,
      stage: isSet(object.stage) ? Stage.fromJSON(object.stage) : undefined,
      stageAttempt: isSet(object.stageAttempt) ? StageAttempt.fromJSON(object.stageAttempt) : undefined,
      stageEdit: isSet(object.stageEdit) ? StageEdit.fromJSON(object.stageEdit) : undefined,
    };
  },

  toJSON(message: Identifier): unknown {
    const obj: any = {};
    if (message.workPlan !== undefined) {
      obj.workPlan = WorkPlan.toJSON(message.workPlan);
    }
    if (message.check !== undefined) {
      obj.check = Check.toJSON(message.check);
    }
    if (message.checkOption !== undefined) {
      obj.checkOption = CheckOption.toJSON(message.checkOption);
    }
    if (message.checkResult !== undefined) {
      obj.checkResult = CheckResult.toJSON(message.checkResult);
    }
    if (message.checkResultDatum !== undefined) {
      obj.checkResultDatum = CheckResultDatum.toJSON(message.checkResultDatum);
    }
    if (message.checkEdit !== undefined) {
      obj.checkEdit = CheckEdit.toJSON(message.checkEdit);
    }
    if (message.checkEditOption !== undefined) {
      obj.checkEditOption = CheckEditOption.toJSON(message.checkEditOption);
    }
    if (message.stage !== undefined) {
      obj.stage = Stage.toJSON(message.stage);
    }
    if (message.stageAttempt !== undefined) {
      obj.stageAttempt = StageAttempt.toJSON(message.stageAttempt);
    }
    if (message.stageEdit !== undefined) {
      obj.stageEdit = StageEdit.toJSON(message.stageEdit);
    }
    return obj;
  },

  create(base?: DeepPartial<Identifier>): Identifier {
    return Identifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Identifier>): Identifier {
    const message = createBaseIdentifier() as any;
    message.workPlan = (object.workPlan !== undefined && object.workPlan !== null)
      ? WorkPlan.fromPartial(object.workPlan)
      : undefined;
    message.check = (object.check !== undefined && object.check !== null) ? Check.fromPartial(object.check) : undefined;
    message.checkOption = (object.checkOption !== undefined && object.checkOption !== null)
      ? CheckOption.fromPartial(object.checkOption)
      : undefined;
    message.checkResult = (object.checkResult !== undefined && object.checkResult !== null)
      ? CheckResult.fromPartial(object.checkResult)
      : undefined;
    message.checkResultDatum = (object.checkResultDatum !== undefined && object.checkResultDatum !== null)
      ? CheckResultDatum.fromPartial(object.checkResultDatum)
      : undefined;
    message.checkEdit = (object.checkEdit !== undefined && object.checkEdit !== null)
      ? CheckEdit.fromPartial(object.checkEdit)
      : undefined;
    message.checkEditOption = (object.checkEditOption !== undefined && object.checkEditOption !== null)
      ? CheckEditOption.fromPartial(object.checkEditOption)
      : undefined;
    message.stage = (object.stage !== undefined && object.stage !== null) ? Stage.fromPartial(object.stage) : undefined;
    message.stageAttempt = (object.stageAttempt !== undefined && object.stageAttempt !== null)
      ? StageAttempt.fromPartial(object.stageAttempt)
      : undefined;
    message.stageEdit = (object.stageEdit !== undefined && object.stageEdit !== null)
      ? StageEdit.fromPartial(object.stageEdit)
      : undefined;
    return message;
  },
};

function createBaseWorkPlan(): WorkPlan {
  return { id: undefined };
}

export const WorkPlan: MessageFns<WorkPlan> = {
  encode(message: WorkPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkPlan() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkPlan {
    return { id: isSet(object.id) ? globalThis.String(object.id) : undefined };
  },

  toJSON(message: WorkPlan): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkPlan>): WorkPlan {
    return WorkPlan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkPlan>): WorkPlan {
    const message = createBaseWorkPlan() as any;
    message.id = object.id ?? undefined;
    return message;
  },
};

function createBaseCheck(): Check {
  return { workPlan: undefined, id: undefined };
}

export const Check: MessageFns<Check> = {
  encode(message: Check, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workPlan !== undefined) {
      WorkPlan.encode(message.workPlan, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Check {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheck() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workPlan = WorkPlan.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Check {
    return {
      workPlan: isSet(object.workPlan) ? WorkPlan.fromJSON(object.workPlan) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
    };
  },

  toJSON(message: Check): unknown {
    const obj: any = {};
    if (message.workPlan !== undefined) {
      obj.workPlan = WorkPlan.toJSON(message.workPlan);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<Check>): Check {
    return Check.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Check>): Check {
    const message = createBaseCheck() as any;
    message.workPlan = (object.workPlan !== undefined && object.workPlan !== null)
      ? WorkPlan.fromPartial(object.workPlan)
      : undefined;
    message.id = object.id ?? undefined;
    return message;
  },
};

function createBaseCheckOption(): CheckOption {
  return { check: undefined, idx: undefined };
}

export const CheckOption: MessageFns<CheckOption> = {
  encode(message: CheckOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.check !== undefined) {
      Check.encode(message.check, writer.uint32(10).fork()).join();
    }
    if (message.idx !== undefined) {
      writer.uint32(16).int32(message.idx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckOption() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.check = Check.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckOption {
    return {
      check: isSet(object.check) ? Check.fromJSON(object.check) : undefined,
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : undefined,
    };
  },

  toJSON(message: CheckOption): unknown {
    const obj: any = {};
    if (message.check !== undefined) {
      obj.check = Check.toJSON(message.check);
    }
    if (message.idx !== undefined) {
      obj.idx = Math.round(message.idx);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckOption>): CheckOption {
    return CheckOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckOption>): CheckOption {
    const message = createBaseCheckOption() as any;
    message.check = (object.check !== undefined && object.check !== null) ? Check.fromPartial(object.check) : undefined;
    message.idx = object.idx ?? undefined;
    return message;
  },
};

function createBaseCheckResult(): CheckResult {
  return { check: undefined, idx: undefined };
}

export const CheckResult: MessageFns<CheckResult> = {
  encode(message: CheckResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.check !== undefined) {
      Check.encode(message.check, writer.uint32(10).fork()).join();
    }
    if (message.idx !== undefined) {
      writer.uint32(16).int32(message.idx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResult() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.check = Check.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckResult {
    return {
      check: isSet(object.check) ? Check.fromJSON(object.check) : undefined,
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : undefined,
    };
  },

  toJSON(message: CheckResult): unknown {
    const obj: any = {};
    if (message.check !== undefined) {
      obj.check = Check.toJSON(message.check);
    }
    if (message.idx !== undefined) {
      obj.idx = Math.round(message.idx);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckResult>): CheckResult {
    return CheckResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckResult>): CheckResult {
    const message = createBaseCheckResult() as any;
    message.check = (object.check !== undefined && object.check !== null) ? Check.fromPartial(object.check) : undefined;
    message.idx = object.idx ?? undefined;
    return message;
  },
};

function createBaseCheckResultDatum(): CheckResultDatum {
  return { result: undefined, idx: undefined };
}

export const CheckResultDatum: MessageFns<CheckResultDatum> = {
  encode(message: CheckResultDatum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      CheckResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.idx !== undefined) {
      writer.uint32(16).int32(message.idx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckResultDatum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResultDatum() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = CheckResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckResultDatum {
    return {
      result: isSet(object.result) ? CheckResult.fromJSON(object.result) : undefined,
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : undefined,
    };
  },

  toJSON(message: CheckResultDatum): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = CheckResult.toJSON(message.result);
    }
    if (message.idx !== undefined) {
      obj.idx = Math.round(message.idx);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckResultDatum>): CheckResultDatum {
    return CheckResultDatum.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckResultDatum>): CheckResultDatum {
    const message = createBaseCheckResultDatum() as any;
    message.result = (object.result !== undefined && object.result !== null)
      ? CheckResult.fromPartial(object.result)
      : undefined;
    message.idx = object.idx ?? undefined;
    return message;
  },
};

function createBaseCheckEdit(): CheckEdit {
  return { check: undefined, version: undefined };
}

export const CheckEdit: MessageFns<CheckEdit> = {
  encode(message: CheckEdit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.check !== undefined) {
      Check.encode(message.check, writer.uint32(10).fork()).join();
    }
    if (message.version !== undefined) {
      Timestamp.encode(toTimestamp(message.version), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEdit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEdit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.check = Check.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckEdit {
    return {
      check: isSet(object.check) ? Check.fromJSON(object.check) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
    };
  },

  toJSON(message: CheckEdit): unknown {
    const obj: any = {};
    if (message.check !== undefined) {
      obj.check = Check.toJSON(message.check);
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckEdit>): CheckEdit {
    return CheckEdit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckEdit>): CheckEdit {
    const message = createBaseCheckEdit() as any;
    message.check = (object.check !== undefined && object.check !== null) ? Check.fromPartial(object.check) : undefined;
    message.version = object.version ?? undefined;
    return message;
  },
};

function createBaseCheckEditOption(): CheckEditOption {
  return { checkEdit: undefined, idx: undefined };
}

export const CheckEditOption: MessageFns<CheckEditOption> = {
  encode(message: CheckEditOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkEdit !== undefined) {
      CheckEdit.encode(message.checkEdit, writer.uint32(10).fork()).join();
    }
    if (message.idx !== undefined) {
      writer.uint32(16).int32(message.idx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEditOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEditOption() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkEdit = CheckEdit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckEditOption {
    return {
      checkEdit: isSet(object.checkEdit) ? CheckEdit.fromJSON(object.checkEdit) : undefined,
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : undefined,
    };
  },

  toJSON(message: CheckEditOption): unknown {
    const obj: any = {};
    if (message.checkEdit !== undefined) {
      obj.checkEdit = CheckEdit.toJSON(message.checkEdit);
    }
    if (message.idx !== undefined) {
      obj.idx = Math.round(message.idx);
    }
    return obj;
  },

  create(base?: DeepPartial<CheckEditOption>): CheckEditOption {
    return CheckEditOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckEditOption>): CheckEditOption {
    const message = createBaseCheckEditOption() as any;
    message.checkEdit = (object.checkEdit !== undefined && object.checkEdit !== null)
      ? CheckEdit.fromPartial(object.checkEdit)
      : undefined;
    message.idx = object.idx ?? undefined;
    return message;
  },
};

function createBaseStage(): Stage {
  return { workPlan: undefined, id: undefined };
}

export const Stage: MessageFns<Stage> = {
  encode(message: Stage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workPlan !== undefined) {
      WorkPlan.encode(message.workPlan, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      writer.uint32(26).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workPlan = WorkPlan.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stage {
    return {
      workPlan: isSet(object.workPlan) ? WorkPlan.fromJSON(object.workPlan) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
    };
  },

  toJSON(message: Stage): unknown {
    const obj: any = {};
    if (message.workPlan !== undefined) {
      obj.workPlan = WorkPlan.toJSON(message.workPlan);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<Stage>): Stage {
    return Stage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stage>): Stage {
    const message = createBaseStage() as any;
    message.workPlan = (object.workPlan !== undefined && object.workPlan !== null)
      ? WorkPlan.fromPartial(object.workPlan)
      : undefined;
    message.id = object.id ?? undefined;
    return message;
  },
};

function createBaseStageAttempt(): StageAttempt {
  return { stage: undefined, idx: undefined };
}

export const StageAttempt: MessageFns<StageAttempt> = {
  encode(message: StageAttempt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== undefined) {
      Stage.encode(message.stage, writer.uint32(10).fork()).join();
    }
    if (message.idx !== undefined) {
      writer.uint32(16).int32(message.idx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageAttempt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageAttempt() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stage = Stage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageAttempt {
    return {
      stage: isSet(object.stage) ? Stage.fromJSON(object.stage) : undefined,
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : undefined,
    };
  },

  toJSON(message: StageAttempt): unknown {
    const obj: any = {};
    if (message.stage !== undefined) {
      obj.stage = Stage.toJSON(message.stage);
    }
    if (message.idx !== undefined) {
      obj.idx = Math.round(message.idx);
    }
    return obj;
  },

  create(base?: DeepPartial<StageAttempt>): StageAttempt {
    return StageAttempt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageAttempt>): StageAttempt {
    const message = createBaseStageAttempt() as any;
    message.stage = (object.stage !== undefined && object.stage !== null) ? Stage.fromPartial(object.stage) : undefined;
    message.idx = object.idx ?? undefined;
    return message;
  },
};

function createBaseStageEdit(): StageEdit {
  return { stage: undefined, version: undefined };
}

export const StageEdit: MessageFns<StageEdit> = {
  encode(message: StageEdit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== undefined) {
      Stage.encode(message.stage, writer.uint32(10).fork()).join();
    }
    if (message.version !== undefined) {
      Timestamp.encode(toTimestamp(message.version), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StageEdit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageEdit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stage = Stage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StageEdit {
    return {
      stage: isSet(object.stage) ? Stage.fromJSON(object.stage) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
    };
  },

  toJSON(message: StageEdit): unknown {
    const obj: any = {};
    if (message.stage !== undefined) {
      obj.stage = Stage.toJSON(message.stage);
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<StageEdit>): StageEdit {
    return StageEdit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StageEdit>): StageEdit {
    const message = createBaseStageEdit() as any;
    message.stage = (object.stage !== undefined && object.stage !== null) ? Stage.fromPartial(object.stage) : undefined;
    message.version = object.version ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
