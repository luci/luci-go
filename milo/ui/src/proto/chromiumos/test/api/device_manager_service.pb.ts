// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.3
// source: chromiumos/test/api/device_manager_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration.pb";
import { Timestamp } from "../../../google/protobuf/timestamp.pb";
import { ExtendLeaseRequest, ExtendLeaseResponse, HardwareRequirements, VMRequirements } from "./device_leasing.pb";

export const protobufPackage = "chromiumos.test.api";

/**
 * This is different than device features which are expressed in
 * requirements_eq. This is more about virtual, physical, or either initially.
 */
export enum DeviceType {
  DEVICE_TYPE_UNSPECIFIED = 0,
  DEVICE_TYPE_VIRTUAL = 1,
  DEVICE_TYPE_PHYSICAL = 2,
}

export function deviceTypeFromJSON(object: any): DeviceType {
  switch (object) {
    case 0:
    case "DEVICE_TYPE_UNSPECIFIED":
      return DeviceType.DEVICE_TYPE_UNSPECIFIED;
    case 1:
    case "DEVICE_TYPE_VIRTUAL":
      return DeviceType.DEVICE_TYPE_VIRTUAL;
    case 2:
    case "DEVICE_TYPE_PHYSICAL":
      return DeviceType.DEVICE_TYPE_PHYSICAL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceType");
  }
}

export function deviceTypeToJSON(object: DeviceType): string {
  switch (object) {
    case DeviceType.DEVICE_TYPE_UNSPECIFIED:
      return "DEVICE_TYPE_UNSPECIFIED";
    case DeviceType.DEVICE_TYPE_VIRTUAL:
      return "DEVICE_TYPE_VIRTUAL";
    case DeviceType.DEVICE_TYPE_PHYSICAL:
      return "DEVICE_TYPE_PHYSICAL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceType");
  }
}

/** The list is not final and can be extended later. */
export enum DeviceState {
  DEVICE_STATE_UNSPECIFIED = 0,
  /**
   * DEVICE_STATE_AVAILABLE - Default state.
   * Device is available to be leased.
   */
  DEVICE_STATE_AVAILABLE = 1,
  /** DEVICE_STATE_LEASED - Device is leased. */
  DEVICE_STATE_LEASED = 2,
}

export function deviceStateFromJSON(object: any): DeviceState {
  switch (object) {
    case 0:
    case "DEVICE_STATE_UNSPECIFIED":
      return DeviceState.DEVICE_STATE_UNSPECIFIED;
    case 1:
    case "DEVICE_STATE_AVAILABLE":
      return DeviceState.DEVICE_STATE_AVAILABLE;
    case 2:
    case "DEVICE_STATE_LEASED":
      return DeviceState.DEVICE_STATE_LEASED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceState");
  }
}

export function deviceStateToJSON(object: DeviceState): string {
  switch (object) {
    case DeviceState.DEVICE_STATE_UNSPECIFIED:
      return "DEVICE_STATE_UNSPECIFIED";
    case DeviceState.DEVICE_STATE_AVAILABLE:
      return "DEVICE_STATE_AVAILABLE";
    case DeviceState.DEVICE_STATE_LEASED:
      return "DEVICE_STATE_LEASED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceState");
  }
}

export enum LeaseDeviceResponseErrorType {
  LEASE_ERROR_TYPE_NONE = 0,
  LEASE_ERROR_TYPE_DEVICE_NOT_FOUND = 1,
  LEASE_ERROR_TYPE_DEVICE_ALREADY_LEASED = 2,
}

export function leaseDeviceResponseErrorTypeFromJSON(object: any): LeaseDeviceResponseErrorType {
  switch (object) {
    case 0:
    case "LEASE_ERROR_TYPE_NONE":
      return LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_NONE;
    case 1:
    case "LEASE_ERROR_TYPE_DEVICE_NOT_FOUND":
      return LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_DEVICE_NOT_FOUND;
    case 2:
    case "LEASE_ERROR_TYPE_DEVICE_ALREADY_LEASED":
      return LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_DEVICE_ALREADY_LEASED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum LeaseDeviceResponseErrorType");
  }
}

export function leaseDeviceResponseErrorTypeToJSON(object: LeaseDeviceResponseErrorType): string {
  switch (object) {
    case LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_NONE:
      return "LEASE_ERROR_TYPE_NONE";
    case LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_DEVICE_NOT_FOUND:
      return "LEASE_ERROR_TYPE_DEVICE_NOT_FOUND";
    case LeaseDeviceResponseErrorType.LEASE_ERROR_TYPE_DEVICE_ALREADY_LEASED:
      return "LEASE_ERROR_TYPE_DEVICE_ALREADY_LEASED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum LeaseDeviceResponseErrorType");
  }
}

export enum BulkLeaseDevicesResponseErrorType {
  BULK_LEASE_ERROR_TYPE_NONE = 0,
  /** BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR - Internal Postgres errors. */
  BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR = 1,
  /** BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE - Some Devices failed to be leased. See individual lease request errors. */
  BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE = 2,
}

export function bulkLeaseDevicesResponseErrorTypeFromJSON(object: any): BulkLeaseDevicesResponseErrorType {
  switch (object) {
    case 0:
    case "BULK_LEASE_ERROR_TYPE_NONE":
      return BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_NONE;
    case 1:
    case "BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR":
      return BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR;
    case 2:
    case "BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE":
      return BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BulkLeaseDevicesResponseErrorType");
  }
}

export function bulkLeaseDevicesResponseErrorTypeToJSON(object: BulkLeaseDevicesResponseErrorType): string {
  switch (object) {
    case BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_NONE:
      return "BULK_LEASE_ERROR_TYPE_NONE";
    case BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR:
      return "BULK_LEASE_ERROR_TYPE_INTERNAL_DATABASE_ERR";
    case BulkLeaseDevicesResponseErrorType.BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE:
      return "BULK_LEASE_ERROR_TYPE_PARTIAL_LEASE_FAILURE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BulkLeaseDevicesResponseErrorType");
  }
}

export enum ReleaseDeviceResponseErrorType {
  ERROR_TYPE_NONE = 0,
  ERROR_TYPE_DEVICE_ALREADY_RELEASED = 1,
}

export function releaseDeviceResponseErrorTypeFromJSON(object: any): ReleaseDeviceResponseErrorType {
  switch (object) {
    case 0:
    case "ERROR_TYPE_NONE":
      return ReleaseDeviceResponseErrorType.ERROR_TYPE_NONE;
    case 1:
    case "ERROR_TYPE_DEVICE_ALREADY_RELEASED":
      return ReleaseDeviceResponseErrorType.ERROR_TYPE_DEVICE_ALREADY_RELEASED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReleaseDeviceResponseErrorType");
  }
}

export function releaseDeviceResponseErrorTypeToJSON(object: ReleaseDeviceResponseErrorType): string {
  switch (object) {
    case ReleaseDeviceResponseErrorType.ERROR_TYPE_NONE:
      return "ERROR_TYPE_NONE";
    case ReleaseDeviceResponseErrorType.ERROR_TYPE_DEVICE_ALREADY_RELEASED:
      return "ERROR_TYPE_DEVICE_ALREADY_RELEASED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReleaseDeviceResponseErrorType");
  }
}

export interface Device {
  /**
   * In the case of VMs, device id could be the GCE instance name. For physical
   * DUTs we use the IDs we get from UFS.
   */
  readonly id: string;
  /** dut_id is the asset tag for a Device */
  readonly dutId: string;
  readonly address: DeviceAddress | undefined;
  readonly type: DeviceType;
  readonly state: DeviceState;
  /** This proto contains per-DUT hardware relevant information including labels. */
  readonly hardwareReqs: HardwareRequirements | undefined;
}

export interface DeviceAddress {
  /**
   * IP address of the device.
   * For physical DUTs it can be a hostname.
   */
  readonly host: string;
  readonly port: number;
}

export interface DeviceLeaseRecord {
  /**
   * Lease id
   * Should be uniquely generated by UUID4.
   */
  readonly id: string;
  /**
   * Key specified by client per request.
   * Requests with the same key will be treated as duplicate requests.
   */
  readonly idempotencyKey: string;
  /**
   * Device data.
   * Id (hostname) corresponding to the device name.
   */
  readonly deviceId: string;
  /** DUT ID (asset tag) corresponding to the device name. */
  readonly dutId: string;
  /** SSH-able address to access the device. */
  readonly deviceAddress:
    | DeviceAddress
    | undefined;
  /** Type of device leased. */
  readonly deviceType: DeviceType;
  /**
   * Tracking times.
   * Time when the device was leased.
   */
  readonly leasedTime:
    | string
    | undefined;
  /** Time when the device was released by a request or cron. */
  readonly releasedTime:
    | string
    | undefined;
  /**
   * Lease expiration time. The time can be updated several times.
   * The record keeps the last known value.
   */
  readonly expirationTime:
    | string
    | undefined;
  /**
   * Last updated time. The time when the lease was last updated.
   * This will be used as a versioning timestamp
   */
  readonly lastUpdatedTime:
    | string
    | undefined;
  /**
   * Request data.
   * All parameters used to create a device will be saved for further analysis.
   * Possible that the data will be removed later if established as not needed.
   */
  readonly requestParameters: { [key: string]: string };
}

export interface DeviceLeaseRecord_RequestParametersEntry {
  readonly key: string;
  readonly value: string;
}

export interface LeaseDeviceRequest {
  /**
   * Generated on the client side, shared across retries but pseudo-unique
   * across different logical requests. Requests with the same key will be
   * treated as duplicate of original request, return the same response.
   */
  readonly idempotencyKey: string;
  /**
   * This is the final end user (can be human or robot). Useful for both
   * debugging and analytics. For example, for a tests triggered for a CL,
   * this field could indicate the CL author as they are the end user.
   *
   * For direct invocations like CLI, this is enforced at first entry point
   * but trusted from there.
   *
   * Not to be confused with LUCI auth which is done by the caller assuming
   * the appropriate identity from a permissions perspective â€” like LUCI
   * project.
   */
  readonly onBehalfOf: string;
  /**
   * This is the quota the end user is requesting to use. One user can have
   * access to multiple quotas. For example, release, CQ, performance testing,
   * etc.
   */
  readonly quotaId: string;
  /**
   * Optional with a good default.
   * Important to configure a good max (e.g. 10 min). This will put a ceiling
   * on time wasted if the client dies.
   */
  readonly leaseDuration:
    | Duration
    | undefined;
  /**
   * The populated requirements will specify what kind of device manager
   * returns. The client can populate both to indicate that they are ok with
   * either a VM or Hardware DUT.
   */
  readonly vmHostReqs: VMRequirements | undefined;
  readonly hardwareDeviceReqs: HardwareRequirements | undefined;
}

export interface LeaseDeviceResponse {
  readonly deviceLease: DeviceLeaseRecord | undefined;
  readonly errorType: LeaseDeviceResponseErrorType;
  readonly errorString: string;
}

export interface BulkLeaseDevicesRequest {
  /** A list of LeaseDeviceRequests. */
  readonly leaseDeviceRequests: readonly LeaseDeviceRequest[];
}

export interface BulkLeaseDevicesResponse {
  /**
   * One LeaseDeviceResponse for each LeaseDeviceRequest in the
   * BulkLeaseDevicesRequest.
   */
  readonly leaseDeviceResponses: readonly LeaseDeviceResponse[];
  /**
   * Overall error for the bulk request. It is possible for the response to
   * error with partial success of leasing.
   */
  readonly errorType: BulkLeaseDevicesResponseErrorType;
  readonly errorString: string;
}

export interface ReleaseDeviceRequest {
  readonly leaseId: string;
}

export interface ReleaseDeviceResponse {
  readonly leaseId: string;
  readonly errorType: ReleaseDeviceResponseErrorType;
  readonly errorString: string;
}

export interface GetDeviceRequest {
  /**
   * The name of the device to retrieve.
   * Format: devices/{device_id}.
   */
  readonly name: string;
}

export interface ListDevicesRequest {
  /**
   * The parent for which to list devices. Based on collections of pools.
   * If no parent is specified, all devices will be queried.
   * Format: pools/{pool}.
   */
  readonly parent: string;
  /**
   * The maximum number of devices to return. The service may return fewer than
   * this value. If unspecified, at most 50 devices will be returned.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListDevices` call. Provide this to
   * retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDevices` must match
   * the call that provided the page token.
   */
  readonly pageToken: string;
  /**
   * The string filter follows AIP-160 (https://google.aip.dev/160) for the
   * filtering syntax.
   */
  readonly filter: string;
}

export interface ListDevicesResponse {
  /** List of devices to be returned. */
  readonly devices: readonly Device[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page. If
   * this field is omitted, there are no subsequent pages.
   */
  readonly nextPageToken: string;
}

function createBaseDevice(): Device {
  return { id: "", dutId: "", address: undefined, type: 0, state: 0, hardwareReqs: undefined };
}

export const Device: MessageFns<Device> = {
  encode(message: Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dutId !== "") {
      writer.uint32(50).string(message.dutId);
    }
    if (message.address !== undefined) {
      DeviceAddress.encode(message.address, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.hardwareReqs !== undefined) {
      HardwareRequirements.encode(message.hardwareReqs, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dutId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = DeviceAddress.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hardwareReqs = HardwareRequirements.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dutId: isSet(object.dutId) ? globalThis.String(object.dutId) : "",
      address: isSet(object.address) ? DeviceAddress.fromJSON(object.address) : undefined,
      type: isSet(object.type) ? deviceTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? deviceStateFromJSON(object.state) : 0,
      hardwareReqs: isSet(object.hardwareReqs) ? HardwareRequirements.fromJSON(object.hardwareReqs) : undefined,
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dutId !== "") {
      obj.dutId = message.dutId;
    }
    if (message.address !== undefined) {
      obj.address = DeviceAddress.toJSON(message.address);
    }
    if (message.type !== 0) {
      obj.type = deviceTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = deviceStateToJSON(message.state);
    }
    if (message.hardwareReqs !== undefined) {
      obj.hardwareReqs = HardwareRequirements.toJSON(message.hardwareReqs);
    }
    return obj;
  },

  create(base?: DeepPartial<Device>): Device {
    return Device.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device>): Device {
    const message = createBaseDevice() as any;
    message.id = object.id ?? "";
    message.dutId = object.dutId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? DeviceAddress.fromPartial(object.address)
      : undefined;
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.hardwareReqs = (object.hardwareReqs !== undefined && object.hardwareReqs !== null)
      ? HardwareRequirements.fromPartial(object.hardwareReqs)
      : undefined;
    return message;
  },
};

function createBaseDeviceAddress(): DeviceAddress {
  return { host: "", port: 0 };
}

export const DeviceAddress: MessageFns<DeviceAddress> = {
  encode(message: DeviceAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceAddress() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceAddress {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: DeviceAddress): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceAddress>): DeviceAddress {
    return DeviceAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceAddress>): DeviceAddress {
    const message = createBaseDeviceAddress() as any;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseDeviceLeaseRecord(): DeviceLeaseRecord {
  return {
    id: "",
    idempotencyKey: "",
    deviceId: "",
    dutId: "",
    deviceAddress: undefined,
    deviceType: 0,
    leasedTime: undefined,
    releasedTime: undefined,
    expirationTime: undefined,
    lastUpdatedTime: undefined,
    requestParameters: {},
  };
}

export const DeviceLeaseRecord: MessageFns<DeviceLeaseRecord> = {
  encode(message: DeviceLeaseRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(18).string(message.idempotencyKey);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    if (message.dutId !== "") {
      writer.uint32(90).string(message.dutId);
    }
    if (message.deviceAddress !== undefined) {
      DeviceAddress.encode(message.deviceAddress, writer.uint32(34).fork()).join();
    }
    if (message.deviceType !== 0) {
      writer.uint32(40).int32(message.deviceType);
    }
    if (message.leasedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.leasedTime), writer.uint32(50).fork()).join();
    }
    if (message.releasedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.releasedTime), writer.uint32(58).fork()).join();
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(66).fork()).join();
    }
    if (message.lastUpdatedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdatedTime), writer.uint32(74).fork()).join();
    }
    Object.entries(message.requestParameters).forEach(([key, value]) => {
      DeviceLeaseRecord_RequestParametersEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceLeaseRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceLeaseRecord() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dutId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceAddress = DeviceAddress.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deviceType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.leasedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.releasedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastUpdatedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = DeviceLeaseRecord_RequestParametersEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.requestParameters[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceLeaseRecord {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      dutId: isSet(object.dutId) ? globalThis.String(object.dutId) : "",
      deviceAddress: isSet(object.deviceAddress) ? DeviceAddress.fromJSON(object.deviceAddress) : undefined,
      deviceType: isSet(object.deviceType) ? deviceTypeFromJSON(object.deviceType) : 0,
      leasedTime: isSet(object.leasedTime) ? globalThis.String(object.leasedTime) : undefined,
      releasedTime: isSet(object.releasedTime) ? globalThis.String(object.releasedTime) : undefined,
      expirationTime: isSet(object.expirationTime) ? globalThis.String(object.expirationTime) : undefined,
      lastUpdatedTime: isSet(object.lastUpdatedTime) ? globalThis.String(object.lastUpdatedTime) : undefined,
      requestParameters: isObject(object.requestParameters)
        ? Object.entries(object.requestParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeviceLeaseRecord): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.dutId !== "") {
      obj.dutId = message.dutId;
    }
    if (message.deviceAddress !== undefined) {
      obj.deviceAddress = DeviceAddress.toJSON(message.deviceAddress);
    }
    if (message.deviceType !== 0) {
      obj.deviceType = deviceTypeToJSON(message.deviceType);
    }
    if (message.leasedTime !== undefined) {
      obj.leasedTime = message.leasedTime;
    }
    if (message.releasedTime !== undefined) {
      obj.releasedTime = message.releasedTime;
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime;
    }
    if (message.lastUpdatedTime !== undefined) {
      obj.lastUpdatedTime = message.lastUpdatedTime;
    }
    if (message.requestParameters) {
      const entries = Object.entries(message.requestParameters);
      if (entries.length > 0) {
        obj.requestParameters = {};
        entries.forEach(([k, v]) => {
          obj.requestParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceLeaseRecord>): DeviceLeaseRecord {
    return DeviceLeaseRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceLeaseRecord>): DeviceLeaseRecord {
    const message = createBaseDeviceLeaseRecord() as any;
    message.id = object.id ?? "";
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.deviceId = object.deviceId ?? "";
    message.dutId = object.dutId ?? "";
    message.deviceAddress = (object.deviceAddress !== undefined && object.deviceAddress !== null)
      ? DeviceAddress.fromPartial(object.deviceAddress)
      : undefined;
    message.deviceType = object.deviceType ?? 0;
    message.leasedTime = object.leasedTime ?? undefined;
    message.releasedTime = object.releasedTime ?? undefined;
    message.expirationTime = object.expirationTime ?? undefined;
    message.lastUpdatedTime = object.lastUpdatedTime ?? undefined;
    message.requestParameters = Object.entries(object.requestParameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDeviceLeaseRecord_RequestParametersEntry(): DeviceLeaseRecord_RequestParametersEntry {
  return { key: "", value: "" };
}

export const DeviceLeaseRecord_RequestParametersEntry: MessageFns<DeviceLeaseRecord_RequestParametersEntry> = {
  encode(message: DeviceLeaseRecord_RequestParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceLeaseRecord_RequestParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceLeaseRecord_RequestParametersEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceLeaseRecord_RequestParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeviceLeaseRecord_RequestParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceLeaseRecord_RequestParametersEntry>): DeviceLeaseRecord_RequestParametersEntry {
    return DeviceLeaseRecord_RequestParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceLeaseRecord_RequestParametersEntry>): DeviceLeaseRecord_RequestParametersEntry {
    const message = createBaseDeviceLeaseRecord_RequestParametersEntry() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLeaseDeviceRequest(): LeaseDeviceRequest {
  return {
    idempotencyKey: "",
    onBehalfOf: "",
    quotaId: "",
    leaseDuration: undefined,
    vmHostReqs: undefined,
    hardwareDeviceReqs: undefined,
  };
}

export const LeaseDeviceRequest: MessageFns<LeaseDeviceRequest> = {
  encode(message: LeaseDeviceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idempotencyKey !== "") {
      writer.uint32(10).string(message.idempotencyKey);
    }
    if (message.onBehalfOf !== "") {
      writer.uint32(18).string(message.onBehalfOf);
    }
    if (message.quotaId !== "") {
      writer.uint32(26).string(message.quotaId);
    }
    if (message.leaseDuration !== undefined) {
      Duration.encode(message.leaseDuration, writer.uint32(34).fork()).join();
    }
    if (message.vmHostReqs !== undefined) {
      VMRequirements.encode(message.vmHostReqs, writer.uint32(42).fork()).join();
    }
    if (message.hardwareDeviceReqs !== undefined) {
      HardwareRequirements.encode(message.hardwareDeviceReqs, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaseDeviceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaseDeviceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onBehalfOf = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quotaId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.leaseDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vmHostReqs = VMRequirements.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hardwareDeviceReqs = HardwareRequirements.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaseDeviceRequest {
    return {
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      onBehalfOf: isSet(object.onBehalfOf) ? globalThis.String(object.onBehalfOf) : "",
      quotaId: isSet(object.quotaId) ? globalThis.String(object.quotaId) : "",
      leaseDuration: isSet(object.leaseDuration) ? Duration.fromJSON(object.leaseDuration) : undefined,
      vmHostReqs: isSet(object.vmHostReqs) ? VMRequirements.fromJSON(object.vmHostReqs) : undefined,
      hardwareDeviceReqs: isSet(object.hardwareDeviceReqs)
        ? HardwareRequirements.fromJSON(object.hardwareDeviceReqs)
        : undefined,
    };
  },

  toJSON(message: LeaseDeviceRequest): unknown {
    const obj: any = {};
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.onBehalfOf !== "") {
      obj.onBehalfOf = message.onBehalfOf;
    }
    if (message.quotaId !== "") {
      obj.quotaId = message.quotaId;
    }
    if (message.leaseDuration !== undefined) {
      obj.leaseDuration = Duration.toJSON(message.leaseDuration);
    }
    if (message.vmHostReqs !== undefined) {
      obj.vmHostReqs = VMRequirements.toJSON(message.vmHostReqs);
    }
    if (message.hardwareDeviceReqs !== undefined) {
      obj.hardwareDeviceReqs = HardwareRequirements.toJSON(message.hardwareDeviceReqs);
    }
    return obj;
  },

  create(base?: DeepPartial<LeaseDeviceRequest>): LeaseDeviceRequest {
    return LeaseDeviceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaseDeviceRequest>): LeaseDeviceRequest {
    const message = createBaseLeaseDeviceRequest() as any;
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.onBehalfOf = object.onBehalfOf ?? "";
    message.quotaId = object.quotaId ?? "";
    message.leaseDuration = (object.leaseDuration !== undefined && object.leaseDuration !== null)
      ? Duration.fromPartial(object.leaseDuration)
      : undefined;
    message.vmHostReqs = (object.vmHostReqs !== undefined && object.vmHostReqs !== null)
      ? VMRequirements.fromPartial(object.vmHostReqs)
      : undefined;
    message.hardwareDeviceReqs = (object.hardwareDeviceReqs !== undefined && object.hardwareDeviceReqs !== null)
      ? HardwareRequirements.fromPartial(object.hardwareDeviceReqs)
      : undefined;
    return message;
  },
};

function createBaseLeaseDeviceResponse(): LeaseDeviceResponse {
  return { deviceLease: undefined, errorType: 0, errorString: "" };
}

export const LeaseDeviceResponse: MessageFns<LeaseDeviceResponse> = {
  encode(message: LeaseDeviceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceLease !== undefined) {
      DeviceLeaseRecord.encode(message.deviceLease, writer.uint32(10).fork()).join();
    }
    if (message.errorType !== 0) {
      writer.uint32(16).int32(message.errorType);
    }
    if (message.errorString !== "") {
      writer.uint32(26).string(message.errorString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaseDeviceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaseDeviceResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceLease = DeviceLeaseRecord.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaseDeviceResponse {
    return {
      deviceLease: isSet(object.deviceLease) ? DeviceLeaseRecord.fromJSON(object.deviceLease) : undefined,
      errorType: isSet(object.errorType) ? leaseDeviceResponseErrorTypeFromJSON(object.errorType) : 0,
      errorString: isSet(object.errorString) ? globalThis.String(object.errorString) : "",
    };
  },

  toJSON(message: LeaseDeviceResponse): unknown {
    const obj: any = {};
    if (message.deviceLease !== undefined) {
      obj.deviceLease = DeviceLeaseRecord.toJSON(message.deviceLease);
    }
    if (message.errorType !== 0) {
      obj.errorType = leaseDeviceResponseErrorTypeToJSON(message.errorType);
    }
    if (message.errorString !== "") {
      obj.errorString = message.errorString;
    }
    return obj;
  },

  create(base?: DeepPartial<LeaseDeviceResponse>): LeaseDeviceResponse {
    return LeaseDeviceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaseDeviceResponse>): LeaseDeviceResponse {
    const message = createBaseLeaseDeviceResponse() as any;
    message.deviceLease = (object.deviceLease !== undefined && object.deviceLease !== null)
      ? DeviceLeaseRecord.fromPartial(object.deviceLease)
      : undefined;
    message.errorType = object.errorType ?? 0;
    message.errorString = object.errorString ?? "";
    return message;
  },
};

function createBaseBulkLeaseDevicesRequest(): BulkLeaseDevicesRequest {
  return { leaseDeviceRequests: [] };
}

export const BulkLeaseDevicesRequest: MessageFns<BulkLeaseDevicesRequest> = {
  encode(message: BulkLeaseDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leaseDeviceRequests) {
      LeaseDeviceRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkLeaseDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkLeaseDevicesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaseDeviceRequests.push(LeaseDeviceRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkLeaseDevicesRequest {
    return {
      leaseDeviceRequests: globalThis.Array.isArray(object?.leaseDeviceRequests)
        ? object.leaseDeviceRequests.map((e: any) => LeaseDeviceRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BulkLeaseDevicesRequest): unknown {
    const obj: any = {};
    if (message.leaseDeviceRequests?.length) {
      obj.leaseDeviceRequests = message.leaseDeviceRequests.map((e) => LeaseDeviceRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BulkLeaseDevicesRequest>): BulkLeaseDevicesRequest {
    return BulkLeaseDevicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkLeaseDevicesRequest>): BulkLeaseDevicesRequest {
    const message = createBaseBulkLeaseDevicesRequest() as any;
    message.leaseDeviceRequests = object.leaseDeviceRequests?.map((e) => LeaseDeviceRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkLeaseDevicesResponse(): BulkLeaseDevicesResponse {
  return { leaseDeviceResponses: [], errorType: 0, errorString: "" };
}

export const BulkLeaseDevicesResponse: MessageFns<BulkLeaseDevicesResponse> = {
  encode(message: BulkLeaseDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leaseDeviceResponses) {
      LeaseDeviceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.errorType !== 0) {
      writer.uint32(16).int32(message.errorType);
    }
    if (message.errorString !== "") {
      writer.uint32(26).string(message.errorString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkLeaseDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkLeaseDevicesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaseDeviceResponses.push(LeaseDeviceResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkLeaseDevicesResponse {
    return {
      leaseDeviceResponses: globalThis.Array.isArray(object?.leaseDeviceResponses)
        ? object.leaseDeviceResponses.map((e: any) => LeaseDeviceResponse.fromJSON(e))
        : [],
      errorType: isSet(object.errorType) ? bulkLeaseDevicesResponseErrorTypeFromJSON(object.errorType) : 0,
      errorString: isSet(object.errorString) ? globalThis.String(object.errorString) : "",
    };
  },

  toJSON(message: BulkLeaseDevicesResponse): unknown {
    const obj: any = {};
    if (message.leaseDeviceResponses?.length) {
      obj.leaseDeviceResponses = message.leaseDeviceResponses.map((e) => LeaseDeviceResponse.toJSON(e));
    }
    if (message.errorType !== 0) {
      obj.errorType = bulkLeaseDevicesResponseErrorTypeToJSON(message.errorType);
    }
    if (message.errorString !== "") {
      obj.errorString = message.errorString;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkLeaseDevicesResponse>): BulkLeaseDevicesResponse {
    return BulkLeaseDevicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkLeaseDevicesResponse>): BulkLeaseDevicesResponse {
    const message = createBaseBulkLeaseDevicesResponse() as any;
    message.leaseDeviceResponses = object.leaseDeviceResponses?.map((e) => LeaseDeviceResponse.fromPartial(e)) || [];
    message.errorType = object.errorType ?? 0;
    message.errorString = object.errorString ?? "";
    return message;
  },
};

function createBaseReleaseDeviceRequest(): ReleaseDeviceRequest {
  return { leaseId: "" };
}

export const ReleaseDeviceRequest: MessageFns<ReleaseDeviceRequest> = {
  encode(message: ReleaseDeviceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaseId !== "") {
      writer.uint32(10).string(message.leaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDeviceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDeviceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaseId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDeviceRequest {
    return { leaseId: isSet(object.leaseId) ? globalThis.String(object.leaseId) : "" };
  },

  toJSON(message: ReleaseDeviceRequest): unknown {
    const obj: any = {};
    if (message.leaseId !== "") {
      obj.leaseId = message.leaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDeviceRequest>): ReleaseDeviceRequest {
    return ReleaseDeviceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDeviceRequest>): ReleaseDeviceRequest {
    const message = createBaseReleaseDeviceRequest() as any;
    message.leaseId = object.leaseId ?? "";
    return message;
  },
};

function createBaseReleaseDeviceResponse(): ReleaseDeviceResponse {
  return { leaseId: "", errorType: 0, errorString: "" };
}

export const ReleaseDeviceResponse: MessageFns<ReleaseDeviceResponse> = {
  encode(message: ReleaseDeviceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaseId !== "") {
      writer.uint32(10).string(message.leaseId);
    }
    if (message.errorType !== 0) {
      writer.uint32(16).int32(message.errorType);
    }
    if (message.errorString !== "") {
      writer.uint32(26).string(message.errorString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDeviceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDeviceResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDeviceResponse {
    return {
      leaseId: isSet(object.leaseId) ? globalThis.String(object.leaseId) : "",
      errorType: isSet(object.errorType) ? releaseDeviceResponseErrorTypeFromJSON(object.errorType) : 0,
      errorString: isSet(object.errorString) ? globalThis.String(object.errorString) : "",
    };
  },

  toJSON(message: ReleaseDeviceResponse): unknown {
    const obj: any = {};
    if (message.leaseId !== "") {
      obj.leaseId = message.leaseId;
    }
    if (message.errorType !== 0) {
      obj.errorType = releaseDeviceResponseErrorTypeToJSON(message.errorType);
    }
    if (message.errorString !== "") {
      obj.errorString = message.errorString;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDeviceResponse>): ReleaseDeviceResponse {
    return ReleaseDeviceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDeviceResponse>): ReleaseDeviceResponse {
    const message = createBaseReleaseDeviceResponse() as any;
    message.leaseId = object.leaseId ?? "";
    message.errorType = object.errorType ?? 0;
    message.errorString = object.errorString ?? "";
    return message;
  },
};

function createBaseGetDeviceRequest(): GetDeviceRequest {
  return { name: "" };
}

export const GetDeviceRequest: MessageFns<GetDeviceRequest> = {
  encode(message: GetDeviceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDeviceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeviceRequest>): GetDeviceRequest {
    return GetDeviceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeviceRequest>): GetDeviceRequest {
    const message = createBaseGetDeviceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDevicesRequest(): ListDevicesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListDevicesRequest: MessageFns<ListDevicesRequest> = {
  encode(message: ListDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListDevicesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDevicesRequest>): ListDevicesRequest {
    return ListDevicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDevicesRequest>): ListDevicesRequest {
    const message = createBaseListDevicesRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListDevicesResponse(): ListDevicesResponse {
  return { devices: [], nextPageToken: "" };
}

export const ListDevicesResponse: MessageFns<ListDevicesResponse> = {
  encode(message: ListDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesResponse {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDevicesResponse): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDevicesResponse>): ListDevicesResponse {
    return ListDevicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDevicesResponse>): ListDevicesResponse {
    const message = createBaseListDevicesResponse() as any;
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

export interface DeviceLeaseService {
  /** Lease a device and create a lease. */
  LeaseDevice(request: LeaseDeviceRequest): Promise<LeaseDeviceResponse>;
  /** Bulk lease devices and create leases for all of them. */
  BulkLeaseDevices(request: BulkLeaseDevicesRequest): Promise<BulkLeaseDevicesResponse>;
  /** Release a device lease. */
  ReleaseDevice(request: ReleaseDeviceRequest): Promise<ReleaseDeviceResponse>;
  /** Extend a device lease by modifying the expiration time. */
  ExtendLease(request: ExtendLeaseRequest): Promise<ExtendLeaseResponse>;
  /**
   * Get a device by device id.
   * Designed to adhere to https://google.aip.dev/131.
   */
  GetDevice(request: GetDeviceRequest): Promise<Device>;
  /**
   * List devices managed by Device Manager.
   * Designed to adhere to https://google.aip.dev/132.
   */
  ListDevices(request: ListDevicesRequest): Promise<ListDevicesResponse>;
}

export const DeviceLeaseServiceServiceName = "chromiumos.test.api.DeviceLeaseService";
export class DeviceLeaseServiceClientImpl implements DeviceLeaseService {
  static readonly DEFAULT_SERVICE = DeviceLeaseServiceServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DeviceLeaseServiceServiceName;
    this.rpc = rpc;
    this.LeaseDevice = this.LeaseDevice.bind(this);
    this.BulkLeaseDevices = this.BulkLeaseDevices.bind(this);
    this.ReleaseDevice = this.ReleaseDevice.bind(this);
    this.ExtendLease = this.ExtendLease.bind(this);
    this.GetDevice = this.GetDevice.bind(this);
    this.ListDevices = this.ListDevices.bind(this);
  }
  LeaseDevice(request: LeaseDeviceRequest): Promise<LeaseDeviceResponse> {
    const data = LeaseDeviceRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "LeaseDevice", data);
    return promise.then((data) => LeaseDeviceResponse.fromJSON(data));
  }

  BulkLeaseDevices(request: BulkLeaseDevicesRequest): Promise<BulkLeaseDevicesResponse> {
    const data = BulkLeaseDevicesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "BulkLeaseDevices", data);
    return promise.then((data) => BulkLeaseDevicesResponse.fromJSON(data));
  }

  ReleaseDevice(request: ReleaseDeviceRequest): Promise<ReleaseDeviceResponse> {
    const data = ReleaseDeviceRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ReleaseDevice", data);
    return promise.then((data) => ReleaseDeviceResponse.fromJSON(data));
  }

  ExtendLease(request: ExtendLeaseRequest): Promise<ExtendLeaseResponse> {
    const data = ExtendLeaseRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ExtendLease", data);
    return promise.then((data) => ExtendLeaseResponse.fromJSON(data));
  }

  GetDevice(request: GetDeviceRequest): Promise<Device> {
    const data = GetDeviceRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetDevice", data);
    return promise.then((data) => Device.fromJSON(data));
  }

  ListDevices(request: ListDevicesRequest): Promise<ListDevicesResponse> {
    const data = ListDevicesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListDevices", data);
    return promise.then((data) => ListDevicesResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
