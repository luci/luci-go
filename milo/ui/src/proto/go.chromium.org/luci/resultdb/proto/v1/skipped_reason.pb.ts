// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.0
// source: go.chromium.org/luci/resultdb/proto/v1/skipped_reason.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "luci.resultdb.v1";

/**
 * SkippedReason helps a developer answer the questions:
 * - Why was this test skipped?
 * - How do I stop it being skipped?
 */
export interface SkippedReason {
  readonly kind: SkippedReason_Kind;
  /**
   * A human-readable message providing more context or details about why the
   * test was skipped. Limited to 1024 bytes of printable UTF-8.
   *
   * Required for skip kinds DEMOTED and OTHER, optional otherwise.
   *
   * For DISABLED_AT_DECLARATION, useful information would be:
   * - For Tast, the Tast-provided skip reason (detailing the declared
   *   hardware/software dependencies that were unmet).
   *
   * For SKIPPED_BY_TEST_BODY, useful information would be:
   * - For JUnit, the JUnit assumption failure that led to the skip.
   *   (Include the message and the file name/line number
   *   that had the assert here, but leave the full stack trace
   *   for the field `trace`).
   *   E.g. `MyTest.java(456): some message`
   * - For GoogleTest, the file and line where the GTEST_SKIP() macro was
   *   invoked and the message passed to it.
   *
   * For DEMOTED and OTHER, the criteria that led to the skip
   * and how the user might get the test running again.
   */
  readonly reasonMessage: string;
  /**
   * A stack trace associated with the decision to skip, if applicable.
   * This is primarily intended for use with SKIPPED_BY_TEST_BODY,
   * where the test framework is capable of providing a stack trace.
   *
   * A size limit of 4096 bytes (UTF-8) applies to this field. If no
   * stack trace is available, leave blank.
   *
   * E.g. `org.junit.AssumptionViolatedException: some message
   *      at org.junit.Assume.assumeTrue(Assume.java:68)
   *      at com.example.MyTest.myTest(MyTest.java:456)`
   */
  readonly trace: string;
}

/**
 * Provides structured explanation for why a test was skipped.
 * It must be populated when the status is SKIP.
 * Open to extension.
 */
export enum SkippedReason_Kind {
  /** KIND_UNSPECIFIED - Skipped reason was not specified. Do not use this value. */
  KIND_UNSPECIFIED = 0,
  /**
   * DISABLED_AT_DECLARATION - Skipped by an annotation at the test declaration site.
   *
   * This includes:
   * - JUnit4 @Ignore,
   * - JUnit5 @Disabled, @DisabledIf/For/On... @EnabledIf/For/On...
   *   annotations.
   * - GoogleTest DISABLED_ text prefix.
   * - Tast test skips from the declared software or hardware
   *   dependencies being unsatisfied at runtime.
   * and similar statically defined annotations at the test
   * declaration site.
   */
  DISABLED_AT_DECLARATION = 1,
  /**
   * SKIPPED_BY_TEST_BODY - Test body began to run but determined the test should
   * not finish. For example, the test did not detect a valid
   * environment meeting the test assumptions.
   *
   * This covers:
   * - a JUnit4 or JUnit5 assumption failure in the body of a test,
   *   from Assume.assumeThat(...) and similar methods.
   * - Use of the GTEST_SKIP() macro within the body of a test.
   * - Golang's t.Skip(...) in the body of a test.
   */
  SKIPPED_BY_TEST_BODY = 2,
  /**
   * DEMOTED - Used to indicate the test was skipped due to presubmit demotion
   * (e.g. because the test was too flaky).
   *
   * You must specify a human-readable detail message if you use this status.
   * Please explain the criteria that was met and how the user should get the
   * test undemoted or reference a link that explains more.
   */
  DEMOTED = 3,
  /**
   * OTHER - The test was skipped by some other reason.
   *
   * This includes:
   * - Blink web tests disabled in an expectation file.
   *
   * You must specify a human-readable detail message if you use this status.
   */
  OTHER = 4,
}

export function skippedReason_KindFromJSON(object: any): SkippedReason_Kind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return SkippedReason_Kind.KIND_UNSPECIFIED;
    case 1:
    case "DISABLED_AT_DECLARATION":
      return SkippedReason_Kind.DISABLED_AT_DECLARATION;
    case 2:
    case "SKIPPED_BY_TEST_BODY":
      return SkippedReason_Kind.SKIPPED_BY_TEST_BODY;
    case 3:
    case "DEMOTED":
      return SkippedReason_Kind.DEMOTED;
    case 4:
    case "OTHER":
      return SkippedReason_Kind.OTHER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SkippedReason_Kind");
  }
}

export function skippedReason_KindToJSON(object: SkippedReason_Kind): string {
  switch (object) {
    case SkippedReason_Kind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case SkippedReason_Kind.DISABLED_AT_DECLARATION:
      return "DISABLED_AT_DECLARATION";
    case SkippedReason_Kind.SKIPPED_BY_TEST_BODY:
      return "SKIPPED_BY_TEST_BODY";
    case SkippedReason_Kind.DEMOTED:
      return "DEMOTED";
    case SkippedReason_Kind.OTHER:
      return "OTHER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SkippedReason_Kind");
  }
}

function createBaseSkippedReason(): SkippedReason {
  return { kind: 0, reasonMessage: "", trace: "" };
}

export const SkippedReason: MessageFns<SkippedReason> = {
  encode(message: SkippedReason, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.reasonMessage !== "") {
      writer.uint32(18).string(message.reasonMessage);
    }
    if (message.trace !== "") {
      writer.uint32(26).string(message.trace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkippedReason {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkippedReason() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reasonMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkippedReason {
    return {
      kind: isSet(object.kind) ? skippedReason_KindFromJSON(object.kind) : 0,
      reasonMessage: isSet(object.reasonMessage) ? globalThis.String(object.reasonMessage) : "",
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
    };
  },

  toJSON(message: SkippedReason): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = skippedReason_KindToJSON(message.kind);
    }
    if (message.reasonMessage !== "") {
      obj.reasonMessage = message.reasonMessage;
    }
    if (message.trace !== "") {
      obj.trace = message.trace;
    }
    return obj;
  },

  create(base?: DeepPartial<SkippedReason>): SkippedReason {
    return SkippedReason.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkippedReason>): SkippedReason {
    const message = createBaseSkippedReason() as any;
    message.kind = object.kind ?? 0;
    message.reasonMessage = object.reasonMessage ?? "";
    message.trace = object.trace ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
