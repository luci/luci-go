// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.1
// source: go.chromium.org/luci/resultdb/proto/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "luci.resultdb.v1";

/**
 * AggregationLevel defines the levels that test verdicts can be
 * aggregated to.
 */
export enum AggregationLevel {
  /** AGGREGATION_LEVEL_UNSPECIFIED - Aggregation level not specified. Do not use. */
  AGGREGATION_LEVEL_UNSPECIFIED = 0,
  /**
   * INVOCATION - Aggregate to the invocation level. This means all test results
   * in an invocation.
   */
  INVOCATION = 1,
  /**
   * MODULE - Aggregate to the module level. This means all test results
   * sharing the same module_name, module_variant and module_scheme.
   */
  MODULE = 2,
  /**
   * COARSE - Aggregate to the coarse name level.
   * This means all test results sharing the same module and coarse_name.
   */
  COARSE = 3,
  /**
   * FINE - Aggregate to the fine name level.
   * This means all test results sharing the same module, coarse_name,
   * and fine_name.
   */
  FINE = 4,
  /**
   * CASE - Aggregate to the test case (test verdict) level.
   * This means all test results sharing the same test identifier.
   */
  CASE = 5,
}

export function aggregationLevelFromJSON(object: any): AggregationLevel {
  switch (object) {
    case 0:
    case "AGGREGATION_LEVEL_UNSPECIFIED":
      return AggregationLevel.AGGREGATION_LEVEL_UNSPECIFIED;
    case 1:
    case "INVOCATION":
      return AggregationLevel.INVOCATION;
    case 2:
    case "MODULE":
      return AggregationLevel.MODULE;
    case 3:
    case "COARSE":
      return AggregationLevel.COARSE;
    case 4:
    case "FINE":
      return AggregationLevel.FINE;
    case 5:
    case "CASE":
      return AggregationLevel.CASE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum AggregationLevel");
  }
}

export function aggregationLevelToJSON(object: AggregationLevel): string {
  switch (object) {
    case AggregationLevel.AGGREGATION_LEVEL_UNSPECIFIED:
      return "AGGREGATION_LEVEL_UNSPECIFIED";
    case AggregationLevel.INVOCATION:
      return "INVOCATION";
    case AggregationLevel.MODULE:
      return "MODULE";
    case AggregationLevel.COARSE:
      return "COARSE";
    case AggregationLevel.FINE:
      return "FINE";
    case AggregationLevel.CASE:
      return "CASE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum AggregationLevel");
  }
}

/**
 * WorkUnitView represents the set of work unit fields to be retrieved.
 * See https://google.aip.dev/157.
 */
export enum WorkUnitView {
  /** WORK_UNIT_VIEW_UNSPECIFIED - The default / unset value. The API will default to the basic view. */
  WORK_UNIT_VIEW_UNSPECIFIED = 0,
  /**
   * WORK_UNIT_VIEW_BASIC - Include basic information about the work unit. Excludes
   * extended_properties.
   */
  WORK_UNIT_VIEW_BASIC = 1,
  /** WORK_UNIT_VIEW_FULL - Include all fields, including extended_properties. */
  WORK_UNIT_VIEW_FULL = 2,
}

export function workUnitViewFromJSON(object: any): WorkUnitView {
  switch (object) {
    case 0:
    case "WORK_UNIT_VIEW_UNSPECIFIED":
      return WorkUnitView.WORK_UNIT_VIEW_UNSPECIFIED;
    case 1:
    case "WORK_UNIT_VIEW_BASIC":
      return WorkUnitView.WORK_UNIT_VIEW_BASIC;
    case 2:
    case "WORK_UNIT_VIEW_FULL":
      return WorkUnitView.WORK_UNIT_VIEW_FULL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkUnitView");
  }
}

export function workUnitViewToJSON(object: WorkUnitView): string {
  switch (object) {
    case WorkUnitView.WORK_UNIT_VIEW_UNSPECIFIED:
      return "WORK_UNIT_VIEW_UNSPECIFIED";
    case WorkUnitView.WORK_UNIT_VIEW_BASIC:
      return "WORK_UNIT_VIEW_BASIC";
    case WorkUnitView.WORK_UNIT_VIEW_FULL:
      return "WORK_UNIT_VIEW_FULL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum WorkUnitView");
  }
}

/**
 * A key-value map describing one variant of a module.
 *
 * A module can be executed in different ways, for example on
 * different OS, GPUs, with different compile options or runtime flags.
 * A variant definition captures one such variant.
 * A test case with a specific variant definition is called test variant.
 *
 * Guidelines for variant definition design:
 * - This rule guides what keys MUST be present in the definition.
 *   A single expected result of a given test variant is enough to consider it
 *   passing (potentially flakily). If it is important to differentiate across
 *   a certain dimension (e.g. whether web tests are executed with or without
 *   site per process isolation), then there MUST be a key that captures the
 *   dimension (e.g. a name from test_suites.pyl).
 *   Otherwise, a pass in one variant will hide a failure of another one.
 *
 * - This rule guides what keys MUST NOT be present in the definition.
 *   A change in the key-value set essentially resets the test result history.
 *   For example, if GN args are among variant key-value pairs, then adding a
 *   new GN arg changes the identity of the test variant and resets its history.
 *
 * In Chromium, variant keys are:
 * - bucket: the LUCI bucket, e.g. "ci"
 * - builder: the LUCI builder, e.g. "linux-rel"
 * - test_suite: a name from
 *   https://cs.chromium.org/chromium/src/testing/buildbot/test_suites.pyl
 */
export interface Variant {
  /**
   * The definition of the variant.
   * Key and values must be valid StringPair keys and values, see their
   * constraints.
   *
   * These values must be the same for all tests in a given execution of
   * a module. Variants specific to a particular test case should be
   * encoded in the test method name (see TestIdentifier.method).
   *
   * The total size (as measured by proto.Size) must be less than 1,024 bytes.
   */
  readonly def: { [key: string]: string };
}

export interface Variant_DefEntry {
  readonly key: string;
  readonly value: string;
}

/** A string key-value pair. Typically used for tagging, see Invocation.tags */
export interface StringPair {
  /**
   * Regex: ^[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*$
   * Max length: 64 bytes.
   */
  readonly key: string;
  /**
   * Must be valid UTF-8, Unicode Normalization Form C, printable characters
   * only.
   * Max length: 256 bytes.
   */
  readonly value: string;
}

/**
 * TestIdentifier represents the identity of a test in structured form.
 * It includes information about the configuration the test was run in (e.g.
 * build configuration, CPU architecture, OS).
 *
 * The structured test identifier represented in this proto corresponds to
 * the flat test identifier with the following form:
 * :{module_name}!{module_scheme}:{coarse_name}:{fine_name}#{case_name}
 *
 * and variant matching module_variant. (Note that {case_name} may in turn
 * include multiple components separated by colons, see 'Extended depth
 * hierarchies' under case_name below.)
 *
 * The precise algorithm for encoding a structured test ID to a flat
 * test ID is an implementation detail of ResultDB and must not be relied
 * upon by clients. Use the provided encode and decode functions in the
 * pbutil library if you need to encode or decode them. BigQuery exports
 * should include the structured form Test ID to avoid clients needing
 * to decode IDs.
 *
 * Special treatment exists for legacy test identifiers, for which
 * module_name = "legacy", module_scheme = "legacy", coarse_name = "",
 * fine_name = "" and case_name = <legacy_id>. For these, the corresponding
 * flat test ID is simply:
 * {case_name}
 *
 * (no escaping applies to this form, although method starting with ':'
 * is illegal for legacy test identifiers).
 *
 * See go/resultdb-test-hierarchy-design for more details.
 *
 * Limits: the encoded flat test ID (as per rules above) must be less than
 * 512 bytes in UTF-8.
 */
export interface TestIdentifier {
  /**
   * The name of the module being tested. A module is a set of tests which run
   * with the same test harness, and typically corresponds with a unit of
   * build, such as a bazel test target.
   *
   * For example, "CtsSdkExtensionsTestCases" or "chrome/test:blink_webkit_tests".
   *
   * Note: Modules are identified by the combination of module_name and scheme, not
   * only module_name. See `scheme` field below for more.
   *
   * Constraints:
   * - Limited to 300 bytes of valid, printable UTF-8. For the purposes of this
   *   definition, the unicode replacement character (U+FFFD) is not considered printable.
   *   See also length limits on `TestIdentifier` as a whole.
   * - All unicode must be in Normalization Form C.
   * - Use of spaces is allowed, but discouraged.
   */
  readonly moduleName: string;
  /**
   * The scheme of the module, for example, "junit" or "gtest".
   *
   * Must match one of the schemes in the ResultDB service configuration (see
   * go/resultdb-schemes). Additional values can be configured as needed.
   *
   * Note: modules are identified by the combination of module_name, module_variant and
   * module_scheme.
   * Nonetheless, when presenting data on a frontend, it is acceptable to not show the scheme
   * as it exists primarily to allow customisation of the labels shown next to the coarse_name,
   * fine_name and case_name fields.
   * When uploading data it is STRONGLY DISCOURAGED to use different schemes with the same
   * module name as it may lead to ambiguous UI for users.
   *
   * Limited to ^[a-z][a-z0-9]{0,19}$.
   */
  readonly moduleScheme: string;
  /**
   * Description of one specific way of running the tests in a module,
   * e.g. specific ABI (x64/x86/...), build flags and/or operating system.
   *
   * Variants identify the unique ways the module was run compared to every other way
   * the module is run by the LUCI project. As such, some variant key-value pairs
   * may be repeated for all modules in an invocation.
   *
   * N.B. Presently this is always the same as test_result.variant but semantics could
   * diverge in future if variants are introduced at other levels.
   */
  readonly moduleVariant:
    | Variant
    | undefined;
  /**
   * Hash of the module variant.
   * hex(sha256(sorted(''.join('%s:%s\n' for k, v in module_variant.items()))))[:8].
   *
   * In the context of the TestResult record, this field is OUTPUT_ONLY and will be
   * automatically computed from the provided module_variant (do not set it yourself).
   * In the context of ResultDB Query RPCs accepting this type as a request filter,
   * this field may be specified as an alternative to module_variant.
   */
  readonly moduleVariantHash: string;
  /**
   * Intermediate hierarchy - coarse name.
   *
   * For example "com.android.os.ext".
   *
   * A scheme dependent value used to organise the test into a coarse group of related tests,
   * such as a package or directory.
   * If the scheme does not define a coarse grouping, this must be blank.
   * If only one intermediate hierarchy level is used for a scheme, it is always the
   * fine hierarchy level.
   *
   * Constraints:
   * - Must match constraints set by the module's scheme.
   * - Limited to 300 bytes of printable UTF-8. For the purposes of this
   *   definition, the unicode replacement character (U+FFFD) is not considered printable.
   *   See also length limits on `TestIdentifier` as a whole.
   * - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C).
   * - All unicode must be in Normalization Form C.
   * - Use of spaces is allowed, but discouraged.
   */
  readonly coarseName: string;
  /**
   * Interemdiate hierarchy - fine name.
   *
   * For example "SdkExtensionsTest" or "WebDialogBrowserTest".
   *
   * A finer grouping within the above coarse grouping (if any), e.g. class or file.
   * If the scheme does not define a fine grouping, this must be blank.
   *
   * Constraints:
   * - Must match constraints set by the module's scheme.
   * - Limited to 300 bytes of printable UTF-8. For the purposes of this
   *   definition, the unicode replacement character (U+FFFD) is not considered printable.
   *   See also length limits on `TestIdentifier` as a whole.
   * - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C).
   * - All unicode must be in Normalization Form C.
   * - Use of spaces is allowed, but discouraged.
   */
  readonly fineName: string;
  /**
   * The identifier of test case within the above fine grouping.
   *
   * For example "testBadArgument" or "topLevelTest:with_context:does_something".
   *
   * This is the finest granularity component of the test identifier, and typically
   * refers to sub-file granularity unless no such granularity exists.
   *
   * Application guidance:
   * * Standard usage: E.g. GTest methods, JUnit methods, etc.
   *
   *   Put the test method name in this field, escaping any colons (':')
   *   and backlashes ('\') with a backslash '\'.
   *   If your tests have additional hierarchy in the test case name,
   *   consider the section on 'Extended depth hierarchies' below.
   *
   * * Class/package-level setup/teardown:
   *
   *   Use the special value "*fixture" when reporting the result of
   *   setup and teardown common to tests in the same fine_name.
   *
   * * Extended depth hierarchies:
   *
   *   When uploading a test case from an extended depth hierarchy, use the separator ':'
   *   to separate the components of the test case identifier (e.g. the describe blocks
   *   in a jest/mocha test). Text between the separators must have all occurrences
   *   of ':' and '\' escaped with a backslash ('\') to avoid other colons being interpreted
   *   as separators. Each component of such a hierarchical test case ID must not be empty.
   *   E.g. 'topLevelTest:' is not valid.
   *
   *   Rationale and Important Caveats
   *
   *   Most test hierarchy should be captured by the module, coarse and fine names.
   *   For example, the module typically captures the compilation unit, the coarse name
   *   the directory (e.g. package name) and the fine name the file (e.g. class name).
   *   This leaves the case name to capture sub-file granularity, which
   *   in many frameworks is simply the method name.
   *
   *   However, some frameworks have additional levels of test hierarchy within the
   *   "file" level. For example, Jest and Mocha allow tests to be nested within
   *   an arbitrary number of describe('subscope', func() { ... }) blocks. There may
   *   also be parameterisations of tests. For such cases, we offer a standardised
   *   way to express the additional hierarchy using colons (':') to separate components.
   *   UI may give special treatment to components so expressed in future.
   *
   *   Only consider uploading separate results for each test in such an additional
   *   depth hierarchy if all of the following hold:
   *   - Passes are reported for each test, not just failures.
   *   - Tests are independent (e.g. a assertion failure does not cause multiple
   *     failing results, e.g. failure of the child test does not also cause the
   *     parent to fail or vice-versa as is typical in many 'subtest' arrangements).
   *   - In case of retries, you are happy for each test passing individually at least
   *     once to allow CL submission. I.E. they do not all have to pass in the same run.
   *
   *   The above criteria are important to keep the test results view understandable in
   *   case of retries, and to protect the data model that downstream clients
   *   rely on (e.g. clients must report passes where they report failures).
   *
   *   If they cannot be met, do not upload separate tests results and prefer to upload one
   *   test result per top-level method. Currently Mocha and Jest tests, and parameterised
   *   GTest methods are the only cases where it is known these requirements can be met. Python
   *   unittests and go subtests do not meet the requirements due to falling foul of the
   *   independence requirement (and in case of python unittests, also the inability to
   *   report passes for subtests).
   *
   * Constraints:
   * - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C),
   *   unless it is to write the value "*fixture".
   * - The use of the ':' character is reserved for denoting variable depth/extended depth
   *   hierarchies. If you do not intend this semantic, you must escape it using a backslash.
   *   (You must also escape all backslashes that are not denoting an escape sequence with
   *   a backslash.)
   * - When the case_name is broken up by ':', each such component must be non-empty.
   * - Limited to 512 bytes of printable UTF-8. For the purposes of this
   *   definition, the unicode replacement character (U+FFFD) is not considered printable.
   *   See also length limits on `TestIdentifier` as a whole.
   * - All unicode must be in Normalization Form C.
   * - Use of spaces is allowed, but discouraged.
   * - Legacy test identifiers (in module "legacy") are exempted from some of the
   *   above constraints to facilitate backwards compatibility but use of this quirk is
   *   discouraged.
   */
  readonly caseName: string;
}

/**
 * TestIdentifierPrefix represents a prefix of a structured test id.
 *
 * For the purposes of this message, all module_* fields are considered one
 * logical field and must be set together.
 *
 * Compared to the TestIdentifier message, this message tracks which
 * parts of the prefix is present. This is necessary, as:
 *
 * module_name: "//bazel_path:my_target"
 * module_variant: [...]
 * module_scheme: "myscheme"
 * (module prefix)
 *
 * differs semantically from
 *
 * module_name: "//bazel_path:my_target"
 * module_variant: [...]
 * module_scheme: "myscheme"
 * coarse_name: ""
 * (coarse name prefix)
 *
 * As the former represents a module-level aggregate and the latter a coarse-name
 * aggregate for coarse name "".
 */
export interface TestIdentifierPrefix {
  /** The aggregation level represented by the prefix. */
  readonly level: AggregationLevel;
  /**
   * The test identifier. This may have only some fields set, based on the
   * selected aggregation level.
   * If an AggregationLevel of Invocation is set, identifier must be unset or all its fields must be empty.
   * If an AggregationLevel of Module is set, all module fields must be set.
   * If an AggregationLevel of Coarse is set, all module fields and the coarse_name field must be set.
   * If an AggregationLevel of Fine is set, all module fields, and the coarse_name and fine_name fields must be set.
   * If an AggregationLevel of Case is set, all fields must be set.
   *
   * In case of coarse_name and fine_name, as empty ("") is a valid value, the fields
   * are taken to be set according to the set AggregationLevel.
   */
  readonly id: TestIdentifier | undefined;
}

/** ModuleIdentifier represents the identity of a module. */
export interface ModuleIdentifier {
  /**
   * The name of the module being tested. A module is a set of tests which run
   * with the same test harness, and typically corresponds with a unit of
   * build, such as a bazel test target.
   *
   * See TestIdentifier.module_name for more details.
   */
  readonly moduleName: string;
  /**
   * The scheme of the module, for example, "junit" or "gtest".
   *
   * Must match one of the schemes in the ResultDB service configuration (see
   * go/resultdb-schemes). Additional values can be configured as needed.
   *
   * See TestIdentifier.module_scheme for more details.
   */
  readonly moduleScheme: string;
  /**
   * Description of one specific way of running the tests in a module,
   * e.g. specific ABI (x64/x86/...), build flags and/or operating system.
   *
   * See TestIdentifier.module_variant for more details.
   */
  readonly moduleVariant:
    | Variant
    | undefined;
  /**
   * Hash of the module variant.
   *
   * In the context of the WorkUnit record, this field is always OUTPUT_ONLY and will be
   * automatically computed from the provided module_variant (do not set it yourself).
   * In the context of ResultDB Query RPCs accepting this type as a request filter,
   * this field may be specified as an alternative to module_variant.
   *
   * See TestIdentifier.module_variant_hash for more details.
   */
  readonly moduleVariantHash: string;
}

/**
 * GitilesCommit specifies the position of the gitiles commit an invocation
 * ran against, in a repository's commit log. More specifically, a ref's commit
 * log.
 *
 * It also specifies the host/project/ref combination that the commit
 * exists in, to provide context.
 */
export interface GitilesCommit {
  /**
   * The identity of the gitiles host, e.g. "chromium.googlesource.com".
   * Mandatory.
   */
  readonly host: string;
  /** Repository name on the host, e.g. "chromium/src". Mandatory. */
  readonly project: string;
  /**
   * Commit ref, e.g. "refs/heads/main" from which the commit was fetched.
   * Not the branch name, use "refs/heads/branch"
   * Mandatory.
   */
  readonly ref: string;
  /** Commit HEX SHA1. All lowercase. Mandatory. */
  readonly commitHash: string;
  /**
   * Defines a total order of commits on the ref.
   * A positive, monotonically increasing integer. The recommended
   * way of obtaining this is by using the goto.google.com/git-numberer
   * Gerrit plugin. Other solutions can be used as well, so long
   * as the same scheme is used consistently for a ref.
   * Mandatory.
   */
  readonly position: string;
}

/** A Gerrit patchset. */
export interface GerritChange {
  /** Gerrit hostname, e.g. "chromium-review.googlesource.com". */
  readonly host: string;
  /** Gerrit project, e.g. "chromium/src". */
  readonly project: string;
  /** Change number, e.g. 12345. */
  readonly change: string;
  /** Patch set number, e.g. 1. */
  readonly patchset: string;
}

/**
 * Specifies the build ID of a submitted Android build. A submitted build is a
 * build that uses only changes that have been submitted to a branch.
 */
export interface SubmittedAndroidBuild {
  /**
   * The Android Build API data realm.
   * This is usually `prod`.
   */
  readonly dataRealm: string;
  /**
   * The Android Build branch.
   * E.g. `git_main`.
   */
  readonly branch: string;
  /**
   * The build ID of the *submitted* build.
   *
   * This must be parsed to an integer, as this will be exported to BigQuery
   * and used for sorting results in source order.
   *
   * When comparing two build IDs on the same data realm and branch, we expect:
   * - A higher number means a newer version of sources were used in a build.
   * - An equal number means the same version of sources used in a build.
   * - A smaller number means an earlier version of sources were used in a build.
   */
  readonly buildId: string;
}

/** Specifies the source code that was tested. */
export interface Sources {
  /** The base version of code sources checked out. */
  readonly gitilesCommit?:
    | GitilesCommit
    | undefined;
  /**
   * The submitted Android Build ID that describes the base code sources tested.
   *
   * In presubmit, where the invocation is testing a pending build (a build ID
   * starting with "P"), lookup its reference build (which will be a submitted
   * build) and specify it here. Then specify the cherry-picked changes under
   * `changelists`.
   */
  readonly submittedAndroidBuild?:
    | SubmittedAndroidBuild
    | undefined;
  /**
   * The changelist(s) which were applied upon the base version of sources
   * checked out. E.g. in presubmit tryjobs.
   *
   * At most 10 changelist(s) may be specified here. If there
   * are more, only include the first 10 and set is_dirty.
   */
  readonly changelists: readonly GerritChange[];
  /**
   * Whether there were any changes made to the sources, not described above.
   * For example, a version of a dependency was upgraded before testing (e.g.
   * in an autoroller recipe).
   *
   * Cherry-picking a changelist on top of the base checkout is not considered
   * making the sources dirty as it is reported separately in `changelists` above.
   */
  readonly isDirty: boolean;
}

/** Deprecated: Use GitilesCommit instead. */
export interface CommitPosition {
  /**
   * The following fields identify a git repository and a ref within which the
   * numerical position below identifies a single commit.
   */
  readonly host: string;
  readonly project: string;
  readonly ref: string;
  /**
   * The numerical position of the commit in the log for the host/project/ref
   * above.
   */
  readonly position: string;
}

/** Represents a reference in a source control system. */
export interface SourceRef {
  /** A branch in gitiles repository. */
  readonly gitiles?:
    | GitilesRef
    | undefined;
  /** A branch in Android Build API. */
  readonly androidBuild?: AndroidBuildBranch | undefined;
}

/** Represents a branch in a gitiles repository. */
export interface GitilesRef {
  /** The gitiles host, e.g. "chromium.googlesource.com". */
  readonly host: string;
  /** The project on the gitiles host, e.g. "chromium/src". */
  readonly project: string;
  /**
   * Commit ref, e.g. "refs/heads/main" from which the commit was fetched.
   * Not the branch name, use "refs/heads/branch"
   */
  readonly ref: string;
}

/** Represents a branch in Android Build API. */
export interface AndroidBuildBranch {
  /**
   * The Android Build API data realm.
   * This is usually `prod`.
   */
  readonly dataRealm: string;
  /**
   * The Android Build branch.
   * E.g. `git_main`.
   */
  readonly branch: string;
}

function createBaseVariant(): Variant {
  return { def: {} };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.def).forEach(([key, value]) => {
      Variant_DefEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Variant_DefEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.def[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant {
    return {
      def: isObject(object.def)
        ? Object.entries(object.def).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Variant): unknown {
    const obj: any = {};
    if (message.def) {
      const entries = Object.entries(message.def);
      if (entries.length > 0) {
        obj.def = {};
        entries.forEach(([k, v]) => {
          obj.def[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Variant>): Variant {
    return Variant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant>): Variant {
    const message = createBaseVariant() as any;
    message.def = Object.entries(object.def ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseVariant_DefEntry(): Variant_DefEntry {
  return { key: "", value: "" };
}

export const Variant_DefEntry: MessageFns<Variant_DefEntry> = {
  encode(message: Variant_DefEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant_DefEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant_DefEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant_DefEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Variant_DefEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Variant_DefEntry>): Variant_DefEntry {
    return Variant_DefEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant_DefEntry>): Variant_DefEntry {
    const message = createBaseVariant_DefEntry() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStringPair(): StringPair {
  return { key: "", value: "" };
}

export const StringPair: MessageFns<StringPair> = {
  encode(message: StringPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringPair() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringPair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StringPair): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StringPair>): StringPair {
    return StringPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringPair>): StringPair {
    const message = createBaseStringPair() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTestIdentifier(): TestIdentifier {
  return {
    moduleName: "",
    moduleScheme: "",
    moduleVariant: undefined,
    moduleVariantHash: "",
    coarseName: "",
    fineName: "",
    caseName: "",
  };
}

export const TestIdentifier: MessageFns<TestIdentifier> = {
  encode(message: TestIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.moduleScheme !== "") {
      writer.uint32(18).string(message.moduleScheme);
    }
    if (message.moduleVariant !== undefined) {
      Variant.encode(message.moduleVariant, writer.uint32(26).fork()).join();
    }
    if (message.moduleVariantHash !== "") {
      writer.uint32(34).string(message.moduleVariantHash);
    }
    if (message.coarseName !== "") {
      writer.uint32(42).string(message.coarseName);
    }
    if (message.fineName !== "") {
      writer.uint32(50).string(message.fineName);
    }
    if (message.caseName !== "") {
      writer.uint32(58).string(message.caseName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestIdentifier() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleScheme = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVariant = Variant.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.moduleVariantHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.coarseName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fineName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.caseName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestIdentifier {
    return {
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      moduleScheme: isSet(object.moduleScheme) ? globalThis.String(object.moduleScheme) : "",
      moduleVariant: isSet(object.moduleVariant) ? Variant.fromJSON(object.moduleVariant) : undefined,
      moduleVariantHash: isSet(object.moduleVariantHash) ? globalThis.String(object.moduleVariantHash) : "",
      coarseName: isSet(object.coarseName) ? globalThis.String(object.coarseName) : "",
      fineName: isSet(object.fineName) ? globalThis.String(object.fineName) : "",
      caseName: isSet(object.caseName) ? globalThis.String(object.caseName) : "",
    };
  },

  toJSON(message: TestIdentifier): unknown {
    const obj: any = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.moduleScheme !== "") {
      obj.moduleScheme = message.moduleScheme;
    }
    if (message.moduleVariant !== undefined) {
      obj.moduleVariant = Variant.toJSON(message.moduleVariant);
    }
    if (message.moduleVariantHash !== "") {
      obj.moduleVariantHash = message.moduleVariantHash;
    }
    if (message.coarseName !== "") {
      obj.coarseName = message.coarseName;
    }
    if (message.fineName !== "") {
      obj.fineName = message.fineName;
    }
    if (message.caseName !== "") {
      obj.caseName = message.caseName;
    }
    return obj;
  },

  create(base?: DeepPartial<TestIdentifier>): TestIdentifier {
    return TestIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestIdentifier>): TestIdentifier {
    const message = createBaseTestIdentifier() as any;
    message.moduleName = object.moduleName ?? "";
    message.moduleScheme = object.moduleScheme ?? "";
    message.moduleVariant = (object.moduleVariant !== undefined && object.moduleVariant !== null)
      ? Variant.fromPartial(object.moduleVariant)
      : undefined;
    message.moduleVariantHash = object.moduleVariantHash ?? "";
    message.coarseName = object.coarseName ?? "";
    message.fineName = object.fineName ?? "";
    message.caseName = object.caseName ?? "";
    return message;
  },
};

function createBaseTestIdentifierPrefix(): TestIdentifierPrefix {
  return { level: 0, id: undefined };
}

export const TestIdentifierPrefix: MessageFns<TestIdentifierPrefix> = {
  encode(message: TestIdentifierPrefix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    if (message.id !== undefined) {
      TestIdentifier.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestIdentifierPrefix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestIdentifierPrefix() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = TestIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestIdentifierPrefix {
    return {
      level: isSet(object.level) ? aggregationLevelFromJSON(object.level) : 0,
      id: isSet(object.id) ? TestIdentifier.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: TestIdentifierPrefix): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = aggregationLevelToJSON(message.level);
    }
    if (message.id !== undefined) {
      obj.id = TestIdentifier.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<TestIdentifierPrefix>): TestIdentifierPrefix {
    return TestIdentifierPrefix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestIdentifierPrefix>): TestIdentifierPrefix {
    const message = createBaseTestIdentifierPrefix() as any;
    message.level = object.level ?? 0;
    message.id = (object.id !== undefined && object.id !== null) ? TestIdentifier.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseModuleIdentifier(): ModuleIdentifier {
  return { moduleName: "", moduleScheme: "", moduleVariant: undefined, moduleVariantHash: "" };
}

export const ModuleIdentifier: MessageFns<ModuleIdentifier> = {
  encode(message: ModuleIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.moduleScheme !== "") {
      writer.uint32(18).string(message.moduleScheme);
    }
    if (message.moduleVariant !== undefined) {
      Variant.encode(message.moduleVariant, writer.uint32(26).fork()).join();
    }
    if (message.moduleVariantHash !== "") {
      writer.uint32(34).string(message.moduleVariantHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModuleIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModuleIdentifier() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.moduleScheme = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moduleVariant = Variant.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.moduleVariantHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModuleIdentifier {
    return {
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      moduleScheme: isSet(object.moduleScheme) ? globalThis.String(object.moduleScheme) : "",
      moduleVariant: isSet(object.moduleVariant) ? Variant.fromJSON(object.moduleVariant) : undefined,
      moduleVariantHash: isSet(object.moduleVariantHash) ? globalThis.String(object.moduleVariantHash) : "",
    };
  },

  toJSON(message: ModuleIdentifier): unknown {
    const obj: any = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.moduleScheme !== "") {
      obj.moduleScheme = message.moduleScheme;
    }
    if (message.moduleVariant !== undefined) {
      obj.moduleVariant = Variant.toJSON(message.moduleVariant);
    }
    if (message.moduleVariantHash !== "") {
      obj.moduleVariantHash = message.moduleVariantHash;
    }
    return obj;
  },

  create(base?: DeepPartial<ModuleIdentifier>): ModuleIdentifier {
    return ModuleIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModuleIdentifier>): ModuleIdentifier {
    const message = createBaseModuleIdentifier() as any;
    message.moduleName = object.moduleName ?? "";
    message.moduleScheme = object.moduleScheme ?? "";
    message.moduleVariant = (object.moduleVariant !== undefined && object.moduleVariant !== null)
      ? Variant.fromPartial(object.moduleVariant)
      : undefined;
    message.moduleVariantHash = object.moduleVariantHash ?? "";
    return message;
  },
};

function createBaseGitilesCommit(): GitilesCommit {
  return { host: "", project: "", ref: "", commitHash: "", position: "0" };
}

export const GitilesCommit: MessageFns<GitilesCommit> = {
  encode(message: GitilesCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    if (message.commitHash !== "") {
      writer.uint32(34).string(message.commitHash);
    }
    if (message.position !== "0") {
      writer.uint32(40).int64(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitilesCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitilesCommit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.position = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitilesCommit {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "0",
    };
  },

  toJSON(message: GitilesCommit): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.commitHash !== "") {
      obj.commitHash = message.commitHash;
    }
    if (message.position !== "0") {
      obj.position = message.position;
    }
    return obj;
  },

  create(base?: DeepPartial<GitilesCommit>): GitilesCommit {
    return GitilesCommit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitilesCommit>): GitilesCommit {
    const message = createBaseGitilesCommit() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.ref = object.ref ?? "";
    message.commitHash = object.commitHash ?? "";
    message.position = object.position ?? "0";
    return message;
  },
};

function createBaseGerritChange(): GerritChange {
  return { host: "", project: "", change: "0", patchset: "0" };
}

export const GerritChange: MessageFns<GerritChange> = {
  encode(message: GerritChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.change !== "0") {
      writer.uint32(24).int64(message.change);
    }
    if (message.patchset !== "0") {
      writer.uint32(32).int64(message.patchset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.change = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.patchset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChange {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      change: isSet(object.change) ? globalThis.String(object.change) : "0",
      patchset: isSet(object.patchset) ? globalThis.String(object.patchset) : "0",
    };
  },

  toJSON(message: GerritChange): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.change !== "0") {
      obj.change = message.change;
    }
    if (message.patchset !== "0") {
      obj.patchset = message.patchset;
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChange>): GerritChange {
    return GerritChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChange>): GerritChange {
    const message = createBaseGerritChange() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.change = object.change ?? "0";
    message.patchset = object.patchset ?? "0";
    return message;
  },
};

function createBaseSubmittedAndroidBuild(): SubmittedAndroidBuild {
  return { dataRealm: "", branch: "", buildId: "0" };
}

export const SubmittedAndroidBuild: MessageFns<SubmittedAndroidBuild> = {
  encode(message: SubmittedAndroidBuild, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataRealm !== "") {
      writer.uint32(10).string(message.dataRealm);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.buildId !== "0") {
      writer.uint32(24).int64(message.buildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmittedAndroidBuild {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmittedAndroidBuild() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataRealm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buildId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmittedAndroidBuild {
    return {
      dataRealm: isSet(object.dataRealm) ? globalThis.String(object.dataRealm) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "0",
    };
  },

  toJSON(message: SubmittedAndroidBuild): unknown {
    const obj: any = {};
    if (message.dataRealm !== "") {
      obj.dataRealm = message.dataRealm;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.buildId !== "0") {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create(base?: DeepPartial<SubmittedAndroidBuild>): SubmittedAndroidBuild {
    return SubmittedAndroidBuild.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmittedAndroidBuild>): SubmittedAndroidBuild {
    const message = createBaseSubmittedAndroidBuild() as any;
    message.dataRealm = object.dataRealm ?? "";
    message.branch = object.branch ?? "";
    message.buildId = object.buildId ?? "0";
    return message;
  },
};

function createBaseSources(): Sources {
  return { gitilesCommit: undefined, submittedAndroidBuild: undefined, changelists: [], isDirty: false };
}

export const Sources: MessageFns<Sources> = {
  encode(message: Sources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitilesCommit !== undefined) {
      GitilesCommit.encode(message.gitilesCommit, writer.uint32(10).fork()).join();
    }
    if (message.submittedAndroidBuild !== undefined) {
      SubmittedAndroidBuild.encode(message.submittedAndroidBuild, writer.uint32(34).fork()).join();
    }
    for (const v of message.changelists) {
      GerritChange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.isDirty !== false) {
      writer.uint32(24).bool(message.isDirty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitilesCommit = GitilesCommit.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.submittedAndroidBuild = SubmittedAndroidBuild.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.changelists.push(GerritChange.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDirty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sources {
    return {
      gitilesCommit: isSet(object.gitilesCommit) ? GitilesCommit.fromJSON(object.gitilesCommit) : undefined,
      submittedAndroidBuild: isSet(object.submittedAndroidBuild)
        ? SubmittedAndroidBuild.fromJSON(object.submittedAndroidBuild)
        : undefined,
      changelists: globalThis.Array.isArray(object?.changelists)
        ? object.changelists.map((e: any) => GerritChange.fromJSON(e))
        : [],
      isDirty: isSet(object.isDirty) ? globalThis.Boolean(object.isDirty) : false,
    };
  },

  toJSON(message: Sources): unknown {
    const obj: any = {};
    if (message.gitilesCommit !== undefined) {
      obj.gitilesCommit = GitilesCommit.toJSON(message.gitilesCommit);
    }
    if (message.submittedAndroidBuild !== undefined) {
      obj.submittedAndroidBuild = SubmittedAndroidBuild.toJSON(message.submittedAndroidBuild);
    }
    if (message.changelists?.length) {
      obj.changelists = message.changelists.map((e) => GerritChange.toJSON(e));
    }
    if (message.isDirty !== false) {
      obj.isDirty = message.isDirty;
    }
    return obj;
  },

  create(base?: DeepPartial<Sources>): Sources {
    return Sources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Sources>): Sources {
    const message = createBaseSources() as any;
    message.gitilesCommit = (object.gitilesCommit !== undefined && object.gitilesCommit !== null)
      ? GitilesCommit.fromPartial(object.gitilesCommit)
      : undefined;
    message.submittedAndroidBuild =
      (object.submittedAndroidBuild !== undefined && object.submittedAndroidBuild !== null)
        ? SubmittedAndroidBuild.fromPartial(object.submittedAndroidBuild)
        : undefined;
    message.changelists = object.changelists?.map((e) => GerritChange.fromPartial(e)) || [];
    message.isDirty = object.isDirty ?? false;
    return message;
  },
};

function createBaseCommitPosition(): CommitPosition {
  return { host: "", project: "", ref: "", position: "0" };
}

export const CommitPosition: MessageFns<CommitPosition> = {
  encode(message: CommitPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    if (message.position !== "0") {
      writer.uint32(32).int64(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitPosition() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitPosition {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "0",
    };
  },

  toJSON(message: CommitPosition): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.position !== "0") {
      obj.position = message.position;
    }
    return obj;
  },

  create(base?: DeepPartial<CommitPosition>): CommitPosition {
    return CommitPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitPosition>): CommitPosition {
    const message = createBaseCommitPosition() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.ref = object.ref ?? "";
    message.position = object.position ?? "0";
    return message;
  },
};

function createBaseSourceRef(): SourceRef {
  return { gitiles: undefined, androidBuild: undefined };
}

export const SourceRef: MessageFns<SourceRef> = {
  encode(message: SourceRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitiles !== undefined) {
      GitilesRef.encode(message.gitiles, writer.uint32(10).fork()).join();
    }
    if (message.androidBuild !== undefined) {
      AndroidBuildBranch.encode(message.androidBuild, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitiles = GitilesRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.androidBuild = AndroidBuildBranch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceRef {
    return {
      gitiles: isSet(object.gitiles) ? GitilesRef.fromJSON(object.gitiles) : undefined,
      androidBuild: isSet(object.androidBuild) ? AndroidBuildBranch.fromJSON(object.androidBuild) : undefined,
    };
  },

  toJSON(message: SourceRef): unknown {
    const obj: any = {};
    if (message.gitiles !== undefined) {
      obj.gitiles = GitilesRef.toJSON(message.gitiles);
    }
    if (message.androidBuild !== undefined) {
      obj.androidBuild = AndroidBuildBranch.toJSON(message.androidBuild);
    }
    return obj;
  },

  create(base?: DeepPartial<SourceRef>): SourceRef {
    return SourceRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceRef>): SourceRef {
    const message = createBaseSourceRef() as any;
    message.gitiles = (object.gitiles !== undefined && object.gitiles !== null)
      ? GitilesRef.fromPartial(object.gitiles)
      : undefined;
    message.androidBuild = (object.androidBuild !== undefined && object.androidBuild !== null)
      ? AndroidBuildBranch.fromPartial(object.androidBuild)
      : undefined;
    return message;
  },
};

function createBaseGitilesRef(): GitilesRef {
  return { host: "", project: "", ref: "" };
}

export const GitilesRef: MessageFns<GitilesRef> = {
  encode(message: GitilesRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitilesRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitilesRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitilesRef {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: GitilesRef): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<GitilesRef>): GitilesRef {
    return GitilesRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitilesRef>): GitilesRef {
    const message = createBaseGitilesRef() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

function createBaseAndroidBuildBranch(): AndroidBuildBranch {
  return { dataRealm: "", branch: "" };
}

export const AndroidBuildBranch: MessageFns<AndroidBuildBranch> = {
  encode(message: AndroidBuildBranch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataRealm !== "") {
      writer.uint32(10).string(message.dataRealm);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidBuildBranch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidBuildBranch() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataRealm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidBuildBranch {
    return {
      dataRealm: isSet(object.dataRealm) ? globalThis.String(object.dataRealm) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
    };
  },

  toJSON(message: AndroidBuildBranch): unknown {
    const obj: any = {};
    if (message.dataRealm !== "") {
      obj.dataRealm = message.dataRealm;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidBuildBranch>): AndroidBuildBranch {
    return AndroidBuildBranch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidBuildBranch>): AndroidBuildBranch {
    const message = createBaseAndroidBuildBranch() as any;
    message.dataRealm = object.dataRealm ?? "";
    message.branch = object.branch ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
