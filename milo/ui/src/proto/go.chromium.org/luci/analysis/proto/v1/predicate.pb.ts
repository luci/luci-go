// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.31.1
// source: go.chromium.org/luci/analysis/proto/v1/predicate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SubmittedFilter, submittedFilterFromJSON, submittedFilterToJSON, TimeRange, Variant } from "./common.pb";

export const protobufPackage = "luci.analysis.v1";

/** Represents a function Variant -> bool. */
export interface VariantPredicate {
  /** A variant must be equal this definition exactly. */
  readonly equals?:
    | Variant
    | undefined;
  /** A variant's key-value pairs must contain those in this one. */
  readonly contains?:
    | Variant
    | undefined;
  /** A variant's hash must equal this value exactly. */
  readonly hashEquals?: string | undefined;
}

/** Represents a function TestVerdict -> bool. */
export interface TestVerdictPredicate {
  /**
   * Optional. The project-scoped realm to query the history from.
   * This is the realm without the "<project>:" prefix.
   *
   * When specified, only the test history entries found in the matching realm
   * will be returned.
   */
  readonly subRealm: string;
  /** Optional. The subset of test variants to request history for. */
  readonly variantPredicate:
    | VariantPredicate
    | undefined;
  /**
   * Optional. Whether test verdicts generated by code with unsubmitted changes
   * (e.g. Gerrit changes) should be included in the response.
   *
   * If no filter is specified, all verdicts are returned (regardless of
   * submitted status).
   */
  readonly submittedFilter: SubmittedFilter;
  /**
   * Optional. Specify a range of timestamps to query the test history from.
   *
   * Test history older than the configured TTL (90 days) will not be returned.
   * When omitted, return all available test history.
   */
  readonly partitionTimeRange:
    | TimeRange
    | undefined;
  /**
   * Optional. Whether to include the test results from LUCI Bisection.
   * Results from LUCI Bisection are only return if this is true.
   * LUCI Bisection results are excluded by default.
   */
  readonly includeBisectionResults: boolean;
}

function createBaseVariantPredicate(): VariantPredicate {
  return { equals: undefined, contains: undefined, hashEquals: undefined };
}

export const VariantPredicate: MessageFns<VariantPredicate> = {
  encode(message: VariantPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.equals !== undefined) {
      Variant.encode(message.equals, writer.uint32(10).fork()).join();
    }
    if (message.contains !== undefined) {
      Variant.encode(message.contains, writer.uint32(18).fork()).join();
    }
    if (message.hashEquals !== undefined) {
      writer.uint32(26).string(message.hashEquals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantPredicate() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.equals = Variant.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contains = Variant.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hashEquals = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantPredicate {
    return {
      equals: isSet(object.equals) ? Variant.fromJSON(object.equals) : undefined,
      contains: isSet(object.contains) ? Variant.fromJSON(object.contains) : undefined,
      hashEquals: isSet(object.hashEquals) ? globalThis.String(object.hashEquals) : undefined,
    };
  },

  toJSON(message: VariantPredicate): unknown {
    const obj: any = {};
    if (message.equals !== undefined) {
      obj.equals = Variant.toJSON(message.equals);
    }
    if (message.contains !== undefined) {
      obj.contains = Variant.toJSON(message.contains);
    }
    if (message.hashEquals !== undefined) {
      obj.hashEquals = message.hashEquals;
    }
    return obj;
  },

  create(base?: DeepPartial<VariantPredicate>): VariantPredicate {
    return VariantPredicate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VariantPredicate>): VariantPredicate {
    const message = createBaseVariantPredicate() as any;
    message.equals = (object.equals !== undefined && object.equals !== null)
      ? Variant.fromPartial(object.equals)
      : undefined;
    message.contains = (object.contains !== undefined && object.contains !== null)
      ? Variant.fromPartial(object.contains)
      : undefined;
    message.hashEquals = object.hashEquals ?? undefined;
    return message;
  },
};

function createBaseTestVerdictPredicate(): TestVerdictPredicate {
  return {
    subRealm: "",
    variantPredicate: undefined,
    submittedFilter: 0,
    partitionTimeRange: undefined,
    includeBisectionResults: false,
  };
}

export const TestVerdictPredicate: MessageFns<TestVerdictPredicate> = {
  encode(message: TestVerdictPredicate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subRealm !== "") {
      writer.uint32(10).string(message.subRealm);
    }
    if (message.variantPredicate !== undefined) {
      VariantPredicate.encode(message.variantPredicate, writer.uint32(18).fork()).join();
    }
    if (message.submittedFilter !== 0) {
      writer.uint32(24).int32(message.submittedFilter);
    }
    if (message.partitionTimeRange !== undefined) {
      TimeRange.encode(message.partitionTimeRange, writer.uint32(34).fork()).join();
    }
    if (message.includeBisectionResults !== false) {
      writer.uint32(40).bool(message.includeBisectionResults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestVerdictPredicate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestVerdictPredicate() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subRealm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variantPredicate = VariantPredicate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.submittedFilter = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.partitionTimeRange = TimeRange.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeBisectionResults = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestVerdictPredicate {
    return {
      subRealm: isSet(object.subRealm) ? globalThis.String(object.subRealm) : "",
      variantPredicate: isSet(object.variantPredicate) ? VariantPredicate.fromJSON(object.variantPredicate) : undefined,
      submittedFilter: isSet(object.submittedFilter) ? submittedFilterFromJSON(object.submittedFilter) : 0,
      partitionTimeRange: isSet(object.partitionTimeRange) ? TimeRange.fromJSON(object.partitionTimeRange) : undefined,
      includeBisectionResults: isSet(object.includeBisectionResults)
        ? globalThis.Boolean(object.includeBisectionResults)
        : false,
    };
  },

  toJSON(message: TestVerdictPredicate): unknown {
    const obj: any = {};
    if (message.subRealm !== "") {
      obj.subRealm = message.subRealm;
    }
    if (message.variantPredicate !== undefined) {
      obj.variantPredicate = VariantPredicate.toJSON(message.variantPredicate);
    }
    if (message.submittedFilter !== 0) {
      obj.submittedFilter = submittedFilterToJSON(message.submittedFilter);
    }
    if (message.partitionTimeRange !== undefined) {
      obj.partitionTimeRange = TimeRange.toJSON(message.partitionTimeRange);
    }
    if (message.includeBisectionResults !== false) {
      obj.includeBisectionResults = message.includeBisectionResults;
    }
    return obj;
  },

  create(base?: DeepPartial<TestVerdictPredicate>): TestVerdictPredicate {
    return TestVerdictPredicate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestVerdictPredicate>): TestVerdictPredicate {
    const message = createBaseTestVerdictPredicate() as any;
    message.subRealm = object.subRealm ?? "";
    message.variantPredicate = (object.variantPredicate !== undefined && object.variantPredicate !== null)
      ? VariantPredicate.fromPartial(object.variantPredicate)
      : undefined;
    message.submittedFilter = object.submittedFilter ?? 0;
    message.partitionTimeRange = (object.partitionTimeRange !== undefined && object.partitionTimeRange !== null)
      ? TimeRange.fromPartial(object.partitionTimeRange)
      : undefined;
    message.includeBisectionResults = object.includeBisectionResults ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
