// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.0
// source: go.chromium.org/luci/analysis/proto/v1/test_history.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../../../google/protobuf/duration.pb";
import { Timestamp } from "../../../../../google/protobuf/timestamp.pb";
import { FlatTestIdentifier, TestIdentifier, Variant } from "./common.pb";
import { TestVerdictPredicate, VariantPredicate } from "./predicate.pb";
import { Changelist, SourceRef, Sources } from "./sources.pb";
import {
  TestVerdict,
  TestVerdict_Status,
  testVerdict_StatusFromJSON,
  testVerdict_StatusToJSON,
} from "./test_verdict.pb";

export const protobufPackage = "luci.analysis.v1";

/** A request message for `TestHistory.Query` RPC. */
export interface QueryTestHistoryRequest {
  /**
   * Required. The LUCI Project of the test results.
   * I.e. For a result to be part of the history, it needs to be contained
   * transitively by an invocation in this project.
   */
  readonly project: string;
  /** Required. The test ID to query the history from. */
  readonly testId: string;
  /** Required. A test verdict in the response must satisfy this predicate. */
  readonly predicate:
    | TestVerdictPredicate
    | undefined;
  /**
   * If set, includes data from up to one prior ID of this test (if any).
   *
   * This has a performance cost and depends on the availability of
   * identifying the previous ID of this test (if indeed it was renamed).
   */
  readonly followTestIdRenaming: boolean;
  /**
   * The maximum number of entries to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 variants will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to the next call MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for `TestHistory.Query` RPC. */
export interface QueryTestHistoryResponse {
  /**
   * The list of test verdicts.
   * Test verdicts will be ordered by `partition_time` DESC, `variant_hash` ASC,
   * `invocation_id` ASC.
   */
  readonly verdicts: readonly TestVerdict[];
  /**
   * This field will be set if there are more results to return.
   * To get the next page of data, send the same request again, but include this
   * token.
   */
  readonly nextPageToken: string;
}

/** A request message for `TestHistory.QueryStats` RPC. */
export interface QueryTestHistoryStatsRequest {
  /**
   * Required. The LUCI Project of the test results.
   * I.e. For a result to be part of the history, it needs to be contained
   * transitively by an invocation in this project.
   */
  readonly project: string;
  /** Required. The test ID to query the history from. */
  readonly testId: string;
  /** Required. A test verdict in the response must satisfy this predicate. */
  readonly predicate:
    | TestVerdictPredicate
    | undefined;
  /**
   * If set, includes data from up to one prior ID of this test (if any).
   *
   * This has a performance cost and depends on the availability of
   * identifying the previous ID of this test (if indeed it was renamed).
   */
  readonly followTestIdRenaming: boolean;
  /**
   * The maximum number of entries to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 variants will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to the next call
   * MUST match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for `TestHistory.QueryStats` RPC. */
export interface QueryTestHistoryStatsResponse {
  /**
   * The list of test verdict groups. Test verdicts will be grouped and ordered
   * by `partition_date` DESC, `variant_hash` ASC.
   */
  readonly groups: readonly QueryTestHistoryStatsResponse_Group[];
  /**
   * This field will be set if there are more results to return.
   * To get the next page of data, send the same request again, but include this
   * token.
   */
  readonly nextPageToken: string;
}

export interface QueryTestHistoryStatsResponse_Group {
  /**
   * The start time of this group.
   * Test verdicts that are paritioned in the 24 hours following this
   * timestamp are captured in this group.
   */
  readonly partitionTime:
    | string
    | undefined;
  /** The hash of the variant. */
  readonly variantHash: string;
  /** The counts of verdicts in the group. */
  readonly verdictCounts:
    | QueryTestHistoryStatsResponse_Group_VerdictCounts
    | undefined;
  /**
   * Deprecated: Use `counts` field instead.
   * The number of unexpected test verdicts in the group.
   *
   * @deprecated
   */
  readonly unexpectedCount: number;
  /**
   * The number of unexpectedly skipped test verdicts in the group.
   *
   * @deprecated
   */
  readonly unexpectedlySkippedCount: number;
  /**
   * The number of flaky test verdicts in the group.
   *
   * @deprecated
   */
  readonly flakyCount: number;
  /**
   * The number of exonerated test verdicts in the group.
   *
   * @deprecated
   */
  readonly exoneratedCount: number;
  /**
   * The number of expected test verdicts in the group.
   *
   * @deprecated
   */
  readonly expectedCount: number;
  /** The average duration of passing test results in the group. */
  readonly passedAvgDuration: Duration | undefined;
}

/** Counts of verdicts, using verdict status v2. */
export interface QueryTestHistoryStatsResponse_Group_VerdictCounts {
  /**
   * The number of failed verdicts.
   * Count includes both exonerated and non-exonerated verdicts.
   */
  readonly failed: number;
  /** The number of flaky verdicts. */
  readonly flaky: number;
  /** The number of passed verdicts. */
  readonly passed: number;
  /** The number of skipped verdicts. */
  readonly skipped: number;
  /**
   * The number of execution errored verdicts.
   * Count includes both exonerated and non-exonerated verdicts.
   */
  readonly executionErrored: number;
  /**
   * The number of precluded verdicts.
   * Count includes both exonerated and non-exonerated verdicts.
   */
  readonly precluded: number;
  /** The number of failed verdicts with exonerations. */
  readonly failedExonerated: number;
  /** The number of execution errored verdicts with exonerations. */
  readonly executionErroredExonerated: number;
  /** The number of precluded verdicts with exonerations. */
  readonly precludedExonerated: number;
}

/** A request message for the `QueryVariants` RPC. */
export interface QueryVariantsRequest {
  /** Required. The LUCI project to query the variants from. */
  readonly project: string;
  /** Required. The test ID to query the variants from. */
  readonly testId: string;
  /**
   * Optional. The project-scoped realm to query the variants from.
   * This is the realm without the "<project>:" prefix.
   *
   * When specified, only the test variants found in the matching realm will be
   * returned.
   */
  readonly subRealm: string;
  /**
   * Optional. When specified, only variant matches this predicate will be
   * returned.
   */
  readonly variantPredicate:
    | VariantPredicate
    | undefined;
  /**
   * If set, includes data from up to one prior ID of this test (if any).
   *
   * This has a performance cost and depends on the availability of
   * identifying the previous ID of this test (if indeed it was renamed).
   */
  readonly followTestIdRenaming: boolean;
  /**
   * The maximum number of variants to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 variants will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryVariants` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryVariants` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
}

/** A response message for the `QueryVariants` RPC. */
export interface QueryVariantsResponse {
  /** A list of variants. Ordered by variant hash. */
  readonly variants: readonly QueryVariantsResponse_VariantInfo[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** Contains the variant definition and its hash. */
export interface QueryVariantsResponse_VariantInfo {
  /** The hash of the variant. */
  readonly variantHash: string;
  /** The definition of the variant. */
  readonly variant: Variant | undefined;
}

/** A request message for the `QueryTests` RPC. */
export interface QueryTestsRequest {
  /** Required. The LUCI project to query the tests from. */
  readonly project: string;
  /**
   * Required. The search string.
   * Only tests that contain the substring in the test_id or test_metadata.name
   * will be returned.
   */
  readonly testIdSubstring: string;
  /**
   * Optional. The project-scoped realm to query the variants from.
   * This is the realm without the "<project>:" prefix.
   *
   * When specified, only the tests found in the matching realm will be
   * returned.
   */
  readonly subRealm: string;
  /**
   * The maximum number of test IDs to return.
   *
   * The service may return fewer than this value.
   * If unspecified, at most 100 test IDs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `QueryTests` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `QueryTests` MUST
   * match the call that provided the page token.
   */
  readonly pageToken: string;
  /**
   * If true then the test_id_substring match will be case insensitive.  If false
   * the match will be case sensitive.
   */
  readonly caseInsensitive: boolean;
}

/** A response message for the `QueryTests` RPC. */
export interface QueryTestsResponse {
  /** A list of test Ids. Ordered alphabetically. */
  readonly testIds: readonly string[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there were no subsequent pages at the time of
   * request.
   */
  readonly nextPageToken: string;
}

/** A request message for the `QueryRecentPasses` RPC. */
export interface QueryRecentPassesRequest {
  /** Required. The LUCI Project of the failing test result. */
  readonly project: string;
  /** Required. The test ID of the failing test. */
  readonly testId: string;
  /**
   * Required. The variant hash of the failing test.
   * Passing results must match this variant to ensure logs are comparable.
   */
  readonly variantHash: string;
  /** Required. The source position attached to the failing result. */
  readonly sources:
    | Sources
    | undefined;
  /**
   * Optional. The maximum number of passing results to return.
   * The default is 5, the maximum is 25.
   */
  readonly limit: number;
}

/** A response message for `LogAssociation.QueryRecentPasses`. */
export interface QueryRecentPassesResponse {
  /**
   * A list of recent passing results for the specified
   * test variant, source position proximity.
   *
   * May be empty if no recent passing results could be found, e.g. if the test
   * has been failing for more than 14 days, or has never passed.
   */
  readonly passingResults: readonly QueryRecentPassesResponse_PassingResult[];
}

/** Identifying information for a passing test result. */
export interface QueryRecentPassesResponse_PassingResult {
  /**
   * The name of the test result.  This is in ResultDB test result name format
   * and so is suitable for passing directly to ResultDB.
   */
  readonly name: string;
}

/**
 * Queries source verdicts from the history of a specific (test, ref), for culprit finding.
 * Source verdicts aggregate all test results at a source position (e.g. git commit).
 *
 * Only the last ~90 days worth of data can be queried.
 */
export interface QuerySourceVerdictsV2Request {
  /** The LUCI Project. */
  readonly project: string;
  /** The test identifier, in structured form. */
  readonly testIdStructured?:
    | TestIdentifier
    | undefined;
  /** The test identifier, in flat form. */
  readonly testIdFlat?:
    | FlatTestIdentifier
    | undefined;
  /** The source ref (e.g. git branch). */
  readonly sourceRef:
    | SourceRef
    | undefined;
  /** The source ref hash. Specify as an alternative to `source_ref`. */
  readonly sourceRefHash: string;
  /**
   * An AIP-160 filter clause on the returned source verdicts.
   * Currently, the only field supported field is `position`.
   */
  readonly filter: string;
  /**
   * An AIP-132 order by clause controlling the sort order of the returned
   * source verdicts.
   * Currently, the only field supported field is `position`.
   *
   * See https://google.aip.dev/132#ordering
   */
  readonly orderBy: string;
  /**
   * The maximum number of source verdicts to return per page. The server may
   * return fewer than this number (including zero source verdicts), even if
   * not at the end of the collection.
   *
   * If unspecified, the server will decide a reasonable default. The maximum
   * value is 1000; values above 1000 will be coerced to 1000.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous QuerySourceVerdictsV2 call.
   * Provide this to retrieve the subsequent page.
   */
  readonly pageToken: string;
}

/** QuerySourceVerdictsV2Response contains the source verdicts for a specific (test, branch). */
export interface QuerySourceVerdictsV2Response {
  /**
   * Source verdicts in descending source position order. Only source verdicts
   * with test results are returned.
   */
  readonly sourceVerdicts: readonly SourceVerdict[];
  /**
   * A token to retrieve the next page of results. If this is empty, there are
   * no more pages to retrieve.
   */
  readonly nextPageToken: string;
}

/**
 * Source verdict summarises all results of a single test at a single source position
 * (e.g. git commit).
 */
export interface SourceVerdict {
  /**
   * The source position.
   * If source_ref was a GitilesRef, this is the git commit number assigned by goto.google.com/git-numberer.
   * If source_ref was an AndroidBuildBranch, this is the submitted Android build number.
   */
  readonly position: string;
  /**
   * The overall status of the test at this position.
   *
   * This field represents a 'clean' signal of the state of the test
   * and excludes results from presubmit (sources.changelists set) or derived sources
   * (sources.is_dirty set).
   *
   * If this field is set to UNSPECIFIED, it means there is no clean postsubmit result
   * at this position.
   */
  readonly status: TestVerdict_Status;
  /**
   * The approximate status of the test at this position, using results from presubmit runs
   * as well as postsubmit.
   *
   * By using data from presubmit runs (which test CLs patched on top of this position),
   * we obtain additional signal about the likely health of the test at the position but
   * at the cost of some additional noise (because the patched CL could break or fix the
   * test). In practice, we observe the realised noise to be low and the value of the
   * signal obtained to be high so use this status on LUCI UI.
   *
   * In future, we could try to reduce this noise by filtering out unsuccessful presubmit
   * runs, which are the most common source of presubmit noise.
   *
   * Like `status`, other types of derived sources (sources.is_dirty) are filtered out.
   */
  readonly approximateStatus: TestVerdict_Status;
  /**
   * The invocation test verdicts at the source position. Note some of these
   * test verdicts may be for presubmit runs (i.e. for CLs that have not been
   * submitted).
   *
   * Test verdicts will be ordered by ascending partition time, i.e. earliest test
   * verdict first.
   * Limited to at most 20 test verdicts.
   */
  readonly invocationVerdicts: readonly SourceVerdict_InvocationTestVerdict[];
}

/**
 * InvocationTestVerdict represents an invocation test verdict that contributed to the
 * source verdict.
 * An invocation test verdict summarises results of a single test in a single root
 * invocation.
 *
 * As multiple invocations can run the same test on the same base sources, there may be
 * many test verdicts at one source position.
 */
export interface SourceVerdict_InvocationTestVerdict {
  /**
   * The identity of the root invocation this test verdict belongs to.
   * Format: rootInvocations/{root_invocation_id}
   *
   * Alternatively, if the test verdict belongs to a legacy invocation, this field
   * will be empty and `invocation` below will be set instead.
   */
  readonly rootInvocation: string;
  /**
   * The identity of the invocation this test verdict belongs to.
   * Format: invocations/{invocation_id}
   */
  readonly invocation: string;
  /** The partition time of the test verdict. */
  readonly partitionTime:
    | string
    | undefined;
  /** The status of the test verdict. */
  readonly status: TestVerdict_Status;
  /**
   * The changelist(s) that were tested, if any. If there are more 10, only
   * the first 10 are listed here.
   * If this is set to a non-empty value, the results from this verdict are not
   * used in `status`.
   */
  readonly changelists: readonly Changelist[];
  /**
   * Whether the sources tested by the invocation had other changes (not
   * described by the changelists collection above).
   * Test results from such verdicts are not used in `status` or `approximate_status`.
   */
  readonly isSourcesDirty: boolean;
}

function createBaseQueryTestHistoryRequest(): QueryTestHistoryRequest {
  return { project: "", testId: "", predicate: undefined, followTestIdRenaming: false, pageSize: 0, pageToken: "" };
}

export const QueryTestHistoryRequest: MessageFns<QueryTestHistoryRequest> = {
  encode(message: QueryTestHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testId !== "") {
      writer.uint32(18).string(message.testId);
    }
    if (message.predicate !== undefined) {
      TestVerdictPredicate.encode(message.predicate, writer.uint32(26).fork()).join();
    }
    if (message.followTestIdRenaming !== false) {
      writer.uint32(48).bool(message.followTestIdRenaming);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predicate = TestVerdictPredicate.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.followTestIdRenaming = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      predicate: isSet(object.predicate) ? TestVerdictPredicate.fromJSON(object.predicate) : undefined,
      followTestIdRenaming: isSet(object.followTestIdRenaming)
        ? globalThis.Boolean(object.followTestIdRenaming)
        : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTestHistoryRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestVerdictPredicate.toJSON(message.predicate);
    }
    if (message.followTestIdRenaming !== false) {
      obj.followTestIdRenaming = message.followTestIdRenaming;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestHistoryRequest>): QueryTestHistoryRequest {
    return QueryTestHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestHistoryRequest>): QueryTestHistoryRequest {
    const message = createBaseQueryTestHistoryRequest() as any;
    message.project = object.project ?? "";
    message.testId = object.testId ?? "";
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestVerdictPredicate.fromPartial(object.predicate)
      : undefined;
    message.followTestIdRenaming = object.followTestIdRenaming ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTestHistoryResponse(): QueryTestHistoryResponse {
  return { verdicts: [], nextPageToken: "" };
}

export const QueryTestHistoryResponse: MessageFns<QueryTestHistoryResponse> = {
  encode(message: QueryTestHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.verdicts) {
      TestVerdict.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.verdicts.push(TestVerdict.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryResponse {
    return {
      verdicts: globalThis.Array.isArray(object?.verdicts)
        ? object.verdicts.map((e: any) => TestVerdict.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestHistoryResponse): unknown {
    const obj: any = {};
    if (message.verdicts?.length) {
      obj.verdicts = message.verdicts.map((e) => TestVerdict.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestHistoryResponse>): QueryTestHistoryResponse {
    return QueryTestHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestHistoryResponse>): QueryTestHistoryResponse {
    const message = createBaseQueryTestHistoryResponse() as any;
    message.verdicts = object.verdicts?.map((e) => TestVerdict.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryTestHistoryStatsRequest(): QueryTestHistoryStatsRequest {
  return { project: "", testId: "", predicate: undefined, followTestIdRenaming: false, pageSize: 0, pageToken: "" };
}

export const QueryTestHistoryStatsRequest: MessageFns<QueryTestHistoryStatsRequest> = {
  encode(message: QueryTestHistoryStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testId !== "") {
      writer.uint32(18).string(message.testId);
    }
    if (message.predicate !== undefined) {
      TestVerdictPredicate.encode(message.predicate, writer.uint32(26).fork()).join();
    }
    if (message.followTestIdRenaming !== false) {
      writer.uint32(48).bool(message.followTestIdRenaming);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryStatsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predicate = TestVerdictPredicate.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.followTestIdRenaming = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryStatsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      predicate: isSet(object.predicate) ? TestVerdictPredicate.fromJSON(object.predicate) : undefined,
      followTestIdRenaming: isSet(object.followTestIdRenaming)
        ? globalThis.Boolean(object.followTestIdRenaming)
        : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTestHistoryStatsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.predicate !== undefined) {
      obj.predicate = TestVerdictPredicate.toJSON(message.predicate);
    }
    if (message.followTestIdRenaming !== false) {
      obj.followTestIdRenaming = message.followTestIdRenaming;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestHistoryStatsRequest>): QueryTestHistoryStatsRequest {
    return QueryTestHistoryStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestHistoryStatsRequest>): QueryTestHistoryStatsRequest {
    const message = createBaseQueryTestHistoryStatsRequest() as any;
    message.project = object.project ?? "";
    message.testId = object.testId ?? "";
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? TestVerdictPredicate.fromPartial(object.predicate)
      : undefined;
    message.followTestIdRenaming = object.followTestIdRenaming ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTestHistoryStatsResponse(): QueryTestHistoryStatsResponse {
  return { groups: [], nextPageToken: "" };
}

export const QueryTestHistoryStatsResponse: MessageFns<QueryTestHistoryStatsResponse> = {
  encode(message: QueryTestHistoryStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      QueryTestHistoryStatsResponse_Group.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryStatsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(QueryTestHistoryStatsResponse_Group.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryStatsResponse {
    return {
      groups: globalThis.Array.isArray(object?.groups)
        ? object.groups.map((e: any) => QueryTestHistoryStatsResponse_Group.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestHistoryStatsResponse): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => QueryTestHistoryStatsResponse_Group.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestHistoryStatsResponse>): QueryTestHistoryStatsResponse {
    return QueryTestHistoryStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestHistoryStatsResponse>): QueryTestHistoryStatsResponse {
    const message = createBaseQueryTestHistoryStatsResponse() as any;
    message.groups = object.groups?.map((e) => QueryTestHistoryStatsResponse_Group.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryTestHistoryStatsResponse_Group(): QueryTestHistoryStatsResponse_Group {
  return {
    partitionTime: undefined,
    variantHash: "",
    verdictCounts: undefined,
    unexpectedCount: 0,
    unexpectedlySkippedCount: 0,
    flakyCount: 0,
    exoneratedCount: 0,
    expectedCount: 0,
    passedAvgDuration: undefined,
  };
}

export const QueryTestHistoryStatsResponse_Group: MessageFns<QueryTestHistoryStatsResponse_Group> = {
  encode(message: QueryTestHistoryStatsResponse_Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partitionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.partitionTime), writer.uint32(10).fork()).join();
    }
    if (message.variantHash !== "") {
      writer.uint32(18).string(message.variantHash);
    }
    if (message.verdictCounts !== undefined) {
      QueryTestHistoryStatsResponse_Group_VerdictCounts.encode(message.verdictCounts, writer.uint32(74).fork()).join();
    }
    if (message.unexpectedCount !== 0) {
      writer.uint32(24).int32(message.unexpectedCount);
    }
    if (message.unexpectedlySkippedCount !== 0) {
      writer.uint32(32).int32(message.unexpectedlySkippedCount);
    }
    if (message.flakyCount !== 0) {
      writer.uint32(40).int32(message.flakyCount);
    }
    if (message.exoneratedCount !== 0) {
      writer.uint32(48).int32(message.exoneratedCount);
    }
    if (message.expectedCount !== 0) {
      writer.uint32(56).int32(message.expectedCount);
    }
    if (message.passedAvgDuration !== undefined) {
      Duration.encode(message.passedAvgDuration, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryStatsResponse_Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryStatsResponse_Group() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.partitionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variantHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.verdictCounts = QueryTestHistoryStatsResponse_Group_VerdictCounts.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unexpectedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unexpectedlySkippedCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.flakyCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.exoneratedCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expectedCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.passedAvgDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryStatsResponse_Group {
    return {
      partitionTime: isSet(object.partitionTime) ? globalThis.String(object.partitionTime) : undefined,
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : "",
      verdictCounts: isSet(object.verdictCounts)
        ? QueryTestHistoryStatsResponse_Group_VerdictCounts.fromJSON(object.verdictCounts)
        : undefined,
      unexpectedCount: isSet(object.unexpectedCount) ? globalThis.Number(object.unexpectedCount) : 0,
      unexpectedlySkippedCount: isSet(object.unexpectedlySkippedCount)
        ? globalThis.Number(object.unexpectedlySkippedCount)
        : 0,
      flakyCount: isSet(object.flakyCount) ? globalThis.Number(object.flakyCount) : 0,
      exoneratedCount: isSet(object.exoneratedCount) ? globalThis.Number(object.exoneratedCount) : 0,
      expectedCount: isSet(object.expectedCount) ? globalThis.Number(object.expectedCount) : 0,
      passedAvgDuration: isSet(object.passedAvgDuration) ? Duration.fromJSON(object.passedAvgDuration) : undefined,
    };
  },

  toJSON(message: QueryTestHistoryStatsResponse_Group): unknown {
    const obj: any = {};
    if (message.partitionTime !== undefined) {
      obj.partitionTime = message.partitionTime;
    }
    if (message.variantHash !== "") {
      obj.variantHash = message.variantHash;
    }
    if (message.verdictCounts !== undefined) {
      obj.verdictCounts = QueryTestHistoryStatsResponse_Group_VerdictCounts.toJSON(message.verdictCounts);
    }
    if (message.unexpectedCount !== 0) {
      obj.unexpectedCount = Math.round(message.unexpectedCount);
    }
    if (message.unexpectedlySkippedCount !== 0) {
      obj.unexpectedlySkippedCount = Math.round(message.unexpectedlySkippedCount);
    }
    if (message.flakyCount !== 0) {
      obj.flakyCount = Math.round(message.flakyCount);
    }
    if (message.exoneratedCount !== 0) {
      obj.exoneratedCount = Math.round(message.exoneratedCount);
    }
    if (message.expectedCount !== 0) {
      obj.expectedCount = Math.round(message.expectedCount);
    }
    if (message.passedAvgDuration !== undefined) {
      obj.passedAvgDuration = Duration.toJSON(message.passedAvgDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestHistoryStatsResponse_Group>): QueryTestHistoryStatsResponse_Group {
    return QueryTestHistoryStatsResponse_Group.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestHistoryStatsResponse_Group>): QueryTestHistoryStatsResponse_Group {
    const message = createBaseQueryTestHistoryStatsResponse_Group() as any;
    message.partitionTime = object.partitionTime ?? undefined;
    message.variantHash = object.variantHash ?? "";
    message.verdictCounts = (object.verdictCounts !== undefined && object.verdictCounts !== null)
      ? QueryTestHistoryStatsResponse_Group_VerdictCounts.fromPartial(object.verdictCounts)
      : undefined;
    message.unexpectedCount = object.unexpectedCount ?? 0;
    message.unexpectedlySkippedCount = object.unexpectedlySkippedCount ?? 0;
    message.flakyCount = object.flakyCount ?? 0;
    message.exoneratedCount = object.exoneratedCount ?? 0;
    message.expectedCount = object.expectedCount ?? 0;
    message.passedAvgDuration = (object.passedAvgDuration !== undefined && object.passedAvgDuration !== null)
      ? Duration.fromPartial(object.passedAvgDuration)
      : undefined;
    return message;
  },
};

function createBaseQueryTestHistoryStatsResponse_Group_VerdictCounts(): QueryTestHistoryStatsResponse_Group_VerdictCounts {
  return {
    failed: 0,
    flaky: 0,
    passed: 0,
    skipped: 0,
    executionErrored: 0,
    precluded: 0,
    failedExonerated: 0,
    executionErroredExonerated: 0,
    precludedExonerated: 0,
  };
}

export const QueryTestHistoryStatsResponse_Group_VerdictCounts: MessageFns<
  QueryTestHistoryStatsResponse_Group_VerdictCounts
> = {
  encode(
    message: QueryTestHistoryStatsResponse_Group_VerdictCounts,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.failed !== 0) {
      writer.uint32(8).int32(message.failed);
    }
    if (message.flaky !== 0) {
      writer.uint32(16).int32(message.flaky);
    }
    if (message.passed !== 0) {
      writer.uint32(24).int32(message.passed);
    }
    if (message.skipped !== 0) {
      writer.uint32(32).int32(message.skipped);
    }
    if (message.executionErrored !== 0) {
      writer.uint32(40).int32(message.executionErrored);
    }
    if (message.precluded !== 0) {
      writer.uint32(48).int32(message.precluded);
    }
    if (message.failedExonerated !== 0) {
      writer.uint32(56).int32(message.failedExonerated);
    }
    if (message.executionErroredExonerated !== 0) {
      writer.uint32(64).int32(message.executionErroredExonerated);
    }
    if (message.precludedExonerated !== 0) {
      writer.uint32(72).int32(message.precludedExonerated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestHistoryStatsResponse_Group_VerdictCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestHistoryStatsResponse_Group_VerdictCounts() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.failed = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flaky = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.passed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.executionErrored = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.precluded = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.failedExonerated = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.executionErroredExonerated = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.precludedExonerated = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestHistoryStatsResponse_Group_VerdictCounts {
    return {
      failed: isSet(object.failed) ? globalThis.Number(object.failed) : 0,
      flaky: isSet(object.flaky) ? globalThis.Number(object.flaky) : 0,
      passed: isSet(object.passed) ? globalThis.Number(object.passed) : 0,
      skipped: isSet(object.skipped) ? globalThis.Number(object.skipped) : 0,
      executionErrored: isSet(object.executionErrored) ? globalThis.Number(object.executionErrored) : 0,
      precluded: isSet(object.precluded) ? globalThis.Number(object.precluded) : 0,
      failedExonerated: isSet(object.failedExonerated) ? globalThis.Number(object.failedExonerated) : 0,
      executionErroredExonerated: isSet(object.executionErroredExonerated)
        ? globalThis.Number(object.executionErroredExonerated)
        : 0,
      precludedExonerated: isSet(object.precludedExonerated) ? globalThis.Number(object.precludedExonerated) : 0,
    };
  },

  toJSON(message: QueryTestHistoryStatsResponse_Group_VerdictCounts): unknown {
    const obj: any = {};
    if (message.failed !== 0) {
      obj.failed = Math.round(message.failed);
    }
    if (message.flaky !== 0) {
      obj.flaky = Math.round(message.flaky);
    }
    if (message.passed !== 0) {
      obj.passed = Math.round(message.passed);
    }
    if (message.skipped !== 0) {
      obj.skipped = Math.round(message.skipped);
    }
    if (message.executionErrored !== 0) {
      obj.executionErrored = Math.round(message.executionErrored);
    }
    if (message.precluded !== 0) {
      obj.precluded = Math.round(message.precluded);
    }
    if (message.failedExonerated !== 0) {
      obj.failedExonerated = Math.round(message.failedExonerated);
    }
    if (message.executionErroredExonerated !== 0) {
      obj.executionErroredExonerated = Math.round(message.executionErroredExonerated);
    }
    if (message.precludedExonerated !== 0) {
      obj.precludedExonerated = Math.round(message.precludedExonerated);
    }
    return obj;
  },

  create(
    base?: DeepPartial<QueryTestHistoryStatsResponse_Group_VerdictCounts>,
  ): QueryTestHistoryStatsResponse_Group_VerdictCounts {
    return QueryTestHistoryStatsResponse_Group_VerdictCounts.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueryTestHistoryStatsResponse_Group_VerdictCounts>,
  ): QueryTestHistoryStatsResponse_Group_VerdictCounts {
    const message = createBaseQueryTestHistoryStatsResponse_Group_VerdictCounts() as any;
    message.failed = object.failed ?? 0;
    message.flaky = object.flaky ?? 0;
    message.passed = object.passed ?? 0;
    message.skipped = object.skipped ?? 0;
    message.executionErrored = object.executionErrored ?? 0;
    message.precluded = object.precluded ?? 0;
    message.failedExonerated = object.failedExonerated ?? 0;
    message.executionErroredExonerated = object.executionErroredExonerated ?? 0;
    message.precludedExonerated = object.precludedExonerated ?? 0;
    return message;
  },
};

function createBaseQueryVariantsRequest(): QueryVariantsRequest {
  return {
    project: "",
    testId: "",
    subRealm: "",
    variantPredicate: undefined,
    followTestIdRenaming: false,
    pageSize: 0,
    pageToken: "",
  };
}

export const QueryVariantsRequest: MessageFns<QueryVariantsRequest> = {
  encode(message: QueryVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testId !== "") {
      writer.uint32(18).string(message.testId);
    }
    if (message.subRealm !== "") {
      writer.uint32(26).string(message.subRealm);
    }
    if (message.variantPredicate !== undefined) {
      VariantPredicate.encode(message.variantPredicate, writer.uint32(50).fork()).join();
    }
    if (message.followTestIdRenaming !== false) {
      writer.uint32(56).bool(message.followTestIdRenaming);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVariantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subRealm = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.variantPredicate = VariantPredicate.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.followTestIdRenaming = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVariantsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      subRealm: isSet(object.subRealm) ? globalThis.String(object.subRealm) : "",
      variantPredicate: isSet(object.variantPredicate) ? VariantPredicate.fromJSON(object.variantPredicate) : undefined,
      followTestIdRenaming: isSet(object.followTestIdRenaming)
        ? globalThis.Boolean(object.followTestIdRenaming)
        : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryVariantsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.subRealm !== "") {
      obj.subRealm = message.subRealm;
    }
    if (message.variantPredicate !== undefined) {
      obj.variantPredicate = VariantPredicate.toJSON(message.variantPredicate);
    }
    if (message.followTestIdRenaming !== false) {
      obj.followTestIdRenaming = message.followTestIdRenaming;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryVariantsRequest>): QueryVariantsRequest {
    return QueryVariantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryVariantsRequest>): QueryVariantsRequest {
    const message = createBaseQueryVariantsRequest() as any;
    message.project = object.project ?? "";
    message.testId = object.testId ?? "";
    message.subRealm = object.subRealm ?? "";
    message.variantPredicate = (object.variantPredicate !== undefined && object.variantPredicate !== null)
      ? VariantPredicate.fromPartial(object.variantPredicate)
      : undefined;
    message.followTestIdRenaming = object.followTestIdRenaming ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryVariantsResponse(): QueryVariantsResponse {
  return { variants: [], nextPageToken: "" };
}

export const QueryVariantsResponse: MessageFns<QueryVariantsResponse> = {
  encode(message: QueryVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      QueryVariantsResponse_VariantInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVariantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variants.push(QueryVariantsResponse_VariantInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVariantsResponse {
    return {
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => QueryVariantsResponse_VariantInfo.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryVariantsResponse): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => QueryVariantsResponse_VariantInfo.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryVariantsResponse>): QueryVariantsResponse {
    return QueryVariantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryVariantsResponse>): QueryVariantsResponse {
    const message = createBaseQueryVariantsResponse() as any;
    message.variants = object.variants?.map((e) => QueryVariantsResponse_VariantInfo.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryVariantsResponse_VariantInfo(): QueryVariantsResponse_VariantInfo {
  return { variantHash: "", variant: undefined };
}

export const QueryVariantsResponse_VariantInfo: MessageFns<QueryVariantsResponse_VariantInfo> = {
  encode(message: QueryVariantsResponse_VariantInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantHash !== "") {
      writer.uint32(10).string(message.variantHash);
    }
    if (message.variant !== undefined) {
      Variant.encode(message.variant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVariantsResponse_VariantInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVariantsResponse_VariantInfo() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variant = Variant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVariantsResponse_VariantInfo {
    return {
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : "",
      variant: isSet(object.variant) ? Variant.fromJSON(object.variant) : undefined,
    };
  },

  toJSON(message: QueryVariantsResponse_VariantInfo): unknown {
    const obj: any = {};
    if (message.variantHash !== "") {
      obj.variantHash = message.variantHash;
    }
    if (message.variant !== undefined) {
      obj.variant = Variant.toJSON(message.variant);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryVariantsResponse_VariantInfo>): QueryVariantsResponse_VariantInfo {
    return QueryVariantsResponse_VariantInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryVariantsResponse_VariantInfo>): QueryVariantsResponse_VariantInfo {
    const message = createBaseQueryVariantsResponse_VariantInfo() as any;
    message.variantHash = object.variantHash ?? "";
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? Variant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseQueryTestsRequest(): QueryTestsRequest {
  return { project: "", testIdSubstring: "", subRealm: "", pageSize: 0, pageToken: "", caseInsensitive: false };
}

export const QueryTestsRequest: MessageFns<QueryTestsRequest> = {
  encode(message: QueryTestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testIdSubstring !== "") {
      writer.uint32(18).string(message.testIdSubstring);
    }
    if (message.subRealm !== "") {
      writer.uint32(26).string(message.subRealm);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(48).bool(message.caseInsensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testIdSubstring = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subRealm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testIdSubstring: isSet(object.testIdSubstring) ? globalThis.String(object.testIdSubstring) : "",
      subRealm: isSet(object.subRealm) ? globalThis.String(object.subRealm) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
    };
  },

  toJSON(message: QueryTestsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testIdSubstring !== "") {
      obj.testIdSubstring = message.testIdSubstring;
    }
    if (message.subRealm !== "") {
      obj.subRealm = message.subRealm;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestsRequest>): QueryTestsRequest {
    return QueryTestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestsRequest>): QueryTestsRequest {
    const message = createBaseQueryTestsRequest() as any;
    message.project = object.project ?? "";
    message.testIdSubstring = object.testIdSubstring ?? "";
    message.subRealm = object.subRealm ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.caseInsensitive = object.caseInsensitive ?? false;
    return message;
  },
};

function createBaseQueryTestsResponse(): QueryTestsResponse {
  return { testIds: [], nextPageToken: "" };
}

export const QueryTestsResponse: MessageFns<QueryTestsResponse> = {
  encode(message: QueryTestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testIds) {
      writer.uint32(10).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTestsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTestsResponse {
    return {
      testIds: globalThis.Array.isArray(object?.testIds) ? object.testIds.map((e: any) => globalThis.String(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QueryTestsResponse): unknown {
    const obj: any = {};
    if (message.testIds?.length) {
      obj.testIds = message.testIds;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTestsResponse>): QueryTestsResponse {
    return QueryTestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTestsResponse>): QueryTestsResponse {
    const message = createBaseQueryTestsResponse() as any;
    message.testIds = object.testIds?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryRecentPassesRequest(): QueryRecentPassesRequest {
  return { project: "", testId: "", variantHash: "", sources: undefined, limit: 0 };
}

export const QueryRecentPassesRequest: MessageFns<QueryRecentPassesRequest> = {
  encode(message: QueryRecentPassesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testId !== "") {
      writer.uint32(18).string(message.testId);
    }
    if (message.variantHash !== "") {
      writer.uint32(26).string(message.variantHash);
    }
    if (message.sources !== undefined) {
      Sources.encode(message.sources, writer.uint32(42).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRecentPassesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRecentPassesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sources = Sources.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRecentPassesRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testId: isSet(object.testId) ? globalThis.String(object.testId) : "",
      variantHash: isSet(object.variantHash) ? globalThis.String(object.variantHash) : "",
      sources: isSet(object.sources) ? Sources.fromJSON(object.sources) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: QueryRecentPassesRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testId !== "") {
      obj.testId = message.testId;
    }
    if (message.variantHash !== "") {
      obj.variantHash = message.variantHash;
    }
    if (message.sources !== undefined) {
      obj.sources = Sources.toJSON(message.sources);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRecentPassesRequest>): QueryRecentPassesRequest {
    return QueryRecentPassesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRecentPassesRequest>): QueryRecentPassesRequest {
    const message = createBaseQueryRecentPassesRequest() as any;
    message.project = object.project ?? "";
    message.testId = object.testId ?? "";
    message.variantHash = object.variantHash ?? "";
    message.sources = (object.sources !== undefined && object.sources !== null)
      ? Sources.fromPartial(object.sources)
      : undefined;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseQueryRecentPassesResponse(): QueryRecentPassesResponse {
  return { passingResults: [] };
}

export const QueryRecentPassesResponse: MessageFns<QueryRecentPassesResponse> = {
  encode(message: QueryRecentPassesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.passingResults) {
      QueryRecentPassesResponse_PassingResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRecentPassesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRecentPassesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.passingResults.push(QueryRecentPassesResponse_PassingResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRecentPassesResponse {
    return {
      passingResults: globalThis.Array.isArray(object?.passingResults)
        ? object.passingResults.map((e: any) => QueryRecentPassesResponse_PassingResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryRecentPassesResponse): unknown {
    const obj: any = {};
    if (message.passingResults?.length) {
      obj.passingResults = message.passingResults.map((e) => QueryRecentPassesResponse_PassingResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRecentPassesResponse>): QueryRecentPassesResponse {
    return QueryRecentPassesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRecentPassesResponse>): QueryRecentPassesResponse {
    const message = createBaseQueryRecentPassesResponse() as any;
    message.passingResults =
      object.passingResults?.map((e) => QueryRecentPassesResponse_PassingResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryRecentPassesResponse_PassingResult(): QueryRecentPassesResponse_PassingResult {
  return { name: "" };
}

export const QueryRecentPassesResponse_PassingResult: MessageFns<QueryRecentPassesResponse_PassingResult> = {
  encode(message: QueryRecentPassesResponse_PassingResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRecentPassesResponse_PassingResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRecentPassesResponse_PassingResult() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRecentPassesResponse_PassingResult {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: QueryRecentPassesResponse_PassingResult): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryRecentPassesResponse_PassingResult>): QueryRecentPassesResponse_PassingResult {
    return QueryRecentPassesResponse_PassingResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryRecentPassesResponse_PassingResult>): QueryRecentPassesResponse_PassingResult {
    const message = createBaseQueryRecentPassesResponse_PassingResult() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseQuerySourceVerdictsV2Request(): QuerySourceVerdictsV2Request {
  return {
    project: "",
    testIdStructured: undefined,
    testIdFlat: undefined,
    sourceRef: undefined,
    sourceRefHash: "",
    filter: "",
    orderBy: "",
    pageSize: 0,
    pageToken: "",
  };
}

export const QuerySourceVerdictsV2Request: MessageFns<QuerySourceVerdictsV2Request> = {
  encode(message: QuerySourceVerdictsV2Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.testIdStructured !== undefined) {
      TestIdentifier.encode(message.testIdStructured, writer.uint32(18).fork()).join();
    }
    if (message.testIdFlat !== undefined) {
      FlatTestIdentifier.encode(message.testIdFlat, writer.uint32(26).fork()).join();
    }
    if (message.sourceRef !== undefined) {
      SourceRef.encode(message.sourceRef, writer.uint32(34).fork()).join();
    }
    if (message.sourceRefHash !== "") {
      writer.uint32(74).string(message.sourceRefHash);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(66).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySourceVerdictsV2Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySourceVerdictsV2Request() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testIdStructured = TestIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testIdFlat = FlatTestIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceRef = SourceRef.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sourceRefHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySourceVerdictsV2Request {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      testIdStructured: isSet(object.testIdStructured) ? TestIdentifier.fromJSON(object.testIdStructured) : undefined,
      testIdFlat: isSet(object.testIdFlat) ? FlatTestIdentifier.fromJSON(object.testIdFlat) : undefined,
      sourceRef: isSet(object.sourceRef) ? SourceRef.fromJSON(object.sourceRef) : undefined,
      sourceRefHash: isSet(object.sourceRefHash) ? globalThis.String(object.sourceRefHash) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QuerySourceVerdictsV2Request): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.testIdStructured !== undefined) {
      obj.testIdStructured = TestIdentifier.toJSON(message.testIdStructured);
    }
    if (message.testIdFlat !== undefined) {
      obj.testIdFlat = FlatTestIdentifier.toJSON(message.testIdFlat);
    }
    if (message.sourceRef !== undefined) {
      obj.sourceRef = SourceRef.toJSON(message.sourceRef);
    }
    if (message.sourceRefHash !== "") {
      obj.sourceRefHash = message.sourceRefHash;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySourceVerdictsV2Request>): QuerySourceVerdictsV2Request {
    return QuerySourceVerdictsV2Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySourceVerdictsV2Request>): QuerySourceVerdictsV2Request {
    const message = createBaseQuerySourceVerdictsV2Request() as any;
    message.project = object.project ?? "";
    message.testIdStructured = (object.testIdStructured !== undefined && object.testIdStructured !== null)
      ? TestIdentifier.fromPartial(object.testIdStructured)
      : undefined;
    message.testIdFlat = (object.testIdFlat !== undefined && object.testIdFlat !== null)
      ? FlatTestIdentifier.fromPartial(object.testIdFlat)
      : undefined;
    message.sourceRef = (object.sourceRef !== undefined && object.sourceRef !== null)
      ? SourceRef.fromPartial(object.sourceRef)
      : undefined;
    message.sourceRefHash = object.sourceRefHash ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQuerySourceVerdictsV2Response(): QuerySourceVerdictsV2Response {
  return { sourceVerdicts: [], nextPageToken: "" };
}

export const QuerySourceVerdictsV2Response: MessageFns<QuerySourceVerdictsV2Response> = {
  encode(message: QuerySourceVerdictsV2Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sourceVerdicts) {
      SourceVerdict.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySourceVerdictsV2Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySourceVerdictsV2Response() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceVerdicts.push(SourceVerdict.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySourceVerdictsV2Response {
    return {
      sourceVerdicts: globalThis.Array.isArray(object?.sourceVerdicts)
        ? object.sourceVerdicts.map((e: any) => SourceVerdict.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: QuerySourceVerdictsV2Response): unknown {
    const obj: any = {};
    if (message.sourceVerdicts?.length) {
      obj.sourceVerdicts = message.sourceVerdicts.map((e) => SourceVerdict.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySourceVerdictsV2Response>): QuerySourceVerdictsV2Response {
    return QuerySourceVerdictsV2Response.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySourceVerdictsV2Response>): QuerySourceVerdictsV2Response {
    const message = createBaseQuerySourceVerdictsV2Response() as any;
    message.sourceVerdicts = object.sourceVerdicts?.map((e) => SourceVerdict.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSourceVerdict(): SourceVerdict {
  return { position: "0", status: 0, approximateStatus: 0, invocationVerdicts: [] };
}

export const SourceVerdict: MessageFns<SourceVerdict> = {
  encode(message: SourceVerdict, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== "0") {
      writer.uint32(8).int64(message.position);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.approximateStatus !== 0) {
      writer.uint32(24).int32(message.approximateStatus);
    }
    for (const v of message.invocationVerdicts) {
      SourceVerdict_InvocationTestVerdict.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceVerdict() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.position = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.approximateStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.invocationVerdicts.push(SourceVerdict_InvocationTestVerdict.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceVerdict {
    return {
      position: isSet(object.position) ? globalThis.String(object.position) : "0",
      status: isSet(object.status) ? testVerdict_StatusFromJSON(object.status) : 0,
      approximateStatus: isSet(object.approximateStatus) ? testVerdict_StatusFromJSON(object.approximateStatus) : 0,
      invocationVerdicts: globalThis.Array.isArray(object?.invocationVerdicts)
        ? object.invocationVerdicts.map((e: any) => SourceVerdict_InvocationTestVerdict.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SourceVerdict): unknown {
    const obj: any = {};
    if (message.position !== "0") {
      obj.position = message.position;
    }
    if (message.status !== 0) {
      obj.status = testVerdict_StatusToJSON(message.status);
    }
    if (message.approximateStatus !== 0) {
      obj.approximateStatus = testVerdict_StatusToJSON(message.approximateStatus);
    }
    if (message.invocationVerdicts?.length) {
      obj.invocationVerdicts = message.invocationVerdicts.map((e) => SourceVerdict_InvocationTestVerdict.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SourceVerdict>): SourceVerdict {
    return SourceVerdict.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceVerdict>): SourceVerdict {
    const message = createBaseSourceVerdict() as any;
    message.position = object.position ?? "0";
    message.status = object.status ?? 0;
    message.approximateStatus = object.approximateStatus ?? 0;
    message.invocationVerdicts =
      object.invocationVerdicts?.map((e) => SourceVerdict_InvocationTestVerdict.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSourceVerdict_InvocationTestVerdict(): SourceVerdict_InvocationTestVerdict {
  return {
    rootInvocation: "",
    invocation: "",
    partitionTime: undefined,
    status: 0,
    changelists: [],
    isSourcesDirty: false,
  };
}

export const SourceVerdict_InvocationTestVerdict: MessageFns<SourceVerdict_InvocationTestVerdict> = {
  encode(message: SourceVerdict_InvocationTestVerdict, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootInvocation !== "") {
      writer.uint32(10).string(message.rootInvocation);
    }
    if (message.invocation !== "") {
      writer.uint32(18).string(message.invocation);
    }
    if (message.partitionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.partitionTime), writer.uint32(26).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    for (const v of message.changelists) {
      Changelist.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.isSourcesDirty !== false) {
      writer.uint32(48).bool(message.isSourcesDirty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceVerdict_InvocationTestVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceVerdict_InvocationTestVerdict() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootInvocation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invocation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.partitionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.changelists.push(Changelist.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isSourcesDirty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceVerdict_InvocationTestVerdict {
    return {
      rootInvocation: isSet(object.rootInvocation) ? globalThis.String(object.rootInvocation) : "",
      invocation: isSet(object.invocation) ? globalThis.String(object.invocation) : "",
      partitionTime: isSet(object.partitionTime) ? globalThis.String(object.partitionTime) : undefined,
      status: isSet(object.status) ? testVerdict_StatusFromJSON(object.status) : 0,
      changelists: globalThis.Array.isArray(object?.changelists)
        ? object.changelists.map((e: any) => Changelist.fromJSON(e))
        : [],
      isSourcesDirty: isSet(object.isSourcesDirty) ? globalThis.Boolean(object.isSourcesDirty) : false,
    };
  },

  toJSON(message: SourceVerdict_InvocationTestVerdict): unknown {
    const obj: any = {};
    if (message.rootInvocation !== "") {
      obj.rootInvocation = message.rootInvocation;
    }
    if (message.invocation !== "") {
      obj.invocation = message.invocation;
    }
    if (message.partitionTime !== undefined) {
      obj.partitionTime = message.partitionTime;
    }
    if (message.status !== 0) {
      obj.status = testVerdict_StatusToJSON(message.status);
    }
    if (message.changelists?.length) {
      obj.changelists = message.changelists.map((e) => Changelist.toJSON(e));
    }
    if (message.isSourcesDirty !== false) {
      obj.isSourcesDirty = message.isSourcesDirty;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceVerdict_InvocationTestVerdict>): SourceVerdict_InvocationTestVerdict {
    return SourceVerdict_InvocationTestVerdict.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceVerdict_InvocationTestVerdict>): SourceVerdict_InvocationTestVerdict {
    const message = createBaseSourceVerdict_InvocationTestVerdict() as any;
    message.rootInvocation = object.rootInvocation ?? "";
    message.invocation = object.invocation ?? "";
    message.partitionTime = object.partitionTime ?? undefined;
    message.status = object.status ?? 0;
    message.changelists = object.changelists?.map((e) => Changelist.fromPartial(e)) || [];
    message.isSourcesDirty = object.isSourcesDirty ?? false;
    return message;
  },
};

/**
 * Provide methods to read test histories.
 *
 * Use of LUCI is subject to the Google [Terms of Service](https://policies.google.com/terms)
 * and [Privacy Policy](https://policies.google.com/privacy).
 */
export interface TestHistory {
  /**
   * Retrieves test verdicts for a given test ID in a given project and in a
   * given range of time.
   * Accepts a test variant predicate to filter the verdicts.
   */
  Query(request: QueryTestHistoryRequest): Promise<QueryTestHistoryResponse>;
  /**
   * Retrieves a summary of test verdicts for a given test ID in a given project
   * and in a given range of times.
   * Accepts a test variant predicate to filter the verdicts.
   */
  QueryStats(request: QueryTestHistoryStatsRequest): Promise<QueryTestHistoryStatsResponse>;
  /**
   * Retrieves variants for a given test ID in a given project that were
   * recorded in the past 90 days.
   */
  QueryVariants(request: QueryVariantsRequest): Promise<QueryVariantsResponse>;
  /**
   * Finds test IDs that contain the given substring in a given project that
   * were recorded in the past 90 days.
   */
  QueryTests(request: QueryTestsRequest): Promise<QueryTestsResponse>;
  /**
   * Queries for recent passing results of a specific test variant, contextually
   * close to a given failing result.
   * It utilizes LUCI Analysis's historical data
   * (chronological and source-position based) to efficiently find root
   * invocations containing passes suitable for log comparison.
   *
   * The response contains root invocation IDs that are typically passed to
   * ResultDB to perform log comparison.
   */
  QueryRecentPasses(request: QueryRecentPassesRequest): Promise<QueryRecentPassesResponse>;
  /** Queries source verdicts for a given test and source ref. */
  QuerySourceVerdicts(request: QuerySourceVerdictsV2Request): Promise<QuerySourceVerdictsV2Response>;
}

export const TestHistoryServiceName = "luci.analysis.v1.TestHistory";
export class TestHistoryClientImpl implements TestHistory {
  static readonly DEFAULT_SERVICE = TestHistoryServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TestHistoryServiceName;
    this.rpc = rpc;
    this.Query = this.Query.bind(this);
    this.QueryStats = this.QueryStats.bind(this);
    this.QueryVariants = this.QueryVariants.bind(this);
    this.QueryTests = this.QueryTests.bind(this);
    this.QueryRecentPasses = this.QueryRecentPasses.bind(this);
    this.QuerySourceVerdicts = this.QuerySourceVerdicts.bind(this);
  }
  Query(request: QueryTestHistoryRequest): Promise<QueryTestHistoryResponse> {
    const data = QueryTestHistoryRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "Query", data);
    return promise.then((data) => QueryTestHistoryResponse.fromJSON(data));
  }

  QueryStats(request: QueryTestHistoryStatsRequest): Promise<QueryTestHistoryStatsResponse> {
    const data = QueryTestHistoryStatsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryStats", data);
    return promise.then((data) => QueryTestHistoryStatsResponse.fromJSON(data));
  }

  QueryVariants(request: QueryVariantsRequest): Promise<QueryVariantsResponse> {
    const data = QueryVariantsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryVariants", data);
    return promise.then((data) => QueryVariantsResponse.fromJSON(data));
  }

  QueryTests(request: QueryTestsRequest): Promise<QueryTestsResponse> {
    const data = QueryTestsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryTests", data);
    return promise.then((data) => QueryTestsResponse.fromJSON(data));
  }

  QueryRecentPasses(request: QueryRecentPassesRequest): Promise<QueryRecentPassesResponse> {
    const data = QueryRecentPassesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "QueryRecentPasses", data);
    return promise.then((data) => QueryRecentPassesResponse.fromJSON(data));
  }

  QuerySourceVerdicts(request: QuerySourceVerdictsV2Request): Promise<QuerySourceVerdictsV2Response> {
    const data = QuerySourceVerdictsV2Request.toJSON(request);
    const promise = this.rpc.request(this.service, "QuerySourceVerdicts", data);
    return promise.then((data) => QuerySourceVerdictsV2Response.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
