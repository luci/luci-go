// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.0
// source: go.chromium.org/luci/analysis/proto/v1/sources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "luci.analysis.v1";

/** ChangelistOwner describes the owner of a gerrit changelist. */
export enum ChangelistOwnerKind {
  /** CHANGELIST_OWNER_UNSPECIFIED - The changelist owner is not known. */
  CHANGELIST_OWNER_UNSPECIFIED = 0,
  /** HUMAN - The changelist is owned by a human. */
  HUMAN = 1,
  /**
   * AUTOMATION - The changelist is owned by automation. (E.g. autoroller or
   * automatic uprev process.)
   */
  AUTOMATION = 2,
}

export function changelistOwnerKindFromJSON(object: any): ChangelistOwnerKind {
  switch (object) {
    case 0:
    case "CHANGELIST_OWNER_UNSPECIFIED":
      return ChangelistOwnerKind.CHANGELIST_OWNER_UNSPECIFIED;
    case 1:
    case "HUMAN":
      return ChangelistOwnerKind.HUMAN;
    case 2:
    case "AUTOMATION":
      return ChangelistOwnerKind.AUTOMATION;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ChangelistOwnerKind");
  }
}

export function changelistOwnerKindToJSON(object: ChangelistOwnerKind): string {
  switch (object) {
    case ChangelistOwnerKind.CHANGELIST_OWNER_UNSPECIFIED:
      return "CHANGELIST_OWNER_UNSPECIFIED";
    case ChangelistOwnerKind.HUMAN:
      return "HUMAN";
    case ChangelistOwnerKind.AUTOMATION:
      return "AUTOMATION";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ChangelistOwnerKind");
  }
}

/** Specifies the source code that was tested. */
export interface Sources {
  /** The base version of code sources checked out. */
  readonly gitilesCommit?:
    | GitilesCommit
    | undefined;
  /**
   * The submitted Android Build ID that describes the base code sources tested.
   *
   * In presubmit, where the invocation is testing a pending build (a build ID
   * starting with "P"), lookup its reference build (which will be a submitted
   * build) and specify it here. Then specify the cherry-picked changes under
   * `changelists`.
   */
  readonly submittedAndroidBuild?:
    | SubmittedAndroidBuild
    | undefined;
  /**
   * The changelist(s) which were applied upon the base version of sources
   * checked out. E.g. in commit queue tryjobs.
   *
   * At most 10 changelist(s) may be specified here. If there
   * are more, only include the first 10 and set is_dirty.
   */
  readonly changelists: readonly GerritChange[];
  /**
   * Whether there were any changes made to the sources, not described above.
   * For example, a version of a dependency was upgraded before testing (e.g.
   * in an autoroller recipe).
   *
   * Cherry-picking a changelist on top of the base checkout is not considered
   * making the sources dirty as it is reported separately above.
   */
  readonly isDirty: boolean;
}

/**
 * GitilesCommit specifies the position of the gitiles commit an invocation
 * ran against, in a repository's commit log. More specifically, a ref's commit
 * log.
 *
 * It also specifies the host/project/ref combination that the commit
 * exists in, to provide context.
 */
export interface GitilesCommit {
  /**
   * The identity of the gitiles host, e.g. "chromium.googlesource.com".
   * Mandatory.
   */
  readonly host: string;
  /** Repository name on the host, e.g. "chromium/src". Mandatory. */
  readonly project: string;
  /**
   * Commit ref, e.g. "refs/heads/main" from which the commit was fetched.
   * Not the branch name, use "refs/heads/branch"
   * Mandatory.
   */
  readonly ref: string;
  /** Commit SHA-1, as 40 lowercase hexadecimal characters. Mandatory. */
  readonly commitHash: string;
  /**
   * Defines a total order of commits on the ref.
   * A positive, monotonically increasing integer. The recommended
   * way of obtaining this is by using the goto.google.com/git-numberer
   * Gerrit plugin. Other solutions can be used as well, so long
   * as the same scheme is used consistently for a ref.
   * Mandatory.
   */
  readonly position: string;
}

/**
 * Specifies the build ID of a submitted Android build. A submitted build is a
 * build that uses only changes that have been submitted to a branch.
 */
export interface SubmittedAndroidBuild {
  /**
   * The Android Build API data realm.
   * This is usually `prod`.
   */
  readonly dataRealm: string;
  /**
   * The Android Build branch.
   * E.g. `git_main`.
   */
  readonly branch: string;
  /**
   * The build ID of the *submitted* build.
   *
   * This must be parsed to an integer, as this will be exported to BigQuery
   * and used for sorting results in source order.
   *
   * When comparing two build IDs on the same data realm and branch, we expect:
   * - A higher number means a newer version of sources were used in a build.
   * - An equal number means the same version of sources used in a build.
   * - A smaller number means an earlier version of sources were used in a build.
   */
  readonly buildId: string;
}

/** A Gerrit patchset. */
export interface GerritChange {
  /** Gerrit hostname, e.g. "chromium-review.googlesource.com". */
  readonly host: string;
  /** Gerrit project, e.g. "chromium/src". */
  readonly project: string;
  /** Change number, e.g. 12345. */
  readonly change: string;
  /** Patch set number, e.g. 1. */
  readonly patchset: string;
  /** The kind of owner of the changelist. Output only. */
  readonly ownerKind: ChangelistOwnerKind;
}

/** Represents a reference in a source control system. */
export interface SourceRef {
  /** A branch in gitiles repository. */
  readonly gitiles?:
    | GitilesRef
    | undefined;
  /** A branch in Android Build API. */
  readonly androidBuild?: AndroidBuildBranch | undefined;
}

/** Represents a branch in a gitiles repository. */
export interface GitilesRef {
  /** The gitiles host, e.g. "chromium.googlesource.com". */
  readonly host: string;
  /** The project on the gitiles host, e.g. "chromium/src". */
  readonly project: string;
  /**
   * Commit ref, e.g. "refs/heads/main" from which the commit was fetched.
   * Not the branch name, use "refs/heads/branch"
   */
  readonly ref: string;
}

/** Represents a branch in Android Build API. */
export interface AndroidBuildBranch {
  /**
   * The Android Build API data realm.
   * This is usually `prod`.
   */
  readonly dataRealm: string;
  /**
   * The Android Build branch.
   * E.g. `git_main`.
   */
  readonly branch: string;
}

/** A gerrit changelist. */
export interface Changelist {
  /** Gerrit hostname, e.g. "chromium-review.googlesource.com". */
  readonly host: string;
  /** Change number, e.g. 12345. */
  readonly change: string;
  /** Patch set number, e.g. 1. */
  readonly patchset: number;
  /** The kind of owner of the changelist. */
  readonly ownerKind: ChangelistOwnerKind;
}

function createBaseSources(): Sources {
  return { gitilesCommit: undefined, submittedAndroidBuild: undefined, changelists: [], isDirty: false };
}

export const Sources: MessageFns<Sources> = {
  encode(message: Sources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitilesCommit !== undefined) {
      GitilesCommit.encode(message.gitilesCommit, writer.uint32(10).fork()).join();
    }
    if (message.submittedAndroidBuild !== undefined) {
      SubmittedAndroidBuild.encode(message.submittedAndroidBuild, writer.uint32(34).fork()).join();
    }
    for (const v of message.changelists) {
      GerritChange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.isDirty !== false) {
      writer.uint32(24).bool(message.isDirty);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSources() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitilesCommit = GitilesCommit.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.submittedAndroidBuild = SubmittedAndroidBuild.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.changelists.push(GerritChange.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDirty = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sources {
    return {
      gitilesCommit: isSet(object.gitilesCommit) ? GitilesCommit.fromJSON(object.gitilesCommit) : undefined,
      submittedAndroidBuild: isSet(object.submittedAndroidBuild)
        ? SubmittedAndroidBuild.fromJSON(object.submittedAndroidBuild)
        : undefined,
      changelists: globalThis.Array.isArray(object?.changelists)
        ? object.changelists.map((e: any) => GerritChange.fromJSON(e))
        : [],
      isDirty: isSet(object.isDirty) ? globalThis.Boolean(object.isDirty) : false,
    };
  },

  toJSON(message: Sources): unknown {
    const obj: any = {};
    if (message.gitilesCommit !== undefined) {
      obj.gitilesCommit = GitilesCommit.toJSON(message.gitilesCommit);
    }
    if (message.submittedAndroidBuild !== undefined) {
      obj.submittedAndroidBuild = SubmittedAndroidBuild.toJSON(message.submittedAndroidBuild);
    }
    if (message.changelists?.length) {
      obj.changelists = message.changelists.map((e) => GerritChange.toJSON(e));
    }
    if (message.isDirty !== false) {
      obj.isDirty = message.isDirty;
    }
    return obj;
  },

  create(base?: DeepPartial<Sources>): Sources {
    return Sources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Sources>): Sources {
    const message = createBaseSources() as any;
    message.gitilesCommit = (object.gitilesCommit !== undefined && object.gitilesCommit !== null)
      ? GitilesCommit.fromPartial(object.gitilesCommit)
      : undefined;
    message.submittedAndroidBuild =
      (object.submittedAndroidBuild !== undefined && object.submittedAndroidBuild !== null)
        ? SubmittedAndroidBuild.fromPartial(object.submittedAndroidBuild)
        : undefined;
    message.changelists = object.changelists?.map((e) => GerritChange.fromPartial(e)) || [];
    message.isDirty = object.isDirty ?? false;
    return message;
  },
};

function createBaseGitilesCommit(): GitilesCommit {
  return { host: "", project: "", ref: "", commitHash: "", position: "0" };
}

export const GitilesCommit: MessageFns<GitilesCommit> = {
  encode(message: GitilesCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    if (message.commitHash !== "") {
      writer.uint32(34).string(message.commitHash);
    }
    if (message.position !== "0") {
      writer.uint32(40).int64(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitilesCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitilesCommit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.position = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitilesCommit {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "0",
    };
  },

  toJSON(message: GitilesCommit): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.commitHash !== "") {
      obj.commitHash = message.commitHash;
    }
    if (message.position !== "0") {
      obj.position = message.position;
    }
    return obj;
  },

  create(base?: DeepPartial<GitilesCommit>): GitilesCommit {
    return GitilesCommit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitilesCommit>): GitilesCommit {
    const message = createBaseGitilesCommit() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.ref = object.ref ?? "";
    message.commitHash = object.commitHash ?? "";
    message.position = object.position ?? "0";
    return message;
  },
};

function createBaseSubmittedAndroidBuild(): SubmittedAndroidBuild {
  return { dataRealm: "", branch: "", buildId: "0" };
}

export const SubmittedAndroidBuild: MessageFns<SubmittedAndroidBuild> = {
  encode(message: SubmittedAndroidBuild, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataRealm !== "") {
      writer.uint32(10).string(message.dataRealm);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.buildId !== "0") {
      writer.uint32(24).int64(message.buildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmittedAndroidBuild {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmittedAndroidBuild() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataRealm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buildId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmittedAndroidBuild {
    return {
      dataRealm: isSet(object.dataRealm) ? globalThis.String(object.dataRealm) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      buildId: isSet(object.buildId) ? globalThis.String(object.buildId) : "0",
    };
  },

  toJSON(message: SubmittedAndroidBuild): unknown {
    const obj: any = {};
    if (message.dataRealm !== "") {
      obj.dataRealm = message.dataRealm;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.buildId !== "0") {
      obj.buildId = message.buildId;
    }
    return obj;
  },

  create(base?: DeepPartial<SubmittedAndroidBuild>): SubmittedAndroidBuild {
    return SubmittedAndroidBuild.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmittedAndroidBuild>): SubmittedAndroidBuild {
    const message = createBaseSubmittedAndroidBuild() as any;
    message.dataRealm = object.dataRealm ?? "";
    message.branch = object.branch ?? "";
    message.buildId = object.buildId ?? "0";
    return message;
  },
};

function createBaseGerritChange(): GerritChange {
  return { host: "", project: "", change: "0", patchset: "0", ownerKind: 0 };
}

export const GerritChange: MessageFns<GerritChange> = {
  encode(message: GerritChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(42).string(message.project);
    }
    if (message.change !== "0") {
      writer.uint32(16).int64(message.change);
    }
    if (message.patchset !== "0") {
      writer.uint32(24).int64(message.patchset);
    }
    if (message.ownerKind !== 0) {
      writer.uint32(32).int32(message.ownerKind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GerritChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGerritChange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.change = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patchset = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ownerKind = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GerritChange {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      change: isSet(object.change) ? globalThis.String(object.change) : "0",
      patchset: isSet(object.patchset) ? globalThis.String(object.patchset) : "0",
      ownerKind: isSet(object.ownerKind) ? changelistOwnerKindFromJSON(object.ownerKind) : 0,
    };
  },

  toJSON(message: GerritChange): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.change !== "0") {
      obj.change = message.change;
    }
    if (message.patchset !== "0") {
      obj.patchset = message.patchset;
    }
    if (message.ownerKind !== 0) {
      obj.ownerKind = changelistOwnerKindToJSON(message.ownerKind);
    }
    return obj;
  },

  create(base?: DeepPartial<GerritChange>): GerritChange {
    return GerritChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GerritChange>): GerritChange {
    const message = createBaseGerritChange() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.change = object.change ?? "0";
    message.patchset = object.patchset ?? "0";
    message.ownerKind = object.ownerKind ?? 0;
    return message;
  },
};

function createBaseSourceRef(): SourceRef {
  return { gitiles: undefined, androidBuild: undefined };
}

export const SourceRef: MessageFns<SourceRef> = {
  encode(message: SourceRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitiles !== undefined) {
      GitilesRef.encode(message.gitiles, writer.uint32(10).fork()).join();
    }
    if (message.androidBuild !== undefined) {
      AndroidBuildBranch.encode(message.androidBuild, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitiles = GitilesRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.androidBuild = AndroidBuildBranch.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceRef {
    return {
      gitiles: isSet(object.gitiles) ? GitilesRef.fromJSON(object.gitiles) : undefined,
      androidBuild: isSet(object.androidBuild) ? AndroidBuildBranch.fromJSON(object.androidBuild) : undefined,
    };
  },

  toJSON(message: SourceRef): unknown {
    const obj: any = {};
    if (message.gitiles !== undefined) {
      obj.gitiles = GitilesRef.toJSON(message.gitiles);
    }
    if (message.androidBuild !== undefined) {
      obj.androidBuild = AndroidBuildBranch.toJSON(message.androidBuild);
    }
    return obj;
  },

  create(base?: DeepPartial<SourceRef>): SourceRef {
    return SourceRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceRef>): SourceRef {
    const message = createBaseSourceRef() as any;
    message.gitiles = (object.gitiles !== undefined && object.gitiles !== null)
      ? GitilesRef.fromPartial(object.gitiles)
      : undefined;
    message.androidBuild = (object.androidBuild !== undefined && object.androidBuild !== null)
      ? AndroidBuildBranch.fromPartial(object.androidBuild)
      : undefined;
    return message;
  },
};

function createBaseGitilesRef(): GitilesRef {
  return { host: "", project: "", ref: "" };
}

export const GitilesRef: MessageFns<GitilesRef> = {
  encode(message: GitilesRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitilesRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitilesRef() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitilesRef {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: GitilesRef): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<GitilesRef>): GitilesRef {
    return GitilesRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitilesRef>): GitilesRef {
    const message = createBaseGitilesRef() as any;
    message.host = object.host ?? "";
    message.project = object.project ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

function createBaseAndroidBuildBranch(): AndroidBuildBranch {
  return { dataRealm: "", branch: "" };
}

export const AndroidBuildBranch: MessageFns<AndroidBuildBranch> = {
  encode(message: AndroidBuildBranch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataRealm !== "") {
      writer.uint32(10).string(message.dataRealm);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidBuildBranch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidBuildBranch() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataRealm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidBuildBranch {
    return {
      dataRealm: isSet(object.dataRealm) ? globalThis.String(object.dataRealm) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
    };
  },

  toJSON(message: AndroidBuildBranch): unknown {
    const obj: any = {};
    if (message.dataRealm !== "") {
      obj.dataRealm = message.dataRealm;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    return obj;
  },

  create(base?: DeepPartial<AndroidBuildBranch>): AndroidBuildBranch {
    return AndroidBuildBranch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AndroidBuildBranch>): AndroidBuildBranch {
    const message = createBaseAndroidBuildBranch() as any;
    message.dataRealm = object.dataRealm ?? "";
    message.branch = object.branch ?? "";
    return message;
  },
};

function createBaseChangelist(): Changelist {
  return { host: "", change: "0", patchset: 0, ownerKind: 0 };
}

export const Changelist: MessageFns<Changelist> = {
  encode(message: Changelist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.change !== "0") {
      writer.uint32(16).int64(message.change);
    }
    if (message.patchset !== 0) {
      writer.uint32(24).int32(message.patchset);
    }
    if (message.ownerKind !== 0) {
      writer.uint32(32).int32(message.ownerKind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Changelist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangelist() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.change = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patchset = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ownerKind = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Changelist {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      change: isSet(object.change) ? globalThis.String(object.change) : "0",
      patchset: isSet(object.patchset) ? globalThis.Number(object.patchset) : 0,
      ownerKind: isSet(object.ownerKind) ? changelistOwnerKindFromJSON(object.ownerKind) : 0,
    };
  },

  toJSON(message: Changelist): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.change !== "0") {
      obj.change = message.change;
    }
    if (message.patchset !== 0) {
      obj.patchset = Math.round(message.patchset);
    }
    if (message.ownerKind !== 0) {
      obj.ownerKind = changelistOwnerKindToJSON(message.ownerKind);
    }
    return obj;
  },

  create(base?: DeepPartial<Changelist>): Changelist {
    return Changelist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Changelist>): Changelist {
    const message = createBaseChangelist() as any;
    message.host = object.host ?? "";
    message.change = object.change ?? "0";
    message.patchset = object.patchset ?? 0;
    message.ownerKind = object.ownerKind ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
