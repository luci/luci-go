// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.32.0
// source: go.chromium.org/luci/analysis/proto/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../../google/protobuf/timestamp.pb";

export const protobufPackage = "luci.analysis.v1";

/**
 * BuildStatus the result of the build in which the test verdict was produced.
 * This can be used to detect if the test verdict is incomplete (e.g. because
 * an infra failure or cancellation occurred), and whether the unexpected
 * test verdict was also followed by a failing build.
 *
 * Note: All values prefixed with BUILD_STATUS_ as the names are generic
 * and likely to conflict with other/future enumerations otherwise.
 * See https://google.aip.dev/126.
 */
export enum BuildStatus {
  /** BUILD_STATUS_UNSPECIFIED - A build must not have this status. */
  BUILD_STATUS_UNSPECIFIED = 0,
  /** BUILD_STATUS_SUCCESS - The build succeeded. */
  BUILD_STATUS_SUCCESS = 1,
  /** BUILD_STATUS_FAILURE - The build failed. */
  BUILD_STATUS_FAILURE = 2,
  /** BUILD_STATUS_INFRA_FAILURE - The build encountered an infrastructure failure. */
  BUILD_STATUS_INFRA_FAILURE = 3,
  /** BUILD_STATUS_CANCELED - The build was canceled. */
  BUILD_STATUS_CANCELED = 4,
}

export function buildStatusFromJSON(object: any): BuildStatus {
  switch (object) {
    case 0:
    case "BUILD_STATUS_UNSPECIFIED":
      return BuildStatus.BUILD_STATUS_UNSPECIFIED;
    case 1:
    case "BUILD_STATUS_SUCCESS":
      return BuildStatus.BUILD_STATUS_SUCCESS;
    case 2:
    case "BUILD_STATUS_FAILURE":
      return BuildStatus.BUILD_STATUS_FAILURE;
    case 3:
    case "BUILD_STATUS_INFRA_FAILURE":
      return BuildStatus.BUILD_STATUS_INFRA_FAILURE;
    case 4:
    case "BUILD_STATUS_CANCELED":
      return BuildStatus.BUILD_STATUS_CANCELED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BuildStatus");
  }
}

export function buildStatusToJSON(object: BuildStatus): string {
  switch (object) {
    case BuildStatus.BUILD_STATUS_UNSPECIFIED:
      return "BUILD_STATUS_UNSPECIFIED";
    case BuildStatus.BUILD_STATUS_SUCCESS:
      return "BUILD_STATUS_SUCCESS";
    case BuildStatus.BUILD_STATUS_FAILURE:
      return "BUILD_STATUS_FAILURE";
    case BuildStatus.BUILD_STATUS_INFRA_FAILURE:
      return "BUILD_STATUS_INFRA_FAILURE";
    case BuildStatus.BUILD_STATUS_CANCELED:
      return "BUILD_STATUS_CANCELED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BuildStatus");
  }
}

/**
 * ExonerationReason captures a reason why a test failure was
 * exonerated. Exonerated means the failure was ignored and did not
 * have further impact, in terms of causing the build to fail or
 * rejecting the CL being tested in a presubmit run.
 *
 * Based on https://source.chromium.org/chromium/infra/infra/+/main:go/src/go.chromium.org/luci/resultdb/proto/v1/test_result.proto?q=ExonerationReason&type=cs.
 */
export enum ExonerationReason {
  /** EXONERATION_REASON_UNSPECIFIED - A test failure must not have this status. */
  EXONERATION_REASON_UNSPECIFIED = 0,
  /**
   * OCCURS_ON_MAINLINE - Similar unexpected results were observed on a mainline branch
   * (i.e. against a build without unsubmitted changes applied).
   * (For avoidance of doubt, this includes both flakily and
   * deterministically occurring unexpected results.)
   * Applies to unexpected results in presubmit/CQ runs only.
   */
  OCCURS_ON_MAINLINE = 1,
  /**
   * OCCURS_ON_OTHER_CLS - Similar unexpected results were observed in presubmit run(s) for other,
   * unrelated CL(s). (This is suggestive of the issue being present
   * on mainline but is not confirmed as there are possible confounding
   * factors, like how tests are run on CLs vs how tests are run on
   * mainline branches.)
   * Applies to unexpected results in presubmit/CQ runs only.
   */
  OCCURS_ON_OTHER_CLS = 2,
  /**
   * NOT_CRITICAL - The tests are not critical to the test subject (e.g. CL) passing.
   * This could be because more data is being collected to determine if
   * the tests are stable enough to be made critical (as is often the
   * case for experimental test suites).
   */
  NOT_CRITICAL = 3,
  /**
   * UNEXPECTED_PASS - The test result was an unexpected pass. (Note that such an exoneration is
   * not automatically created for unexpected passes, unless the option is
   * specified to ResultSink or the project manually creates one).
   */
  UNEXPECTED_PASS = 4,
}

export function exonerationReasonFromJSON(object: any): ExonerationReason {
  switch (object) {
    case 0:
    case "EXONERATION_REASON_UNSPECIFIED":
      return ExonerationReason.EXONERATION_REASON_UNSPECIFIED;
    case 1:
    case "OCCURS_ON_MAINLINE":
      return ExonerationReason.OCCURS_ON_MAINLINE;
    case 2:
    case "OCCURS_ON_OTHER_CLS":
      return ExonerationReason.OCCURS_ON_OTHER_CLS;
    case 3:
    case "NOT_CRITICAL":
      return ExonerationReason.NOT_CRITICAL;
    case 4:
    case "UNEXPECTED_PASS":
      return ExonerationReason.UNEXPECTED_PASS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ExonerationReason");
  }
}

export function exonerationReasonToJSON(object: ExonerationReason): string {
  switch (object) {
    case ExonerationReason.EXONERATION_REASON_UNSPECIFIED:
      return "EXONERATION_REASON_UNSPECIFIED";
    case ExonerationReason.OCCURS_ON_MAINLINE:
      return "OCCURS_ON_MAINLINE";
    case ExonerationReason.OCCURS_ON_OTHER_CLS:
      return "OCCURS_ON_OTHER_CLS";
    case ExonerationReason.NOT_CRITICAL:
      return "NOT_CRITICAL";
    case ExonerationReason.UNEXPECTED_PASS:
      return "UNEXPECTED_PASS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ExonerationReason");
  }
}

/**
 * SubmittedFilter filters test verdicts based on whether they had unsubmitted
 * changes.
 */
export enum SubmittedFilter {
  /** SUBMITTED_FILTER_UNSPECIFIED - Default value. Include all test verdicts. */
  SUBMITTED_FILTER_UNSPECIFIED = 0,
  /** ONLY_SUBMITTED - Only include test verdicts that don't have unsubmitted changes. */
  ONLY_SUBMITTED = 1,
  /** ONLY_UNSUBMITTED - Only include test verdicts that have unsubmitted changes. */
  ONLY_UNSUBMITTED = 2,
}

export function submittedFilterFromJSON(object: any): SubmittedFilter {
  switch (object) {
    case 0:
    case "SUBMITTED_FILTER_UNSPECIFIED":
      return SubmittedFilter.SUBMITTED_FILTER_UNSPECIFIED;
    case 1:
    case "ONLY_SUBMITTED":
      return SubmittedFilter.ONLY_SUBMITTED;
    case 2:
    case "ONLY_UNSUBMITTED":
      return SubmittedFilter.ONLY_UNSUBMITTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubmittedFilter");
  }
}

export function submittedFilterToJSON(object: SubmittedFilter): string {
  switch (object) {
    case SubmittedFilter.SUBMITTED_FILTER_UNSPECIFIED:
      return "SUBMITTED_FILTER_UNSPECIFIED";
    case SubmittedFilter.ONLY_SUBMITTED:
      return "ONLY_SUBMITTED";
    case SubmittedFilter.ONLY_UNSUBMITTED:
      return "ONLY_UNSUBMITTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubmittedFilter");
  }
}

/**
 * PresubmitRunMode describes the mode of a presubmit run. Currently
 * based on LUCI CV run mode enumeration at
 * https://source.chromium.org/chromium/infra/infra/+/main:go/src/go.chromium.org/luci/cv/api/bigquery/v1/attempt.proto?q=QUICK_DRY_RUN&type=cs.
 */
export enum PresubmitRunMode {
  /** PRESUBMIT_RUN_MODE_UNSPECIFIED - A presubmit run must not have this status. */
  PRESUBMIT_RUN_MODE_UNSPECIFIED = 0,
  /** DRY_RUN - Run all tests but do not submit. */
  DRY_RUN = 1,
  /** FULL_RUN - Run all tests and potentially submit. */
  FULL_RUN = 2,
  /** QUICK_DRY_RUN - Run some tests but do not submit. */
  QUICK_DRY_RUN = 3,
  /** NEW_PATCHSET_RUN - Runs some tests on patchset upload but do not submit. */
  NEW_PATCHSET_RUN = 4,
}

export function presubmitRunModeFromJSON(object: any): PresubmitRunMode {
  switch (object) {
    case 0:
    case "PRESUBMIT_RUN_MODE_UNSPECIFIED":
      return PresubmitRunMode.PRESUBMIT_RUN_MODE_UNSPECIFIED;
    case 1:
    case "DRY_RUN":
      return PresubmitRunMode.DRY_RUN;
    case 2:
    case "FULL_RUN":
      return PresubmitRunMode.FULL_RUN;
    case 3:
    case "QUICK_DRY_RUN":
      return PresubmitRunMode.QUICK_DRY_RUN;
    case 4:
    case "NEW_PATCHSET_RUN":
      return PresubmitRunMode.NEW_PATCHSET_RUN;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PresubmitRunMode");
  }
}

export function presubmitRunModeToJSON(object: PresubmitRunMode): string {
  switch (object) {
    case PresubmitRunMode.PRESUBMIT_RUN_MODE_UNSPECIFIED:
      return "PRESUBMIT_RUN_MODE_UNSPECIFIED";
    case PresubmitRunMode.DRY_RUN:
      return "DRY_RUN";
    case PresubmitRunMode.FULL_RUN:
      return "FULL_RUN";
    case PresubmitRunMode.QUICK_DRY_RUN:
      return "QUICK_DRY_RUN";
    case PresubmitRunMode.NEW_PATCHSET_RUN:
      return "NEW_PATCHSET_RUN";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PresubmitRunMode");
  }
}

/**
 * PresubmitRunStatus is the ending status of a presubmit run.
 *
 * Note: All values prefixed with PRESUBMIT_RUN_STATUS_ as the names are
 * generic and likely to conflict with other/future enumerations otherwise.
 * See https://google.aip.dev/126.
 *
 * Based on https://source.chromium.org/chromium/infra/infra/+/main:go/src/go.chromium.org/luci/cv/internal/run/storage.proto;l=28?q=LUCI%20CV%20status%20lang:proto.
 */
export enum PresubmitRunStatus {
  /** PRESUBMIT_RUN_STATUS_UNSPECIFIED - A build must not have this status. */
  PRESUBMIT_RUN_STATUS_UNSPECIFIED = 0,
  /** PRESUBMIT_RUN_STATUS_SUCCEEDED - The run succeeded. */
  PRESUBMIT_RUN_STATUS_SUCCEEDED = 1,
  /** PRESUBMIT_RUN_STATUS_FAILED - The run failed. */
  PRESUBMIT_RUN_STATUS_FAILED = 2,
  /** PRESUBMIT_RUN_STATUS_CANCELED - The run was canceled. */
  PRESUBMIT_RUN_STATUS_CANCELED = 3,
}

export function presubmitRunStatusFromJSON(object: any): PresubmitRunStatus {
  switch (object) {
    case 0:
    case "PRESUBMIT_RUN_STATUS_UNSPECIFIED":
      return PresubmitRunStatus.PRESUBMIT_RUN_STATUS_UNSPECIFIED;
    case 1:
    case "PRESUBMIT_RUN_STATUS_SUCCEEDED":
      return PresubmitRunStatus.PRESUBMIT_RUN_STATUS_SUCCEEDED;
    case 2:
    case "PRESUBMIT_RUN_STATUS_FAILED":
      return PresubmitRunStatus.PRESUBMIT_RUN_STATUS_FAILED;
    case 3:
    case "PRESUBMIT_RUN_STATUS_CANCELED":
      return PresubmitRunStatus.PRESUBMIT_RUN_STATUS_CANCELED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PresubmitRunStatus");
  }
}

export function presubmitRunStatusToJSON(object: PresubmitRunStatus): string {
  switch (object) {
    case PresubmitRunStatus.PRESUBMIT_RUN_STATUS_UNSPECIFIED:
      return "PRESUBMIT_RUN_STATUS_UNSPECIFIED";
    case PresubmitRunStatus.PRESUBMIT_RUN_STATUS_SUCCEEDED:
      return "PRESUBMIT_RUN_STATUS_SUCCEEDED";
    case PresubmitRunStatus.PRESUBMIT_RUN_STATUS_FAILED:
      return "PRESUBMIT_RUN_STATUS_FAILED";
    case PresubmitRunStatus.PRESUBMIT_RUN_STATUS_CANCELED:
      return "PRESUBMIT_RUN_STATUS_CANCELED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PresubmitRunStatus");
  }
}

/** A range of timestamps. */
export interface TimeRange {
  /** The oldest timestamp to include in the range. */
  readonly earliest:
    | string
    | undefined;
  /** Include only timestamps that are strictly older than this. */
  readonly latest: string | undefined;
}

/** Identity of a test result. */
export interface TestResultId {
  /**
   * The test results system.
   * Currently, the only valid value is "resultdb".
   */
  readonly system: string;
  /**
   * ID for the test result in the test results system.
   * For test results in ResultDB, the format is:
   * "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}"
   * Where INVOCATION_ID, URL_ESCAPED_TEST_ID and RESULT_ID are values defined
   * in ResultDB.
   */
  readonly id: string;
}

/**
 * Variant represents a way of running a test case.
 *
 * The same test case can be executed in different ways, for example on
 * different OS, GPUs, with different compile options or runtime flags.
 */
export interface Variant {
  /**
   * The definition of the variant. Each key-value pair represents a
   * parameter describing how the test was run (e.g. OS, GPU, etc.).
   */
  readonly def: { [key: string]: string };
}

export interface Variant_DefEntry {
  readonly key: string;
  readonly value: string;
}

export interface StringPair {
  /**
   * Regex: ^[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*$
   * Max length: 64.
   */
  readonly key: string;
  /** Max length: 256. */
  readonly value: string;
}

/** Identity of a bug tracking component in a bug tracking system. */
export interface BugTrackingComponent {
  /**
   * The bug tracking system corresponding to this test case, as identified
   * by the test results system.
   * Currently, the valid values are "monorail" or "buganizer".
   */
  readonly system: string;
  /**
   * The bug tracking component corresponding to this test case, as identified
   * by the test results system.
   * If the bug tracking system is monorail, this is the component as the
   * user would see it, e.g. "Infra>Test>Flakiness". For monorail, the bug
   * tracking project (e.g. "chromium") is not encoded, but assumed to be
   * specified in the project's LUCI Analysis configuration.
   */
  readonly component: string;
}

/** Identity of a presubmit run (also known as a "CQ Run" or "CV Run"). */
export interface PresubmitRunId {
  /**
   * The system that was used to process the presubmit run.
   * Currently, the only valid value is "luci-cv" for LUCI Commit Verifier
   * (LUCI CV).
   */
  readonly system: string;
  /**
   * Identity of the presubmit run.
   * If the presubmit system is LUCI CV, the format of this value is:
   *   "{LUCI_PROJECT}/{LUCI_CV_ID}", e.g.
   *   "infra/8988819463854-1-f94732fe20056fd1".
   */
  readonly id: string;
}

/** Identity of a bug in a bug-tracking system. */
export interface AssociatedBug {
  /**
   * System is the bug tracking system of the bug. This is either
   * "monorail" or "buganizer".
   */
  readonly system: string;
  /**
   * Id is the bug tracking system-specific identity of the bug.
   * For monorail, the scheme is {project}/{numeric_id}, for
   * buganizer the scheme is {numeric_id}.
   */
  readonly id: string;
  /**
   * A human-readable name for the bug. This is typically the
   * bug shortlink (e.g. "crbug.com/1234567").
   */
  readonly linkText: string;
  /**
   * The resolved bug URL, e.g.
   * E.g. "https://bugs.chromium.org/p/chromium/issues/detail?id=123456".
   */
  readonly url: string;
}

/**
 * ClusterId represents the identity of a cluster. The LUCI Project is
 * omitted as it is assumed to be implicit from the context.
 *
 * This is often used in place of the resource name of the cluster
 * (in the sense of https://google.aip.dev/122) as clients may need
 * to access individual parts of the resource name (e.g. to determine
 * the algorithm used) and it is not desirable to make clients parse
 * the resource name.
 */
export interface ClusterId {
  /**
   * Algorithm is the name of the clustering algorithm that identified
   * the cluster.
   */
  readonly algorithm: string;
  /**
   * Id is the cluster identifier returned by the algorithm. The underlying
   * identifier is at most 16 bytes, but is represented here as a hexadecimal
   * string of up to 32 lowercase hexadecimal characters.
   */
  readonly id: string;
}

/** Represents a range of numeric values, e.g. unexpected verdict rates. */
export interface NumericRange {
  /** The inclusive lower bound included in the range. */
  readonly lowerBound: number;
  /** The inclusive upper bound included in the range. */
  readonly upperBound: number;
}

/**
 * Message used to namespace test status ennum values, to avoid
 * naming conflicts with verdicts.
 */
export interface TestResult {
}

/**
 * Status of a test result (v2).
 * It is a mirror of luci.resultdb.v1.TestResult_Status, to avoid LUCI
 * Analysis RPC protos being coupled to RDB protos.
 */
export enum TestResult_Status {
  /** STATUS_UNSPECIFIED - Status was not specified. Do not use. */
  STATUS_UNSPECIFIED = 0,
  /** PASSED - The test case has passed. */
  PASSED = 1,
  /**
   * FAILED - The test case has failed.
   * Suggests that the code under test is incorrect, but it is also possible
   * that the test is incorrect or it is a flake.
   *
   * If a test failed to complete due to an error that is not the fault of
   * this test's content, use the status EXECUTION_ERRORED (for errors specific
   * to this test) or PRECLUDED (for errors at a higher-level) instead.
   *
   * If you specify this status, you must also populate the failure_reason.kind field.
   */
  FAILED = 2,
  /**
   * SKIPPED - The test case did not, *and should not*, run to completion in this
   * configuration.
   *
   * For example:
   * - The test is disabled in code
   * - The test assumptions are not met (e.g. JUnit assumption failure
   *   or Tast test hardware dependency unmet)
   * - The test was not stable enough to in presubmit right now.
   *
   * If a test was not run or not run to completion due to an error, use the
   * status EXECUTION_ERRORED (for test-level errors) or PRECLUDED
   * (for higher-level errors) instead.
   *
   * If you specify this status, you must also populate the skipped_reason field.
   */
  SKIPPED = 3,
  /**
   * EXECUTION_ERRORED - The test did not run to completion, because an infrastructure error
   * precluded it from doing so.
   *
   * Infrastructure here is broadly defined, to mean "not the content
   * of this test".
   *
   * For example:
   * - The test ran, but the result file could not be parsed.
   * - A file this test depends on could not be downloaded.
   *
   * Sometimes it is ambiguous whether test content is at fault or not.
   * For example, loss of SSH connection during the test could be because
   * the test caused a kernel panic or because of a flaky ethernet adapter.
   * Judgement is required. If unsure, use EXECUTION_ERRORED status instead
   * of FAIL to avoid falsely inflating the flakiness rate of a test.
   *
   * Results with this status should be ignored when calculating the flake
   * and failure rates of the test.
   *
   * Currently, there is no dedicated 'reason' field for this status;
   * please just include a suitable description in the result `summary_html`.
   */
  EXECUTION_ERRORED = 4,
  /**
   * PRECLUDED - The test did not run to completion, because its execution is precluded
   * by an error at a higher-level. For example, a work unit-level timeout.
   *
   * If you report this status, you must report an error on the containing
   * work unit. If this restriction is changed in future to allow preclusion
   * by other sources (e.g. a class fixture failed to setup so the tests in
   * using it could not run), a preclusion reason field will be added to
   * capture this.
   *
   * Results with this status should be ignored when calculating the flake
   * and failure rates of the test.
   *
   * Currently, there is no dedicated 'reason' field for this status; please
   * include a suitable description in the result `summary_html`.
   */
  PRECLUDED = 5,
}

export function testResult_StatusFromJSON(object: any): TestResult_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return TestResult_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PASSED":
      return TestResult_Status.PASSED;
    case 2:
    case "FAILED":
      return TestResult_Status.FAILED;
    case 3:
    case "SKIPPED":
      return TestResult_Status.SKIPPED;
    case 4:
    case "EXECUTION_ERRORED":
      return TestResult_Status.EXECUTION_ERRORED;
    case 5:
    case "PRECLUDED":
      return TestResult_Status.PRECLUDED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TestResult_Status");
  }
}

export function testResult_StatusToJSON(object: TestResult_Status): string {
  switch (object) {
    case TestResult_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case TestResult_Status.PASSED:
      return "PASSED";
    case TestResult_Status.FAILED:
      return "FAILED";
    case TestResult_Status.SKIPPED:
      return "SKIPPED";
    case TestResult_Status.EXECUTION_ERRORED:
      return "EXECUTION_ERRORED";
    case TestResult_Status.PRECLUDED:
      return "PRECLUDED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TestResult_Status");
  }
}

function createBaseTimeRange(): TimeRange {
  return { earliest: undefined, latest: undefined };
}

export const TimeRange: MessageFns<TimeRange> = {
  encode(message: TimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.earliest !== undefined) {
      Timestamp.encode(toTimestamp(message.earliest), writer.uint32(10).fork()).join();
    }
    if (message.latest !== undefined) {
      Timestamp.encode(toTimestamp(message.latest), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.earliest = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.latest = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRange {
    return {
      earliest: isSet(object.earliest) ? globalThis.String(object.earliest) : undefined,
      latest: isSet(object.latest) ? globalThis.String(object.latest) : undefined,
    };
  },

  toJSON(message: TimeRange): unknown {
    const obj: any = {};
    if (message.earliest !== undefined) {
      obj.earliest = message.earliest;
    }
    if (message.latest !== undefined) {
      obj.latest = message.latest;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeRange>): TimeRange {
    return TimeRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeRange>): TimeRange {
    const message = createBaseTimeRange() as any;
    message.earliest = object.earliest ?? undefined;
    message.latest = object.latest ?? undefined;
    return message;
  },
};

function createBaseTestResultId(): TestResultId {
  return { system: "", id: "" };
}

export const TestResultId: MessageFns<TestResultId> = {
  encode(message: TestResultId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system !== "") {
      writer.uint32(10).string(message.system);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResultId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResultId() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResultId {
    return {
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: TestResultId): unknown {
    const obj: any = {};
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<TestResultId>): TestResultId {
    return TestResultId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestResultId>): TestResultId {
    const message = createBaseTestResultId() as any;
    message.system = object.system ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseVariant(): Variant {
  return { def: {} };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.def).forEach(([key, value]) => {
      Variant_DefEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Variant_DefEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.def[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant {
    return {
      def: isObject(object.def)
        ? Object.entries(object.def).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Variant): unknown {
    const obj: any = {};
    if (message.def) {
      const entries = Object.entries(message.def);
      if (entries.length > 0) {
        obj.def = {};
        entries.forEach(([k, v]) => {
          obj.def[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Variant>): Variant {
    return Variant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant>): Variant {
    const message = createBaseVariant() as any;
    message.def = Object.entries(object.def ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseVariant_DefEntry(): Variant_DefEntry {
  return { key: "", value: "" };
}

export const Variant_DefEntry: MessageFns<Variant_DefEntry> = {
  encode(message: Variant_DefEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant_DefEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant_DefEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant_DefEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Variant_DefEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Variant_DefEntry>): Variant_DefEntry {
    return Variant_DefEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variant_DefEntry>): Variant_DefEntry {
    const message = createBaseVariant_DefEntry() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStringPair(): StringPair {
  return { key: "", value: "" };
}

export const StringPair: MessageFns<StringPair> = {
  encode(message: StringPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringPair() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringPair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StringPair): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StringPair>): StringPair {
    return StringPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringPair>): StringPair {
    const message = createBaseStringPair() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBugTrackingComponent(): BugTrackingComponent {
  return { system: "", component: "" };
}

export const BugTrackingComponent: MessageFns<BugTrackingComponent> = {
  encode(message: BugTrackingComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system !== "") {
      writer.uint32(10).string(message.system);
    }
    if (message.component !== "") {
      writer.uint32(18).string(message.component);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BugTrackingComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBugTrackingComponent() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.component = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BugTrackingComponent {
    return {
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      component: isSet(object.component) ? globalThis.String(object.component) : "",
    };
  },

  toJSON(message: BugTrackingComponent): unknown {
    const obj: any = {};
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.component !== "") {
      obj.component = message.component;
    }
    return obj;
  },

  create(base?: DeepPartial<BugTrackingComponent>): BugTrackingComponent {
    return BugTrackingComponent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BugTrackingComponent>): BugTrackingComponent {
    const message = createBaseBugTrackingComponent() as any;
    message.system = object.system ?? "";
    message.component = object.component ?? "";
    return message;
  },
};

function createBasePresubmitRunId(): PresubmitRunId {
  return { system: "", id: "" };
}

export const PresubmitRunId: MessageFns<PresubmitRunId> = {
  encode(message: PresubmitRunId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system !== "") {
      writer.uint32(10).string(message.system);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PresubmitRunId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePresubmitRunId() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PresubmitRunId {
    return {
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: PresubmitRunId): unknown {
    const obj: any = {};
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<PresubmitRunId>): PresubmitRunId {
    return PresubmitRunId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PresubmitRunId>): PresubmitRunId {
    const message = createBasePresubmitRunId() as any;
    message.system = object.system ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAssociatedBug(): AssociatedBug {
  return { system: "", id: "", linkText: "", url: "" };
}

export const AssociatedBug: MessageFns<AssociatedBug> = {
  encode(message: AssociatedBug, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.system !== "") {
      writer.uint32(10).string(message.system);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.linkText !== "") {
      writer.uint32(26).string(message.linkText);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssociatedBug {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssociatedBug() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.system = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkText = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssociatedBug {
    return {
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      linkText: isSet(object.linkText) ? globalThis.String(object.linkText) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: AssociatedBug): unknown {
    const obj: any = {};
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.linkText !== "") {
      obj.linkText = message.linkText;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<AssociatedBug>): AssociatedBug {
    return AssociatedBug.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssociatedBug>): AssociatedBug {
    const message = createBaseAssociatedBug() as any;
    message.system = object.system ?? "";
    message.id = object.id ?? "";
    message.linkText = object.linkText ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseClusterId(): ClusterId {
  return { algorithm: "", id: "" };
}

export const ClusterId: MessageFns<ClusterId> = {
  encode(message: ClusterId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== "") {
      writer.uint32(10).string(message.algorithm);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterId() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterId {
    return {
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ClusterId): unknown {
    const obj: any = {};
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterId>): ClusterId {
    return ClusterId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterId>): ClusterId {
    const message = createBaseClusterId() as any;
    message.algorithm = object.algorithm ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNumericRange(): NumericRange {
  return { lowerBound: 0, upperBound: 0 };
}

export const NumericRange: MessageFns<NumericRange> = {
  encode(message: NumericRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerBound !== 0) {
      writer.uint32(13).float(message.lowerBound);
    }
    if (message.upperBound !== 0) {
      writer.uint32(21).float(message.upperBound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumericRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumericRange() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.lowerBound = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.upperBound = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumericRange {
    return {
      lowerBound: isSet(object.lowerBound) ? globalThis.Number(object.lowerBound) : 0,
      upperBound: isSet(object.upperBound) ? globalThis.Number(object.upperBound) : 0,
    };
  },

  toJSON(message: NumericRange): unknown {
    const obj: any = {};
    if (message.lowerBound !== 0) {
      obj.lowerBound = message.lowerBound;
    }
    if (message.upperBound !== 0) {
      obj.upperBound = message.upperBound;
    }
    return obj;
  },

  create(base?: DeepPartial<NumericRange>): NumericRange {
    return NumericRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumericRange>): NumericRange {
    const message = createBaseNumericRange() as any;
    message.lowerBound = object.lowerBound ?? 0;
    message.upperBound = object.upperBound ?? 0;
    return message;
  },
};

function createBaseTestResult(): TestResult {
  return {};
}

export const TestResult: MessageFns<TestResult> = {
  encode(_: TestResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TestResult {
    return {};
  },

  toJSON(_: TestResult): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TestResult>): TestResult {
    return TestResult.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TestResult>): TestResult {
    const message = createBaseTestResult() as any;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
