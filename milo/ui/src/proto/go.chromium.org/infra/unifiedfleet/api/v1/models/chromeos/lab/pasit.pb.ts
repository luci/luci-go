// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.31.1
// source: go.chromium.org/infra/unifiedfleet/api/v1/models/chromeos/lab/pasit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { OSRPM } from "./rpm.pb";

export const protobufPackage = "unifiedfleet.api.v1.models.chromeos.lab";

/**
 * PASIT is a connected set of peripheral components used in interop testing.
 * The components connected are controlled via an external host. Pasit
 * describes the devices in the testbed and their connection topology.
 */
export interface Pasit {
  /** The name of the host that controls the devices (e.g. switches) */
  readonly hostname: string;
  /**
   * The components/devices in the PASIT testbed (e.g. docks, switches, cameras,
   * monitors, etc)
   */
  readonly devices: readonly Pasit_Device[];
  /** The connections between devices/components in the testbed. */
  readonly connections: readonly Pasit_Connection[];
}

/** A single connection between two components in the topology. */
export interface Pasit_Connection {
  /**
   * If the parent device has multiple connection ports/slots,
   * this is the name or id of the port.
   */
  readonly parentPort: string;
  /** The ID of the parent component; */
  readonly parentId: string;
  /** The ID of the child component; */
  readonly childId: string;
  /** The speed of the connection. */
  readonly speed: number;
  /** The physical port type/technology, e.g. "USBA", "USBC", "HDMI". */
  readonly type: string;
  /** Tags associated with the connection, e.g. "DOCK", "DOCKLESS", "DAISY_CHAIN" see go/pasit-multi-topology. */
  readonly tags: readonly string[];
}

/** A single device/component in the testbed. */
export interface Pasit_Device {
  /**
   * The unique ID of the device. This is not unique across all devices,
   * in the lab but is unique within a testbed.
   */
  readonly id: string;
  /** The the make/model of the device. */
  readonly model: string;
  /** The type of device represented. */
  readonly type: Pasit_Device_Type;
  /**
   * Additional power supply information for devices that provide
   * power to the DUT.
   */
  readonly powerSupply:
    | Pasit_Device_PowerSupply
    | undefined;
  /** Optional RPM if one exists */
  readonly rpm: OSRPM | undefined;
}

/** The type of device represented. */
export enum Pasit_Device_Type {
  UNKNOWN = 0,
  DUT = 1,
  SWITCH_FIXTURE = 2,
  DOCKING_STATION = 3,
  MONITOR = 4,
  CAMERA = 5,
  STORAGE = 6,
  HID = 7,
  NETWORK = 8,
  HEADPHONE = 9,
  SPEAKER = 10,
  IP_POWER = 11,
}

export function pasit_Device_TypeFromJSON(object: any): Pasit_Device_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Pasit_Device_Type.UNKNOWN;
    case 1:
    case "DUT":
      return Pasit_Device_Type.DUT;
    case 2:
    case "SWITCH_FIXTURE":
      return Pasit_Device_Type.SWITCH_FIXTURE;
    case 3:
    case "DOCKING_STATION":
      return Pasit_Device_Type.DOCKING_STATION;
    case 4:
    case "MONITOR":
      return Pasit_Device_Type.MONITOR;
    case 5:
    case "CAMERA":
      return Pasit_Device_Type.CAMERA;
    case 6:
    case "STORAGE":
      return Pasit_Device_Type.STORAGE;
    case 7:
    case "HID":
      return Pasit_Device_Type.HID;
    case 8:
    case "NETWORK":
      return Pasit_Device_Type.NETWORK;
    case 9:
    case "HEADPHONE":
      return Pasit_Device_Type.HEADPHONE;
    case 10:
    case "SPEAKER":
      return Pasit_Device_Type.SPEAKER;
    case 11:
    case "IP_POWER":
      return Pasit_Device_Type.IP_POWER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Pasit_Device_Type");
  }
}

export function pasit_Device_TypeToJSON(object: Pasit_Device_Type): string {
  switch (object) {
    case Pasit_Device_Type.UNKNOWN:
      return "UNKNOWN";
    case Pasit_Device_Type.DUT:
      return "DUT";
    case Pasit_Device_Type.SWITCH_FIXTURE:
      return "SWITCH_FIXTURE";
    case Pasit_Device_Type.DOCKING_STATION:
      return "DOCKING_STATION";
    case Pasit_Device_Type.MONITOR:
      return "MONITOR";
    case Pasit_Device_Type.CAMERA:
      return "CAMERA";
    case Pasit_Device_Type.STORAGE:
      return "STORAGE";
    case Pasit_Device_Type.HID:
      return "HID";
    case Pasit_Device_Type.NETWORK:
      return "NETWORK";
    case Pasit_Device_Type.HEADPHONE:
      return "HEADPHONE";
    case Pasit_Device_Type.SPEAKER:
      return "SPEAKER";
    case Pasit_Device_Type.IP_POWER:
      return "IP_POWER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Pasit_Device_Type");
  }
}

/** Information on the power capabilities of the device. */
export interface Pasit_Device_PowerSupply {
  readonly current: number;
  readonly voltage: number;
  readonly power: number;
}

function createBasePasit(): Pasit {
  return { hostname: "", devices: [], connections: [] };
}

export const Pasit: MessageFns<Pasit> = {
  encode(message: Pasit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    for (const v of message.devices) {
      Pasit_Device.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connections) {
      Pasit_Connection.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pasit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasit() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.devices.push(Pasit_Device.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connections.push(Pasit_Connection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pasit {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      devices: globalThis.Array.isArray(object?.devices)
        ? object.devices.map((e: any) => Pasit_Device.fromJSON(e))
        : [],
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Pasit_Connection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Pasit): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Pasit_Device.toJSON(e));
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Pasit_Connection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Pasit>): Pasit {
    return Pasit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pasit>): Pasit {
    const message = createBasePasit() as any;
    message.hostname = object.hostname ?? "";
    message.devices = object.devices?.map((e) => Pasit_Device.fromPartial(e)) || [];
    message.connections = object.connections?.map((e) => Pasit_Connection.fromPartial(e)) || [];
    return message;
  },
};

function createBasePasit_Connection(): Pasit_Connection {
  return { parentPort: "", parentId: "", childId: "", speed: 0, type: "", tags: [] };
}

export const Pasit_Connection: MessageFns<Pasit_Connection> = {
  encode(message: Pasit_Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentPort !== "") {
      writer.uint32(10).string(message.parentPort);
    }
    if (message.parentId !== "") {
      writer.uint32(18).string(message.parentId);
    }
    if (message.childId !== "") {
      writer.uint32(26).string(message.childId);
    }
    if (message.speed !== 0) {
      writer.uint32(37).float(message.speed);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pasit_Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasit_Connection() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentPort = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.childId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.speed = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pasit_Connection {
    return {
      parentPort: isSet(object.parentPort) ? globalThis.String(object.parentPort) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      childId: isSet(object.childId) ? globalThis.String(object.childId) : "",
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Pasit_Connection): unknown {
    const obj: any = {};
    if (message.parentPort !== "") {
      obj.parentPort = message.parentPort;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.childId !== "") {
      obj.childId = message.childId;
    }
    if (message.speed !== 0) {
      obj.speed = message.speed;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<Pasit_Connection>): Pasit_Connection {
    return Pasit_Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pasit_Connection>): Pasit_Connection {
    const message = createBasePasit_Connection() as any;
    message.parentPort = object.parentPort ?? "";
    message.parentId = object.parentId ?? "";
    message.childId = object.childId ?? "";
    message.speed = object.speed ?? 0;
    message.type = object.type ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBasePasit_Device(): Pasit_Device {
  return { id: "", model: "", type: 0, powerSupply: undefined, rpm: undefined };
}

export const Pasit_Device: MessageFns<Pasit_Device> = {
  encode(message: Pasit_Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.powerSupply !== undefined) {
      Pasit_Device_PowerSupply.encode(message.powerSupply, writer.uint32(34).fork()).join();
    }
    if (message.rpm !== undefined) {
      OSRPM.encode(message.rpm, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pasit_Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasit_Device() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.powerSupply = Pasit_Device_PowerSupply.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rpm = OSRPM.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pasit_Device {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      type: isSet(object.type) ? pasit_Device_TypeFromJSON(object.type) : 0,
      powerSupply: isSet(object.powerSupply) ? Pasit_Device_PowerSupply.fromJSON(object.powerSupply) : undefined,
      rpm: isSet(object.rpm) ? OSRPM.fromJSON(object.rpm) : undefined,
    };
  },

  toJSON(message: Pasit_Device): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.type !== 0) {
      obj.type = pasit_Device_TypeToJSON(message.type);
    }
    if (message.powerSupply !== undefined) {
      obj.powerSupply = Pasit_Device_PowerSupply.toJSON(message.powerSupply);
    }
    if (message.rpm !== undefined) {
      obj.rpm = OSRPM.toJSON(message.rpm);
    }
    return obj;
  },

  create(base?: DeepPartial<Pasit_Device>): Pasit_Device {
    return Pasit_Device.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pasit_Device>): Pasit_Device {
    const message = createBasePasit_Device() as any;
    message.id = object.id ?? "";
    message.model = object.model ?? "";
    message.type = object.type ?? 0;
    message.powerSupply = (object.powerSupply !== undefined && object.powerSupply !== null)
      ? Pasit_Device_PowerSupply.fromPartial(object.powerSupply)
      : undefined;
    message.rpm = (object.rpm !== undefined && object.rpm !== null) ? OSRPM.fromPartial(object.rpm) : undefined;
    return message;
  },
};

function createBasePasit_Device_PowerSupply(): Pasit_Device_PowerSupply {
  return { current: 0, voltage: 0, power: 0 };
}

export const Pasit_Device_PowerSupply: MessageFns<Pasit_Device_PowerSupply> = {
  encode(message: Pasit_Device_PowerSupply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.current !== 0) {
      writer.uint32(13).float(message.current);
    }
    if (message.voltage !== 0) {
      writer.uint32(21).float(message.voltage);
    }
    if (message.power !== 0) {
      writer.uint32(29).float(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pasit_Device_PowerSupply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasit_Device_PowerSupply() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.current = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.voltage = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.power = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pasit_Device_PowerSupply {
    return {
      current: isSet(object.current) ? globalThis.Number(object.current) : 0,
      voltage: isSet(object.voltage) ? globalThis.Number(object.voltage) : 0,
      power: isSet(object.power) ? globalThis.Number(object.power) : 0,
    };
  },

  toJSON(message: Pasit_Device_PowerSupply): unknown {
    const obj: any = {};
    if (message.current !== 0) {
      obj.current = message.current;
    }
    if (message.voltage !== 0) {
      obj.voltage = message.voltage;
    }
    if (message.power !== 0) {
      obj.power = message.power;
    }
    return obj;
  },

  create(base?: DeepPartial<Pasit_Device_PowerSupply>): Pasit_Device_PowerSupply {
    return Pasit_Device_PowerSupply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pasit_Device_PowerSupply>): Pasit_Device_PowerSupply {
    const message = createBasePasit_Device_PowerSupply() as any;
    message.current = object.current ?? 0;
    message.voltage = object.voltage ?? 0;
    message.power = object.power ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
