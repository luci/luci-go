// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.31.1
// source: go.chromium.org/infra/fleetconsole/omnilab/omnilab-pubsub.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../../google/protobuf/timestamp.pb";

export const protobufPackage = "mobileharness.infra.monitoring";

export interface MonitoredRecord {
  /** The timestamp when this monitored record is created. */
  readonly timestamp:
    | string
    | undefined;
  /** The host entry that describes the host information. */
  readonly hostEntry:
    | MonitoredEntry
    | undefined;
  /** The device entry that describes the connected device information. */
  readonly deviceEntry: readonly MonitoredEntry[];
}

export interface MonitoredEntry {
  /** The string map that helps identify the monitored record */
  readonly identifier: { [key: string]: string };
  /** The attributes that describe this monitored record. */
  readonly attribute: readonly Attribute[];
}

export interface MonitoredEntry_IdentifierEntry {
  readonly key: string;
  readonly value: string;
}

export interface Attribute {
  readonly name: string;
  readonly value: string;
}

function createBaseMonitoredRecord(): MonitoredRecord {
  return { timestamp: undefined, hostEntry: undefined, deviceEntry: [] };
}

export const MonitoredRecord: MessageFns<MonitoredRecord> = {
  encode(message: MonitoredRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.hostEntry !== undefined) {
      MonitoredEntry.encode(message.hostEntry, writer.uint32(18).fork()).join();
    }
    for (const v of message.deviceEntry) {
      MonitoredEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoredRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoredRecord() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostEntry = MonitoredEntry.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceEntry.push(MonitoredEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoredRecord {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : undefined,
      hostEntry: isSet(object.hostEntry) ? MonitoredEntry.fromJSON(object.hostEntry) : undefined,
      deviceEntry: globalThis.Array.isArray(object?.deviceEntry)
        ? object.deviceEntry.map((e: any) => MonitoredEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MonitoredRecord): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp;
    }
    if (message.hostEntry !== undefined) {
      obj.hostEntry = MonitoredEntry.toJSON(message.hostEntry);
    }
    if (message.deviceEntry?.length) {
      obj.deviceEntry = message.deviceEntry.map((e) => MonitoredEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoredRecord>): MonitoredRecord {
    return MonitoredRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoredRecord>): MonitoredRecord {
    const message = createBaseMonitoredRecord() as any;
    message.timestamp = object.timestamp ?? undefined;
    message.hostEntry = (object.hostEntry !== undefined && object.hostEntry !== null)
      ? MonitoredEntry.fromPartial(object.hostEntry)
      : undefined;
    message.deviceEntry = object.deviceEntry?.map((e) => MonitoredEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMonitoredEntry(): MonitoredEntry {
  return { identifier: {}, attribute: [] };
}

export const MonitoredEntry: MessageFns<MonitoredEntry> = {
  encode(message: MonitoredEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.identifier).forEach(([key, value]) => {
      MonitoredEntry_IdentifierEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    for (const v of message.attribute) {
      Attribute.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoredEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoredEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MonitoredEntry_IdentifierEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.identifier[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attribute.push(Attribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoredEntry {
    return {
      identifier: isObject(object.identifier)
        ? Object.entries(object.identifier).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attribute: globalThis.Array.isArray(object?.attribute)
        ? object.attribute.map((e: any) => Attribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MonitoredEntry): unknown {
    const obj: any = {};
    if (message.identifier) {
      const entries = Object.entries(message.identifier);
      if (entries.length > 0) {
        obj.identifier = {};
        entries.forEach(([k, v]) => {
          obj.identifier[k] = v;
        });
      }
    }
    if (message.attribute?.length) {
      obj.attribute = message.attribute.map((e) => Attribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoredEntry>): MonitoredEntry {
    return MonitoredEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoredEntry>): MonitoredEntry {
    const message = createBaseMonitoredEntry() as any;
    message.identifier = Object.entries(object.identifier ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.attribute = object.attribute?.map((e) => Attribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMonitoredEntry_IdentifierEntry(): MonitoredEntry_IdentifierEntry {
  return { key: "", value: "" };
}

export const MonitoredEntry_IdentifierEntry: MessageFns<MonitoredEntry_IdentifierEntry> = {
  encode(message: MonitoredEntry_IdentifierEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoredEntry_IdentifierEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoredEntry_IdentifierEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoredEntry_IdentifierEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MonitoredEntry_IdentifierEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoredEntry_IdentifierEntry>): MonitoredEntry_IdentifierEntry {
    return MonitoredEntry_IdentifierEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoredEntry_IdentifierEntry>): MonitoredEntry_IdentifierEntry {
    const message = createBaseMonitoredEntry_IdentifierEntry() as any;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAttribute(): Attribute {
  return { name: "", value: "" };
}

export const Attribute: MessageFns<Attribute> = {
  encode(message: Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Attribute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Attribute>): Attribute {
    return Attribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attribute>): Attribute {
    const message = createBaseAttribute() as any;
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
