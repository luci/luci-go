// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.31.1
// source: go.chromium.org/infra/fleetconsole/api/fleetconsolerpc/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../../../../google/protobuf/empty.pb";
import { MonitoredRecord } from "../../omnilab/omnilab-pubsub.pb";
import { DateOnly } from "./common_types.pb";

export const protobufPackage = "fleetconsole";

export enum DeviceType {
  DEVICE_TYPE_UNSPECIFIED = 0,
  DEVICE_TYPE_VIRTUAL = 1,
  DEVICE_TYPE_PHYSICAL = 2,
}

export function deviceTypeFromJSON(object: any): DeviceType {
  switch (object) {
    case 0:
    case "DEVICE_TYPE_UNSPECIFIED":
      return DeviceType.DEVICE_TYPE_UNSPECIFIED;
    case 1:
    case "DEVICE_TYPE_VIRTUAL":
      return DeviceType.DEVICE_TYPE_VIRTUAL;
    case 2:
    case "DEVICE_TYPE_PHYSICAL":
      return DeviceType.DEVICE_TYPE_PHYSICAL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceType");
  }
}

export function deviceTypeToJSON(object: DeviceType): string {
  switch (object) {
    case DeviceType.DEVICE_TYPE_UNSPECIFIED:
      return "DEVICE_TYPE_UNSPECIFIED";
    case DeviceType.DEVICE_TYPE_VIRTUAL:
      return "DEVICE_TYPE_VIRTUAL";
    case DeviceType.DEVICE_TYPE_PHYSICAL:
      return "DEVICE_TYPE_PHYSICAL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceType");
  }
}

export enum DeviceState {
  DEVICE_STATE_UNSPECIFIED = 0,
  /**
   * DEVICE_STATE_AVAILABLE - Default state.
   * Device is available to be leased.
   */
  DEVICE_STATE_AVAILABLE = 1,
  /** DEVICE_STATE_LEASED - Device is leased. */
  DEVICE_STATE_LEASED = 2,
}

export function deviceStateFromJSON(object: any): DeviceState {
  switch (object) {
    case 0:
    case "DEVICE_STATE_UNSPECIFIED":
      return DeviceState.DEVICE_STATE_UNSPECIFIED;
    case 1:
    case "DEVICE_STATE_AVAILABLE":
      return DeviceState.DEVICE_STATE_AVAILABLE;
    case 2:
    case "DEVICE_STATE_LEASED":
      return DeviceState.DEVICE_STATE_LEASED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceState");
  }
}

export function deviceStateToJSON(object: DeviceState): string {
  switch (object) {
    case DeviceState.DEVICE_STATE_UNSPECIFIED:
      return "DEVICE_STATE_UNSPECIFIED";
    case DeviceState.DEVICE_STATE_AVAILABLE:
      return "DEVICE_STATE_AVAILABLE";
    case DeviceState.DEVICE_STATE_LEASED:
      return "DEVICE_STATE_LEASED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DeviceState");
  }
}

export enum Platform {
  ANDROID = 0,
  CHROMEOS = 1,
}

export function platformFromJSON(object: any): Platform {
  switch (object) {
    case 0:
    case "ANDROID":
      return Platform.ANDROID;
    case 1:
    case "CHROMEOS":
      return Platform.CHROMEOS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Platform");
  }
}

export function platformToJSON(object: Platform): string {
  switch (object) {
    case Platform.ANDROID:
      return "ANDROID";
    case Platform.CHROMEOS:
      return "CHROMEOS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Platform");
  }
}

/** PingRequest intentionally contains nothing. */
export interface PingRequest {
}

/** PingResponse intentionally contains nothing. */
export interface PingResponse {
}

/** PingBigQueryRequest intentionally contains nothing. */
export interface PingBigQueryRequest {
}

/** PingBigQueryResponse intentionally contains nothing. */
export interface PingBigQueryResponse {
}

/** PingDeviceManagerRequest intentionally contains nothing. */
export interface PingDeviceManagerRequest {
}

/** PingDeviceManagerResponse intentionally contains nothing. */
export interface PingDeviceManagerResponse {
}

/** PingUfsRequest intentionally contains nothing. */
export interface PingUfsRequest {
}

/** PingUfsResponse intentionally contains nothing. */
export interface PingUfsResponse {
}

export interface LogFrontendRequest {
  readonly message: string;
  readonly source: string;
  readonly lineno: number;
  readonly colno: number;
  readonly stack: string;
  /** Captures which react component contains the error */
  readonly componentStack: string;
  readonly url: string;
  readonly severity: LogFrontendRequest_Severity;
}

export enum LogFrontendRequest_Severity {
  INFO = 0,
  WARNING = 1,
  ERROR = 2,
}

export function logFrontendRequest_SeverityFromJSON(object: any): LogFrontendRequest_Severity {
  switch (object) {
    case 0:
    case "INFO":
      return LogFrontendRequest_Severity.INFO;
    case 1:
    case "WARNING":
      return LogFrontendRequest_Severity.WARNING;
    case 2:
    case "ERROR":
      return LogFrontendRequest_Severity.ERROR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum LogFrontendRequest_Severity");
  }
}

export function logFrontendRequest_SeverityToJSON(object: LogFrontendRequest_Severity): string {
  switch (object) {
    case LogFrontendRequest_Severity.INFO:
      return "INFO";
    case LogFrontendRequest_Severity.WARNING:
      return "WARNING";
    case LogFrontendRequest_Severity.ERROR:
      return "ERROR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum LogFrontendRequest_Severity");
  }
}

/** LogFrontendResponse intentionally contains nothing. */
export interface LogFrontendResponse {
}

export interface Device {
  /**
   * In the case of VMs, device id could be the GCE instance name. For physical
   * DUTs we use the IDs we get from UFS.
   */
  readonly id: string;
  /** dut_id is the asset tag for a Device */
  readonly dutId: string;
  readonly address: DeviceAddress | undefined;
  readonly type: DeviceType;
  readonly state: DeviceState;
  /** // This proto contains per-DUT hardware relevant information including labels. */
  readonly deviceSpec: DeviceSpec | undefined;
}

export interface DeviceAddress {
  /**
   * IP address of the device.
   * For physical DUTs it can be a hostname.
   */
  readonly host: string;
  readonly port: number;
}

export interface ListDevicesRequest {
  /**
   * The maximum number of devices to return. The service may return fewer than
   * this value. If unspecified, at most 1000 devices will be returned.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListDevices` call. Provide this to
   * retrieve the subsequent page. Returns first page if omitted.
   *
   * When paginating, all other parameters provided to `ListDevices` must match
   * the call that provided the page token.
   */
  readonly pageToken: string;
  readonly orderBy: string;
  /** See: AIP-160 (https://google.aip.dev/160) for the syntax */
  readonly filter: string;
}

export interface ListDevicesResponse {
  /** List of devices to be returned. */
  readonly devices: readonly Device[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page. If
   * this field is omitted, there are no subsequent pages.
   */
  readonly nextPageToken: string;
}

export interface DeviceSpec {
  /** A map for labels used to request a matching device. */
  readonly labels: { [key: string]: LabelValues };
}

export interface DeviceSpec_LabelsEntry {
  readonly key: string;
  readonly value: LabelValues | undefined;
}

export interface GetDeviceDimensionsResponse {
  readonly baseDimensions: { [key: string]: LabelValues };
  readonly labels: { [key: string]: LabelValues };
}

export interface GetDeviceDimensionsResponse_BaseDimensionsEntry {
  readonly key: string;
  readonly value: LabelValues | undefined;
}

export interface GetDeviceDimensionsResponse_LabelsEntry {
  readonly key: string;
  readonly value: LabelValues | undefined;
}

export interface LabelValues {
  readonly values: readonly string[];
}

export interface CountDevicesRequest {
  /**
   * See: AIP-160 (https://google.aip.dev/160) for the syntax
   * Same filter format as ListDevicesRequest
   */
  readonly filter: string;
}

export interface CountDevicesResponse {
  readonly total: number;
  readonly taskState: TaskStateCounts | undefined;
  readonly deviceState: DeviceStateCounts | undefined;
}

export interface TaskStateCounts {
  readonly busy: number;
  readonly idle: number;
}

export interface DeviceStateCounts {
  readonly ready: number;
  readonly needManualRepair: number;
  readonly needRepair: number;
  readonly repairFailed: number;
}

export interface RepopulateCacheRequest {
}

export interface RepopulateCacheResponse {
}

export interface PingDBRequest {
}

export interface PingDBResponse {
}

export interface CleanExitRequest {
}

export interface CleanExitResponse {
}

export interface ExportDevicesToCSVRequest {
  readonly columns: readonly Column[];
  readonly orderBy: string;
  /** See: AIP-160 (https://google.aip.dev/160) for the syntax */
  readonly filter: string;
  /** If specified will export only the devices with the specified ids. */
  readonly ids: readonly string[];
}

export interface Column {
  readonly name: string;
  readonly displayName: string;
}

export interface ExportDevicesToCSVResponse {
  readonly csvData: string;
}

export interface ListResourceRequestsRequest {
  /**
   * The maximum number of Resource Requests to return. The service may return fewer than
   * this value. If unspecified, at most 50 Resource Requests will be returned.
   */
  readonly pageSize: number;
  /**
   * A page token, received from a previous `ListResourceRequests` call. Provide this to
   * retrieve the subsequent page. Returns first page if omitted.
   *
   * When paginating, all other parameters provided to `ListResourceRequests` must match
   * the call that provided the page token.
   */
  readonly pageToken: string;
  readonly orderBy: string;
  /** See: AIP-160 (https://google.aip.dev/160) for the syntax */
  readonly filter: string;
}

export interface ListResourceRequestsResponse {
  /** List of Resource Requests to be returned. */
  readonly resourceRequests: readonly ResourceRequest[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page. If
   * this field is omitted, there are no subsequent pages.
   */
  readonly nextPageToken: string;
}

export interface ResourceRequest {
  /**
   * The resource name of the resource request.
   * Format: resourceRequests/{rr_id}
   */
  readonly name: string;
  /** The ID of the resource request. */
  readonly rrId: string;
  /** The details of the resource request. */
  readonly resourceDetails: string;
  readonly procurementTargetStartDate?: DateOnly | undefined;
  readonly procurementActualStartDate?: DateOnly | undefined;
  readonly procurementTargetDeliveryDate?: DateOnly | undefined;
  readonly procurementActualDeliveryDate?: DateOnly | undefined;
  readonly buildTargetStartDate?: DateOnly | undefined;
  readonly buildActualStartDate?: DateOnly | undefined;
  readonly buildTargetDeliveryDate?: DateOnly | undefined;
  readonly buildActualDeliveryDate?: DateOnly | undefined;
  readonly qaTargetStartDate?: DateOnly | undefined;
  readonly qaActualStartDate?: DateOnly | undefined;
  readonly qaTargetDeliveryDate?: DateOnly | undefined;
  readonly qaActualDeliveryDate?: DateOnly | undefined;
  readonly configTargetStartDate?: DateOnly | undefined;
  readonly configActualStartDate?: DateOnly | undefined;
  readonly configTargetDeliveryDate?: DateOnly | undefined;
  readonly configActualDeliveryDate?:
    | DateOnly
    | undefined;
  /** Expected ETA for the resource request. */
  readonly expectedEta?:
    | DateOnly
    | undefined;
  /** Status of the Fulfillment bug for the resource request. */
  readonly fulfillmentStatus?: ResourceRequest_Status | undefined;
  readonly materialSourcingStatus?: ResourceRequest_Status | undefined;
  readonly buildStatus?: ResourceRequest_Status | undefined;
  readonly qaStatus?: ResourceRequest_Status | undefined;
  readonly configStatus?: ResourceRequest_Status | undefined;
  readonly customer?: string | undefined;
  readonly resourceGroup?: string | undefined;
  readonly resourceName?: string | undefined;
  readonly acceptedQuantity?: number | undefined;
  readonly criticality?: string | undefined;
  readonly requestApproval?: string | undefined;
  readonly resourcePm?: string | undefined;
  readonly fulfillmentChannel?: string | undefined;
  readonly executionStatus?: string | undefined;
  readonly resourceGroups: readonly string[];
  readonly resourceRequestBugId?: string | undefined;
}

export enum ResourceRequest_Status {
  NOT_STARTED = 0,
  IN_PROGRESS = 1,
  COMPLETE = 2,
}

export function resourceRequest_StatusFromJSON(object: any): ResourceRequest_Status {
  switch (object) {
    case 0:
    case "NOT_STARTED":
      return ResourceRequest_Status.NOT_STARTED;
    case 1:
    case "IN_PROGRESS":
      return ResourceRequest_Status.IN_PROGRESS;
    case 2:
    case "COMPLETE":
      return ResourceRequest_Status.COMPLETE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ResourceRequest_Status");
  }
}

export function resourceRequest_StatusToJSON(object: ResourceRequest_Status): string {
  switch (object) {
    case ResourceRequest_Status.NOT_STARTED:
      return "NOT_STARTED";
    case ResourceRequest_Status.IN_PROGRESS:
      return "IN_PROGRESS";
    case ResourceRequest_Status.COMPLETE:
      return "COMPLETE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ResourceRequest_Status");
  }
}

export interface CountResourceRequestsRequest {
  /**
   * See: AIP-160 (https://google.aip.dev/160) for the syntax
   * Same filter format as ListDevicesRequest
   */
  readonly filter: string;
}

export interface CountResourceRequestsResponse {
  readonly total: number;
  readonly inProgress: number;
  readonly completed: number;
  readonly materialSourcing: number;
  readonly build: number;
  readonly qa: number;
  readonly config: number;
}

export interface GetResourceRequestsMultiselectFilterValuesRequest {
}

export interface GetResourceRequestsMultiselectFilterValuesResponse {
  readonly rrIds: readonly string[];
  readonly resourceDetails: readonly string[];
  readonly materialSourcingStatus: readonly string[];
  readonly buildStatus: readonly string[];
  readonly qaStatus: readonly string[];
  readonly configStatus: readonly string[];
  readonly customer: readonly string[];
  readonly resourceName: readonly string[];
  readonly acceptedQuantity: readonly number[];
  readonly criticality: readonly string[];
  readonly requestApproval: readonly string[];
  readonly resourcePm: readonly string[];
  readonly fulfillmentChannel: readonly string[];
  readonly executionStatus: readonly string[];
  /**
   * Contains all unique string values from the 'resource_groups' (repeated) field
   * across all resource requests.
   */
  readonly resourceGroups: readonly string[];
}

/** ************* REPAIR METRICS ********************* */
export interface UpdateAndroidDevicesRequest {
  readonly host: MonitoredRecord | undefined;
}

export interface UpdateAndroidDevicesResponse {
}

export interface ListRepairMetricsRequest {
  readonly platform: Platform;
  readonly pageSize: number;
  readonly pageToken: string;
  readonly orderBy: string;
  /** See: AIP-160 (https://google.aip.dev/160) for the syntax */
  readonly filter: string;
}

export interface RepairMetric {
  readonly priority: RepairMetric_Priority;
  readonly labName: string;
  readonly hostGroup: string;
  readonly runTarget: string;
  readonly minimumRepairs: number;
  readonly devicesOffline: number;
  readonly totalDevices: number;
}

export enum RepairMetric_Priority {
  BREACHED = 0,
  WATCH = 1,
  DEVICES_REMOVED = 2,
  MISSING_DATA = 3,
  NICE = 4,
}

export function repairMetric_PriorityFromJSON(object: any): RepairMetric_Priority {
  switch (object) {
    case 0:
    case "BREACHED":
      return RepairMetric_Priority.BREACHED;
    case 1:
    case "WATCH":
      return RepairMetric_Priority.WATCH;
    case 2:
    case "DEVICES_REMOVED":
      return RepairMetric_Priority.DEVICES_REMOVED;
    case 3:
    case "MISSING_DATA":
      return RepairMetric_Priority.MISSING_DATA;
    case 4:
    case "NICE":
      return RepairMetric_Priority.NICE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RepairMetric_Priority");
  }
}

export function repairMetric_PriorityToJSON(object: RepairMetric_Priority): string {
  switch (object) {
    case RepairMetric_Priority.BREACHED:
      return "BREACHED";
    case RepairMetric_Priority.WATCH:
      return "WATCH";
    case RepairMetric_Priority.DEVICES_REMOVED:
      return "DEVICES_REMOVED";
    case RepairMetric_Priority.MISSING_DATA:
      return "MISSING_DATA";
    case RepairMetric_Priority.NICE:
      return "NICE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RepairMetric_Priority");
  }
}

export interface ListRepairMetricsResponse {
  readonly repairMetrics: readonly RepairMetric[];
  readonly nextPageToken: string;
}

export interface CountRepairMetricsRequest {
  readonly platform: Platform;
  /** See: AIP-160 (https://google.aip.dev/160) for the syntax */
  readonly filter: string;
}

export interface CountRepairMetricsResponse {
  readonly totalHosts: number;
  readonly offlineHosts: number;
  readonly totalDevices: number;
  readonly offlineDevices: number;
}

export interface GetRepairMetricsDimensionsRequest {
  readonly platform: Platform;
}

export interface GetRepairMetricsDimensionsResponse {
  readonly dimensions: { [key: string]: GetRepairMetricsDimensionsResponse_Values };
}

export interface GetRepairMetricsDimensionsResponse_Values {
  readonly values: readonly string[];
}

export interface GetRepairMetricsDimensionsResponse_DimensionsEntry {
  readonly key: string;
  readonly value: GetRepairMetricsDimensionsResponse_Values | undefined;
}

function createBasePingRequest(): PingRequest {
  return {};
}

export const PingRequest: MessageFns<PingRequest> = {
  encode(_: PingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingRequest {
    return {};
  },

  toJSON(_: PingRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingRequest>): PingRequest {
    return PingRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingRequest>): PingRequest {
    const message = createBasePingRequest() as any;
    return message;
  },
};

function createBasePingResponse(): PingResponse {
  return {};
}

export const PingResponse: MessageFns<PingResponse> = {
  encode(_: PingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingResponse {
    return {};
  },

  toJSON(_: PingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingResponse>): PingResponse {
    return PingResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingResponse>): PingResponse {
    const message = createBasePingResponse() as any;
    return message;
  },
};

function createBasePingBigQueryRequest(): PingBigQueryRequest {
  return {};
}

export const PingBigQueryRequest: MessageFns<PingBigQueryRequest> = {
  encode(_: PingBigQueryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingBigQueryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingBigQueryRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingBigQueryRequest {
    return {};
  },

  toJSON(_: PingBigQueryRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingBigQueryRequest>): PingBigQueryRequest {
    return PingBigQueryRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingBigQueryRequest>): PingBigQueryRequest {
    const message = createBasePingBigQueryRequest() as any;
    return message;
  },
};

function createBasePingBigQueryResponse(): PingBigQueryResponse {
  return {};
}

export const PingBigQueryResponse: MessageFns<PingBigQueryResponse> = {
  encode(_: PingBigQueryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingBigQueryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingBigQueryResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingBigQueryResponse {
    return {};
  },

  toJSON(_: PingBigQueryResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingBigQueryResponse>): PingBigQueryResponse {
    return PingBigQueryResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingBigQueryResponse>): PingBigQueryResponse {
    const message = createBasePingBigQueryResponse() as any;
    return message;
  },
};

function createBasePingDeviceManagerRequest(): PingDeviceManagerRequest {
  return {};
}

export const PingDeviceManagerRequest: MessageFns<PingDeviceManagerRequest> = {
  encode(_: PingDeviceManagerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingDeviceManagerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingDeviceManagerRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingDeviceManagerRequest {
    return {};
  },

  toJSON(_: PingDeviceManagerRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingDeviceManagerRequest>): PingDeviceManagerRequest {
    return PingDeviceManagerRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingDeviceManagerRequest>): PingDeviceManagerRequest {
    const message = createBasePingDeviceManagerRequest() as any;
    return message;
  },
};

function createBasePingDeviceManagerResponse(): PingDeviceManagerResponse {
  return {};
}

export const PingDeviceManagerResponse: MessageFns<PingDeviceManagerResponse> = {
  encode(_: PingDeviceManagerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingDeviceManagerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingDeviceManagerResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingDeviceManagerResponse {
    return {};
  },

  toJSON(_: PingDeviceManagerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingDeviceManagerResponse>): PingDeviceManagerResponse {
    return PingDeviceManagerResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingDeviceManagerResponse>): PingDeviceManagerResponse {
    const message = createBasePingDeviceManagerResponse() as any;
    return message;
  },
};

function createBasePingUfsRequest(): PingUfsRequest {
  return {};
}

export const PingUfsRequest: MessageFns<PingUfsRequest> = {
  encode(_: PingUfsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingUfsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingUfsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingUfsRequest {
    return {};
  },

  toJSON(_: PingUfsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingUfsRequest>): PingUfsRequest {
    return PingUfsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingUfsRequest>): PingUfsRequest {
    const message = createBasePingUfsRequest() as any;
    return message;
  },
};

function createBasePingUfsResponse(): PingUfsResponse {
  return {};
}

export const PingUfsResponse: MessageFns<PingUfsResponse> = {
  encode(_: PingUfsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingUfsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingUfsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingUfsResponse {
    return {};
  },

  toJSON(_: PingUfsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingUfsResponse>): PingUfsResponse {
    return PingUfsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingUfsResponse>): PingUfsResponse {
    const message = createBasePingUfsResponse() as any;
    return message;
  },
};

function createBaseLogFrontendRequest(): LogFrontendRequest {
  return { message: "", source: "", lineno: 0, colno: 0, stack: "", componentStack: "", url: "", severity: 0 };
}

export const LogFrontendRequest: MessageFns<LogFrontendRequest> = {
  encode(message: LogFrontendRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.lineno !== 0) {
      writer.uint32(24).int32(message.lineno);
    }
    if (message.colno !== 0) {
      writer.uint32(32).int32(message.colno);
    }
    if (message.stack !== "") {
      writer.uint32(42).string(message.stack);
    }
    if (message.componentStack !== "") {
      writer.uint32(50).string(message.componentStack);
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.severity !== 0) {
      writer.uint32(64).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogFrontendRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogFrontendRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lineno = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.colno = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stack = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.componentStack = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogFrontendRequest {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      lineno: isSet(object.lineno) ? globalThis.Number(object.lineno) : 0,
      colno: isSet(object.colno) ? globalThis.Number(object.colno) : 0,
      stack: isSet(object.stack) ? globalThis.String(object.stack) : "",
      componentStack: isSet(object.componentStack) ? globalThis.String(object.componentStack) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      severity: isSet(object.severity) ? logFrontendRequest_SeverityFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: LogFrontendRequest): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.lineno !== 0) {
      obj.lineno = Math.round(message.lineno);
    }
    if (message.colno !== 0) {
      obj.colno = Math.round(message.colno);
    }
    if (message.stack !== "") {
      obj.stack = message.stack;
    }
    if (message.componentStack !== "") {
      obj.componentStack = message.componentStack;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.severity !== 0) {
      obj.severity = logFrontendRequest_SeverityToJSON(message.severity);
    }
    return obj;
  },

  create(base?: DeepPartial<LogFrontendRequest>): LogFrontendRequest {
    return LogFrontendRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogFrontendRequest>): LogFrontendRequest {
    const message = createBaseLogFrontendRequest() as any;
    message.message = object.message ?? "";
    message.source = object.source ?? "";
    message.lineno = object.lineno ?? 0;
    message.colno = object.colno ?? 0;
    message.stack = object.stack ?? "";
    message.componentStack = object.componentStack ?? "";
    message.url = object.url ?? "";
    message.severity = object.severity ?? 0;
    return message;
  },
};

function createBaseLogFrontendResponse(): LogFrontendResponse {
  return {};
}

export const LogFrontendResponse: MessageFns<LogFrontendResponse> = {
  encode(_: LogFrontendResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogFrontendResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogFrontendResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogFrontendResponse {
    return {};
  },

  toJSON(_: LogFrontendResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LogFrontendResponse>): LogFrontendResponse {
    return LogFrontendResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LogFrontendResponse>): LogFrontendResponse {
    const message = createBaseLogFrontendResponse() as any;
    return message;
  },
};

function createBaseDevice(): Device {
  return { id: "", dutId: "", address: undefined, type: 0, state: 0, deviceSpec: undefined };
}

export const Device: MessageFns<Device> = {
  encode(message: Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dutId !== "") {
      writer.uint32(50).string(message.dutId);
    }
    if (message.address !== undefined) {
      DeviceAddress.encode(message.address, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.deviceSpec !== undefined) {
      DeviceSpec.encode(message.deviceSpec, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dutId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = DeviceAddress.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deviceSpec = DeviceSpec.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dutId: isSet(object.dutId) ? globalThis.String(object.dutId) : "",
      address: isSet(object.address) ? DeviceAddress.fromJSON(object.address) : undefined,
      type: isSet(object.type) ? deviceTypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? deviceStateFromJSON(object.state) : 0,
      deviceSpec: isSet(object.deviceSpec) ? DeviceSpec.fromJSON(object.deviceSpec) : undefined,
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dutId !== "") {
      obj.dutId = message.dutId;
    }
    if (message.address !== undefined) {
      obj.address = DeviceAddress.toJSON(message.address);
    }
    if (message.type !== 0) {
      obj.type = deviceTypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = deviceStateToJSON(message.state);
    }
    if (message.deviceSpec !== undefined) {
      obj.deviceSpec = DeviceSpec.toJSON(message.deviceSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<Device>): Device {
    return Device.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device>): Device {
    const message = createBaseDevice() as any;
    message.id = object.id ?? "";
    message.dutId = object.dutId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? DeviceAddress.fromPartial(object.address)
      : undefined;
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.deviceSpec = (object.deviceSpec !== undefined && object.deviceSpec !== null)
      ? DeviceSpec.fromPartial(object.deviceSpec)
      : undefined;
    return message;
  },
};

function createBaseDeviceAddress(): DeviceAddress {
  return { host: "", port: 0 };
}

export const DeviceAddress: MessageFns<DeviceAddress> = {
  encode(message: DeviceAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceAddress() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceAddress {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: DeviceAddress): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceAddress>): DeviceAddress {
    return DeviceAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceAddress>): DeviceAddress {
    const message = createBaseDeviceAddress() as any;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseListDevicesRequest(): ListDevicesRequest {
  return { pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListDevicesRequest: MessageFns<ListDevicesRequest> = {
  encode(message: ListDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListDevicesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDevicesRequest>): ListDevicesRequest {
    return ListDevicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDevicesRequest>): ListDevicesRequest {
    const message = createBaseListDevicesRequest() as any;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListDevicesResponse(): ListDevicesResponse {
  return { devices: [], nextPageToken: "" };
}

export const ListDevicesResponse: MessageFns<ListDevicesResponse> = {
  encode(message: ListDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.devices) {
      Device.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDevicesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.devices.push(Device.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDevicesResponse {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => Device.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDevicesResponse): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => Device.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDevicesResponse>): ListDevicesResponse {
    return ListDevicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDevicesResponse>): ListDevicesResponse {
    const message = createBaseListDevicesResponse() as any;
    message.devices = object.devices?.map((e) => Device.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeviceSpec(): DeviceSpec {
  return { labels: {} };
}

export const DeviceSpec: MessageFns<DeviceSpec> = {
  encode(message: DeviceSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      DeviceSpec_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceSpec() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DeviceSpec_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceSpec {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: LabelValues }>((acc, [key, value]) => {
          acc[key] = LabelValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeviceSpec): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = LabelValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceSpec>): DeviceSpec {
    return DeviceSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceSpec>): DeviceSpec {
    const message = createBaseDeviceSpec() as any;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: LabelValues }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = LabelValues.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDeviceSpec_LabelsEntry(): DeviceSpec_LabelsEntry {
  return { key: "", value: undefined };
}

export const DeviceSpec_LabelsEntry: MessageFns<DeviceSpec_LabelsEntry> = {
  encode(message: DeviceSpec_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LabelValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceSpec_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceSpec_LabelsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LabelValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceSpec_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LabelValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DeviceSpec_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LabelValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceSpec_LabelsEntry>): DeviceSpec_LabelsEntry {
    return DeviceSpec_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceSpec_LabelsEntry>): DeviceSpec_LabelsEntry {
    const message = createBaseDeviceSpec_LabelsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LabelValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetDeviceDimensionsResponse(): GetDeviceDimensionsResponse {
  return { baseDimensions: {}, labels: {} };
}

export const GetDeviceDimensionsResponse: MessageFns<GetDeviceDimensionsResponse> = {
  encode(message: GetDeviceDimensionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.baseDimensions).forEach(([key, value]) => {
      GetDeviceDimensionsResponse_BaseDimensionsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      GetDeviceDimensionsResponse_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceDimensionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceDimensionsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetDeviceDimensionsResponse_BaseDimensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.baseDimensions[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetDeviceDimensionsResponse_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceDimensionsResponse {
    return {
      baseDimensions: isObject(object.baseDimensions)
        ? Object.entries(object.baseDimensions).reduce<{ [key: string]: LabelValues }>((acc, [key, value]) => {
          acc[key] = LabelValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: LabelValues }>((acc, [key, value]) => {
          acc[key] = LabelValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetDeviceDimensionsResponse): unknown {
    const obj: any = {};
    if (message.baseDimensions) {
      const entries = Object.entries(message.baseDimensions);
      if (entries.length > 0) {
        obj.baseDimensions = {};
        entries.forEach(([k, v]) => {
          obj.baseDimensions[k] = LabelValues.toJSON(v);
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = LabelValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeviceDimensionsResponse>): GetDeviceDimensionsResponse {
    return GetDeviceDimensionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeviceDimensionsResponse>): GetDeviceDimensionsResponse {
    const message = createBaseGetDeviceDimensionsResponse() as any;
    message.baseDimensions = Object.entries(object.baseDimensions ?? {}).reduce<{ [key: string]: LabelValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = LabelValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: LabelValues }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = LabelValues.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetDeviceDimensionsResponse_BaseDimensionsEntry(): GetDeviceDimensionsResponse_BaseDimensionsEntry {
  return { key: "", value: undefined };
}

export const GetDeviceDimensionsResponse_BaseDimensionsEntry: MessageFns<
  GetDeviceDimensionsResponse_BaseDimensionsEntry
> = {
  encode(
    message: GetDeviceDimensionsResponse_BaseDimensionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LabelValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceDimensionsResponse_BaseDimensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceDimensionsResponse_BaseDimensionsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LabelValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceDimensionsResponse_BaseDimensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LabelValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetDeviceDimensionsResponse_BaseDimensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LabelValues.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetDeviceDimensionsResponse_BaseDimensionsEntry>,
  ): GetDeviceDimensionsResponse_BaseDimensionsEntry {
    return GetDeviceDimensionsResponse_BaseDimensionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetDeviceDimensionsResponse_BaseDimensionsEntry>,
  ): GetDeviceDimensionsResponse_BaseDimensionsEntry {
    const message = createBaseGetDeviceDimensionsResponse_BaseDimensionsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LabelValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetDeviceDimensionsResponse_LabelsEntry(): GetDeviceDimensionsResponse_LabelsEntry {
  return { key: "", value: undefined };
}

export const GetDeviceDimensionsResponse_LabelsEntry: MessageFns<GetDeviceDimensionsResponse_LabelsEntry> = {
  encode(message: GetDeviceDimensionsResponse_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LabelValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeviceDimensionsResponse_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeviceDimensionsResponse_LabelsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LabelValues.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeviceDimensionsResponse_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LabelValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetDeviceDimensionsResponse_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LabelValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeviceDimensionsResponse_LabelsEntry>): GetDeviceDimensionsResponse_LabelsEntry {
    return GetDeviceDimensionsResponse_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeviceDimensionsResponse_LabelsEntry>): GetDeviceDimensionsResponse_LabelsEntry {
    const message = createBaseGetDeviceDimensionsResponse_LabelsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LabelValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseLabelValues(): LabelValues {
  return { values: [] };
}

export const LabelValues: MessageFns<LabelValues> = {
  encode(message: LabelValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelValues() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: LabelValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<LabelValues>): LabelValues {
    return LabelValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelValues>): LabelValues {
    const message = createBaseLabelValues() as any;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseCountDevicesRequest(): CountDevicesRequest {
  return { filter: "" };
}

export const CountDevicesRequest: MessageFns<CountDevicesRequest> = {
  encode(message: CountDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountDevicesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountDevicesRequest {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: CountDevicesRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<CountDevicesRequest>): CountDevicesRequest {
    return CountDevicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountDevicesRequest>): CountDevicesRequest {
    const message = createBaseCountDevicesRequest() as any;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseCountDevicesResponse(): CountDevicesResponse {
  return { total: 0, taskState: undefined, deviceState: undefined };
}

export const CountDevicesResponse: MessageFns<CountDevicesResponse> = {
  encode(message: CountDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.taskState !== undefined) {
      TaskStateCounts.encode(message.taskState, writer.uint32(18).fork()).join();
    }
    if (message.deviceState !== undefined) {
      DeviceStateCounts.encode(message.deviceState, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountDevicesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskState = TaskStateCounts.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceState = DeviceStateCounts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountDevicesResponse {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      taskState: isSet(object.taskState) ? TaskStateCounts.fromJSON(object.taskState) : undefined,
      deviceState: isSet(object.deviceState) ? DeviceStateCounts.fromJSON(object.deviceState) : undefined,
    };
  },

  toJSON(message: CountDevicesResponse): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.taskState !== undefined) {
      obj.taskState = TaskStateCounts.toJSON(message.taskState);
    }
    if (message.deviceState !== undefined) {
      obj.deviceState = DeviceStateCounts.toJSON(message.deviceState);
    }
    return obj;
  },

  create(base?: DeepPartial<CountDevicesResponse>): CountDevicesResponse {
    return CountDevicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountDevicesResponse>): CountDevicesResponse {
    const message = createBaseCountDevicesResponse() as any;
    message.total = object.total ?? 0;
    message.taskState = (object.taskState !== undefined && object.taskState !== null)
      ? TaskStateCounts.fromPartial(object.taskState)
      : undefined;
    message.deviceState = (object.deviceState !== undefined && object.deviceState !== null)
      ? DeviceStateCounts.fromPartial(object.deviceState)
      : undefined;
    return message;
  },
};

function createBaseTaskStateCounts(): TaskStateCounts {
  return { busy: 0, idle: 0 };
}

export const TaskStateCounts: MessageFns<TaskStateCounts> = {
  encode(message: TaskStateCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.busy !== 0) {
      writer.uint32(8).int32(message.busy);
    }
    if (message.idle !== 0) {
      writer.uint32(16).int32(message.idle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStateCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStateCounts() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.busy = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idle = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskStateCounts {
    return {
      busy: isSet(object.busy) ? globalThis.Number(object.busy) : 0,
      idle: isSet(object.idle) ? globalThis.Number(object.idle) : 0,
    };
  },

  toJSON(message: TaskStateCounts): unknown {
    const obj: any = {};
    if (message.busy !== 0) {
      obj.busy = Math.round(message.busy);
    }
    if (message.idle !== 0) {
      obj.idle = Math.round(message.idle);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskStateCounts>): TaskStateCounts {
    return TaskStateCounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskStateCounts>): TaskStateCounts {
    const message = createBaseTaskStateCounts() as any;
    message.busy = object.busy ?? 0;
    message.idle = object.idle ?? 0;
    return message;
  },
};

function createBaseDeviceStateCounts(): DeviceStateCounts {
  return { ready: 0, needManualRepair: 0, needRepair: 0, repairFailed: 0 };
}

export const DeviceStateCounts: MessageFns<DeviceStateCounts> = {
  encode(message: DeviceStateCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ready !== 0) {
      writer.uint32(8).int32(message.ready);
    }
    if (message.needManualRepair !== 0) {
      writer.uint32(16).int32(message.needManualRepair);
    }
    if (message.needRepair !== 0) {
      writer.uint32(24).int32(message.needRepair);
    }
    if (message.repairFailed !== 0) {
      writer.uint32(32).int32(message.repairFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceStateCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceStateCounts() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ready = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.needManualRepair = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needRepair = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.repairFailed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceStateCounts {
    return {
      ready: isSet(object.ready) ? globalThis.Number(object.ready) : 0,
      needManualRepair: isSet(object.needManualRepair) ? globalThis.Number(object.needManualRepair) : 0,
      needRepair: isSet(object.needRepair) ? globalThis.Number(object.needRepair) : 0,
      repairFailed: isSet(object.repairFailed) ? globalThis.Number(object.repairFailed) : 0,
    };
  },

  toJSON(message: DeviceStateCounts): unknown {
    const obj: any = {};
    if (message.ready !== 0) {
      obj.ready = Math.round(message.ready);
    }
    if (message.needManualRepair !== 0) {
      obj.needManualRepair = Math.round(message.needManualRepair);
    }
    if (message.needRepair !== 0) {
      obj.needRepair = Math.round(message.needRepair);
    }
    if (message.repairFailed !== 0) {
      obj.repairFailed = Math.round(message.repairFailed);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceStateCounts>): DeviceStateCounts {
    return DeviceStateCounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceStateCounts>): DeviceStateCounts {
    const message = createBaseDeviceStateCounts() as any;
    message.ready = object.ready ?? 0;
    message.needManualRepair = object.needManualRepair ?? 0;
    message.needRepair = object.needRepair ?? 0;
    message.repairFailed = object.repairFailed ?? 0;
    return message;
  },
};

function createBaseRepopulateCacheRequest(): RepopulateCacheRequest {
  return {};
}

export const RepopulateCacheRequest: MessageFns<RepopulateCacheRequest> = {
  encode(_: RepopulateCacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepopulateCacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepopulateCacheRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RepopulateCacheRequest {
    return {};
  },

  toJSON(_: RepopulateCacheRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RepopulateCacheRequest>): RepopulateCacheRequest {
    return RepopulateCacheRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RepopulateCacheRequest>): RepopulateCacheRequest {
    const message = createBaseRepopulateCacheRequest() as any;
    return message;
  },
};

function createBaseRepopulateCacheResponse(): RepopulateCacheResponse {
  return {};
}

export const RepopulateCacheResponse: MessageFns<RepopulateCacheResponse> = {
  encode(_: RepopulateCacheResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepopulateCacheResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepopulateCacheResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RepopulateCacheResponse {
    return {};
  },

  toJSON(_: RepopulateCacheResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RepopulateCacheResponse>): RepopulateCacheResponse {
    return RepopulateCacheResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RepopulateCacheResponse>): RepopulateCacheResponse {
    const message = createBaseRepopulateCacheResponse() as any;
    return message;
  },
};

function createBasePingDBRequest(): PingDBRequest {
  return {};
}

export const PingDBRequest: MessageFns<PingDBRequest> = {
  encode(_: PingDBRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingDBRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingDBRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingDBRequest {
    return {};
  },

  toJSON(_: PingDBRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingDBRequest>): PingDBRequest {
    return PingDBRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingDBRequest>): PingDBRequest {
    const message = createBasePingDBRequest() as any;
    return message;
  },
};

function createBasePingDBResponse(): PingDBResponse {
  return {};
}

export const PingDBResponse: MessageFns<PingDBResponse> = {
  encode(_: PingDBResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingDBResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingDBResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingDBResponse {
    return {};
  },

  toJSON(_: PingDBResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PingDBResponse>): PingDBResponse {
    return PingDBResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PingDBResponse>): PingDBResponse {
    const message = createBasePingDBResponse() as any;
    return message;
  },
};

function createBaseCleanExitRequest(): CleanExitRequest {
  return {};
}

export const CleanExitRequest: MessageFns<CleanExitRequest> = {
  encode(_: CleanExitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CleanExitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCleanExitRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CleanExitRequest {
    return {};
  },

  toJSON(_: CleanExitRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CleanExitRequest>): CleanExitRequest {
    return CleanExitRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CleanExitRequest>): CleanExitRequest {
    const message = createBaseCleanExitRequest() as any;
    return message;
  },
};

function createBaseCleanExitResponse(): CleanExitResponse {
  return {};
}

export const CleanExitResponse: MessageFns<CleanExitResponse> = {
  encode(_: CleanExitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CleanExitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCleanExitResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CleanExitResponse {
    return {};
  },

  toJSON(_: CleanExitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CleanExitResponse>): CleanExitResponse {
    return CleanExitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CleanExitResponse>): CleanExitResponse {
    const message = createBaseCleanExitResponse() as any;
    return message;
  },
};

function createBaseExportDevicesToCSVRequest(): ExportDevicesToCSVRequest {
  return { columns: [], orderBy: "", filter: "", ids: [] };
}

export const ExportDevicesToCSVRequest: MessageFns<ExportDevicesToCSVRequest> = {
  encode(message: ExportDevicesToCSVRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      Column.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.orderBy !== "") {
      writer.uint32(18).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    for (const v of message.ids) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDevicesToCSVRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDevicesToCSVRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columns.push(Column.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDevicesToCSVRequest {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Column.fromJSON(e)) : [],
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ExportDevicesToCSVRequest): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Column.toJSON(e));
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDevicesToCSVRequest>): ExportDevicesToCSVRequest {
    return ExportDevicesToCSVRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDevicesToCSVRequest>): ExportDevicesToCSVRequest {
    const message = createBaseExportDevicesToCSVRequest() as any;
    message.columns = object.columns?.map((e) => Column.fromPartial(e)) || [];
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseColumn(): Column {
  return { name: "", displayName: "" };
}

export const Column: MessageFns<Column> = {
  encode(message: Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Column): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<Column>): Column {
    return Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Column>): Column {
    const message = createBaseColumn() as any;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseExportDevicesToCSVResponse(): ExportDevicesToCSVResponse {
  return { csvData: "" };
}

export const ExportDevicesToCSVResponse: MessageFns<ExportDevicesToCSVResponse> = {
  encode(message: ExportDevicesToCSVResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csvData !== "") {
      writer.uint32(10).string(message.csvData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDevicesToCSVResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDevicesToCSVResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.csvData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDevicesToCSVResponse {
    return { csvData: isSet(object.csvData) ? globalThis.String(object.csvData) : "" };
  },

  toJSON(message: ExportDevicesToCSVResponse): unknown {
    const obj: any = {};
    if (message.csvData !== "") {
      obj.csvData = message.csvData;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDevicesToCSVResponse>): ExportDevicesToCSVResponse {
    return ExportDevicesToCSVResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDevicesToCSVResponse>): ExportDevicesToCSVResponse {
    const message = createBaseExportDevicesToCSVResponse() as any;
    message.csvData = object.csvData ?? "";
    return message;
  },
};

function createBaseListResourceRequestsRequest(): ListResourceRequestsRequest {
  return { pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListResourceRequestsRequest: MessageFns<ListResourceRequestsRequest> = {
  encode(message: ListResourceRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListResourceRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResourceRequestsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListResourceRequestsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListResourceRequestsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListResourceRequestsRequest>): ListResourceRequestsRequest {
    return ListResourceRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListResourceRequestsRequest>): ListResourceRequestsRequest {
    const message = createBaseListResourceRequestsRequest() as any;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListResourceRequestsResponse(): ListResourceRequestsResponse {
  return { resourceRequests: [], nextPageToken: "" };
}

export const ListResourceRequestsResponse: MessageFns<ListResourceRequestsResponse> = {
  encode(message: ListResourceRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resourceRequests) {
      ResourceRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListResourceRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResourceRequestsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceRequests.push(ResourceRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListResourceRequestsResponse {
    return {
      resourceRequests: globalThis.Array.isArray(object?.resourceRequests)
        ? object.resourceRequests.map((e: any) => ResourceRequest.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListResourceRequestsResponse): unknown {
    const obj: any = {};
    if (message.resourceRequests?.length) {
      obj.resourceRequests = message.resourceRequests.map((e) => ResourceRequest.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListResourceRequestsResponse>): ListResourceRequestsResponse {
    return ListResourceRequestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListResourceRequestsResponse>): ListResourceRequestsResponse {
    const message = createBaseListResourceRequestsResponse() as any;
    message.resourceRequests = object.resourceRequests?.map((e) => ResourceRequest.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseResourceRequest(): ResourceRequest {
  return {
    name: "",
    rrId: "",
    resourceDetails: "",
    procurementTargetStartDate: undefined,
    procurementActualStartDate: undefined,
    procurementTargetDeliveryDate: undefined,
    procurementActualDeliveryDate: undefined,
    buildTargetStartDate: undefined,
    buildActualStartDate: undefined,
    buildTargetDeliveryDate: undefined,
    buildActualDeliveryDate: undefined,
    qaTargetStartDate: undefined,
    qaActualStartDate: undefined,
    qaTargetDeliveryDate: undefined,
    qaActualDeliveryDate: undefined,
    configTargetStartDate: undefined,
    configActualStartDate: undefined,
    configTargetDeliveryDate: undefined,
    configActualDeliveryDate: undefined,
    expectedEta: undefined,
    fulfillmentStatus: undefined,
    materialSourcingStatus: undefined,
    buildStatus: undefined,
    qaStatus: undefined,
    configStatus: undefined,
    customer: undefined,
    resourceGroup: undefined,
    resourceName: undefined,
    acceptedQuantity: undefined,
    criticality: undefined,
    requestApproval: undefined,
    resourcePm: undefined,
    fulfillmentChannel: undefined,
    executionStatus: undefined,
    resourceGroups: [],
    resourceRequestBugId: undefined,
  };
}

export const ResourceRequest: MessageFns<ResourceRequest> = {
  encode(message: ResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.rrId !== "") {
      writer.uint32(18).string(message.rrId);
    }
    if (message.resourceDetails !== "") {
      writer.uint32(26).string(message.resourceDetails);
    }
    if (message.procurementTargetStartDate !== undefined) {
      DateOnly.encode(message.procurementTargetStartDate, writer.uint32(82).fork()).join();
    }
    if (message.procurementActualStartDate !== undefined) {
      DateOnly.encode(message.procurementActualStartDate, writer.uint32(90).fork()).join();
    }
    if (message.procurementTargetDeliveryDate !== undefined) {
      DateOnly.encode(message.procurementTargetDeliveryDate, writer.uint32(98).fork()).join();
    }
    if (message.procurementActualDeliveryDate !== undefined) {
      DateOnly.encode(message.procurementActualDeliveryDate, writer.uint32(106).fork()).join();
    }
    if (message.buildTargetStartDate !== undefined) {
      DateOnly.encode(message.buildTargetStartDate, writer.uint32(114).fork()).join();
    }
    if (message.buildActualStartDate !== undefined) {
      DateOnly.encode(message.buildActualStartDate, writer.uint32(122).fork()).join();
    }
    if (message.buildTargetDeliveryDate !== undefined) {
      DateOnly.encode(message.buildTargetDeliveryDate, writer.uint32(130).fork()).join();
    }
    if (message.buildActualDeliveryDate !== undefined) {
      DateOnly.encode(message.buildActualDeliveryDate, writer.uint32(138).fork()).join();
    }
    if (message.qaTargetStartDate !== undefined) {
      DateOnly.encode(message.qaTargetStartDate, writer.uint32(146).fork()).join();
    }
    if (message.qaActualStartDate !== undefined) {
      DateOnly.encode(message.qaActualStartDate, writer.uint32(154).fork()).join();
    }
    if (message.qaTargetDeliveryDate !== undefined) {
      DateOnly.encode(message.qaTargetDeliveryDate, writer.uint32(162).fork()).join();
    }
    if (message.qaActualDeliveryDate !== undefined) {
      DateOnly.encode(message.qaActualDeliveryDate, writer.uint32(170).fork()).join();
    }
    if (message.configTargetStartDate !== undefined) {
      DateOnly.encode(message.configTargetStartDate, writer.uint32(178).fork()).join();
    }
    if (message.configActualStartDate !== undefined) {
      DateOnly.encode(message.configActualStartDate, writer.uint32(186).fork()).join();
    }
    if (message.configTargetDeliveryDate !== undefined) {
      DateOnly.encode(message.configTargetDeliveryDate, writer.uint32(194).fork()).join();
    }
    if (message.configActualDeliveryDate !== undefined) {
      DateOnly.encode(message.configActualDeliveryDate, writer.uint32(202).fork()).join();
    }
    if (message.expectedEta !== undefined) {
      DateOnly.encode(message.expectedEta, writer.uint32(66).fork()).join();
    }
    if (message.fulfillmentStatus !== undefined) {
      writer.uint32(72).int32(message.fulfillmentStatus);
    }
    if (message.materialSourcingStatus !== undefined) {
      writer.uint32(208).int32(message.materialSourcingStatus);
    }
    if (message.buildStatus !== undefined) {
      writer.uint32(216).int32(message.buildStatus);
    }
    if (message.qaStatus !== undefined) {
      writer.uint32(224).int32(message.qaStatus);
    }
    if (message.configStatus !== undefined) {
      writer.uint32(232).int32(message.configStatus);
    }
    if (message.customer !== undefined) {
      writer.uint32(242).string(message.customer);
    }
    if (message.resourceGroup !== undefined) {
      writer.uint32(250).string(message.resourceGroup);
    }
    if (message.resourceName !== undefined) {
      writer.uint32(258).string(message.resourceName);
    }
    if (message.acceptedQuantity !== undefined) {
      writer.uint32(264).int32(message.acceptedQuantity);
    }
    if (message.criticality !== undefined) {
      writer.uint32(274).string(message.criticality);
    }
    if (message.requestApproval !== undefined) {
      writer.uint32(282).string(message.requestApproval);
    }
    if (message.resourcePm !== undefined) {
      writer.uint32(290).string(message.resourcePm);
    }
    if (message.fulfillmentChannel !== undefined) {
      writer.uint32(298).string(message.fulfillmentChannel);
    }
    if (message.executionStatus !== undefined) {
      writer.uint32(306).string(message.executionStatus);
    }
    for (const v of message.resourceGroups) {
      writer.uint32(314).string(v!);
    }
    if (message.resourceRequestBugId !== undefined) {
      writer.uint32(322).string(message.resourceRequestBugId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rrId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceDetails = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.procurementTargetStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.procurementActualStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.procurementTargetDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.procurementActualDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.buildTargetStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.buildActualStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.buildTargetDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.buildActualDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.qaTargetStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.qaActualStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.qaTargetDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.qaActualDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.configTargetStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.configActualStartDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.configTargetDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.configActualDeliveryDate = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expectedEta = DateOnly.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.fulfillmentStatus = reader.int32() as any;
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.materialSourcingStatus = reader.int32() as any;
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.buildStatus = reader.int32() as any;
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.qaStatus = reader.int32() as any;
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.configStatus = reader.int32() as any;
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.customer = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.resourceGroup = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.acceptedQuantity = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.criticality = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.requestApproval = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.resourcePm = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.fulfillmentChannel = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.executionStatus = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.resourceGroups.push(reader.string());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.resourceRequestBugId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rrId: isSet(object.rrId) ? globalThis.String(object.rrId) : "",
      resourceDetails: isSet(object.resourceDetails) ? globalThis.String(object.resourceDetails) : "",
      procurementTargetStartDate: isSet(object.procurementTargetStartDate)
        ? DateOnly.fromJSON(object.procurementTargetStartDate)
        : undefined,
      procurementActualStartDate: isSet(object.procurementActualStartDate)
        ? DateOnly.fromJSON(object.procurementActualStartDate)
        : undefined,
      procurementTargetDeliveryDate: isSet(object.procurementTargetDeliveryDate)
        ? DateOnly.fromJSON(object.procurementTargetDeliveryDate)
        : undefined,
      procurementActualDeliveryDate: isSet(object.procurementActualDeliveryDate)
        ? DateOnly.fromJSON(object.procurementActualDeliveryDate)
        : undefined,
      buildTargetStartDate: isSet(object.buildTargetStartDate)
        ? DateOnly.fromJSON(object.buildTargetStartDate)
        : undefined,
      buildActualStartDate: isSet(object.buildActualStartDate)
        ? DateOnly.fromJSON(object.buildActualStartDate)
        : undefined,
      buildTargetDeliveryDate: isSet(object.buildTargetDeliveryDate)
        ? DateOnly.fromJSON(object.buildTargetDeliveryDate)
        : undefined,
      buildActualDeliveryDate: isSet(object.buildActualDeliveryDate)
        ? DateOnly.fromJSON(object.buildActualDeliveryDate)
        : undefined,
      qaTargetStartDate: isSet(object.qaTargetStartDate) ? DateOnly.fromJSON(object.qaTargetStartDate) : undefined,
      qaActualStartDate: isSet(object.qaActualStartDate) ? DateOnly.fromJSON(object.qaActualStartDate) : undefined,
      qaTargetDeliveryDate: isSet(object.qaTargetDeliveryDate)
        ? DateOnly.fromJSON(object.qaTargetDeliveryDate)
        : undefined,
      qaActualDeliveryDate: isSet(object.qaActualDeliveryDate)
        ? DateOnly.fromJSON(object.qaActualDeliveryDate)
        : undefined,
      configTargetStartDate: isSet(object.configTargetStartDate)
        ? DateOnly.fromJSON(object.configTargetStartDate)
        : undefined,
      configActualStartDate: isSet(object.configActualStartDate)
        ? DateOnly.fromJSON(object.configActualStartDate)
        : undefined,
      configTargetDeliveryDate: isSet(object.configTargetDeliveryDate)
        ? DateOnly.fromJSON(object.configTargetDeliveryDate)
        : undefined,
      configActualDeliveryDate: isSet(object.configActualDeliveryDate)
        ? DateOnly.fromJSON(object.configActualDeliveryDate)
        : undefined,
      expectedEta: isSet(object.expectedEta) ? DateOnly.fromJSON(object.expectedEta) : undefined,
      fulfillmentStatus: isSet(object.fulfillmentStatus)
        ? resourceRequest_StatusFromJSON(object.fulfillmentStatus)
        : undefined,
      materialSourcingStatus: isSet(object.materialSourcingStatus)
        ? resourceRequest_StatusFromJSON(object.materialSourcingStatus)
        : undefined,
      buildStatus: isSet(object.buildStatus) ? resourceRequest_StatusFromJSON(object.buildStatus) : undefined,
      qaStatus: isSet(object.qaStatus) ? resourceRequest_StatusFromJSON(object.qaStatus) : undefined,
      configStatus: isSet(object.configStatus) ? resourceRequest_StatusFromJSON(object.configStatus) : undefined,
      customer: isSet(object.customer) ? globalThis.String(object.customer) : undefined,
      resourceGroup: isSet(object.resourceGroup) ? globalThis.String(object.resourceGroup) : undefined,
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : undefined,
      acceptedQuantity: isSet(object.acceptedQuantity) ? globalThis.Number(object.acceptedQuantity) : undefined,
      criticality: isSet(object.criticality) ? globalThis.String(object.criticality) : undefined,
      requestApproval: isSet(object.requestApproval) ? globalThis.String(object.requestApproval) : undefined,
      resourcePm: isSet(object.resourcePm) ? globalThis.String(object.resourcePm) : undefined,
      fulfillmentChannel: isSet(object.fulfillmentChannel) ? globalThis.String(object.fulfillmentChannel) : undefined,
      executionStatus: isSet(object.executionStatus) ? globalThis.String(object.executionStatus) : undefined,
      resourceGroups: globalThis.Array.isArray(object?.resourceGroups)
        ? object.resourceGroups.map((e: any) => globalThis.String(e))
        : [],
      resourceRequestBugId: isSet(object.resourceRequestBugId)
        ? globalThis.String(object.resourceRequestBugId)
        : undefined,
    };
  },

  toJSON(message: ResourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rrId !== "") {
      obj.rrId = message.rrId;
    }
    if (message.resourceDetails !== "") {
      obj.resourceDetails = message.resourceDetails;
    }
    if (message.procurementTargetStartDate !== undefined) {
      obj.procurementTargetStartDate = DateOnly.toJSON(message.procurementTargetStartDate);
    }
    if (message.procurementActualStartDate !== undefined) {
      obj.procurementActualStartDate = DateOnly.toJSON(message.procurementActualStartDate);
    }
    if (message.procurementTargetDeliveryDate !== undefined) {
      obj.procurementTargetDeliveryDate = DateOnly.toJSON(message.procurementTargetDeliveryDate);
    }
    if (message.procurementActualDeliveryDate !== undefined) {
      obj.procurementActualDeliveryDate = DateOnly.toJSON(message.procurementActualDeliveryDate);
    }
    if (message.buildTargetStartDate !== undefined) {
      obj.buildTargetStartDate = DateOnly.toJSON(message.buildTargetStartDate);
    }
    if (message.buildActualStartDate !== undefined) {
      obj.buildActualStartDate = DateOnly.toJSON(message.buildActualStartDate);
    }
    if (message.buildTargetDeliveryDate !== undefined) {
      obj.buildTargetDeliveryDate = DateOnly.toJSON(message.buildTargetDeliveryDate);
    }
    if (message.buildActualDeliveryDate !== undefined) {
      obj.buildActualDeliveryDate = DateOnly.toJSON(message.buildActualDeliveryDate);
    }
    if (message.qaTargetStartDate !== undefined) {
      obj.qaTargetStartDate = DateOnly.toJSON(message.qaTargetStartDate);
    }
    if (message.qaActualStartDate !== undefined) {
      obj.qaActualStartDate = DateOnly.toJSON(message.qaActualStartDate);
    }
    if (message.qaTargetDeliveryDate !== undefined) {
      obj.qaTargetDeliveryDate = DateOnly.toJSON(message.qaTargetDeliveryDate);
    }
    if (message.qaActualDeliveryDate !== undefined) {
      obj.qaActualDeliveryDate = DateOnly.toJSON(message.qaActualDeliveryDate);
    }
    if (message.configTargetStartDate !== undefined) {
      obj.configTargetStartDate = DateOnly.toJSON(message.configTargetStartDate);
    }
    if (message.configActualStartDate !== undefined) {
      obj.configActualStartDate = DateOnly.toJSON(message.configActualStartDate);
    }
    if (message.configTargetDeliveryDate !== undefined) {
      obj.configTargetDeliveryDate = DateOnly.toJSON(message.configTargetDeliveryDate);
    }
    if (message.configActualDeliveryDate !== undefined) {
      obj.configActualDeliveryDate = DateOnly.toJSON(message.configActualDeliveryDate);
    }
    if (message.expectedEta !== undefined) {
      obj.expectedEta = DateOnly.toJSON(message.expectedEta);
    }
    if (message.fulfillmentStatus !== undefined) {
      obj.fulfillmentStatus = resourceRequest_StatusToJSON(message.fulfillmentStatus);
    }
    if (message.materialSourcingStatus !== undefined) {
      obj.materialSourcingStatus = resourceRequest_StatusToJSON(message.materialSourcingStatus);
    }
    if (message.buildStatus !== undefined) {
      obj.buildStatus = resourceRequest_StatusToJSON(message.buildStatus);
    }
    if (message.qaStatus !== undefined) {
      obj.qaStatus = resourceRequest_StatusToJSON(message.qaStatus);
    }
    if (message.configStatus !== undefined) {
      obj.configStatus = resourceRequest_StatusToJSON(message.configStatus);
    }
    if (message.customer !== undefined) {
      obj.customer = message.customer;
    }
    if (message.resourceGroup !== undefined) {
      obj.resourceGroup = message.resourceGroup;
    }
    if (message.resourceName !== undefined) {
      obj.resourceName = message.resourceName;
    }
    if (message.acceptedQuantity !== undefined) {
      obj.acceptedQuantity = Math.round(message.acceptedQuantity);
    }
    if (message.criticality !== undefined) {
      obj.criticality = message.criticality;
    }
    if (message.requestApproval !== undefined) {
      obj.requestApproval = message.requestApproval;
    }
    if (message.resourcePm !== undefined) {
      obj.resourcePm = message.resourcePm;
    }
    if (message.fulfillmentChannel !== undefined) {
      obj.fulfillmentChannel = message.fulfillmentChannel;
    }
    if (message.executionStatus !== undefined) {
      obj.executionStatus = message.executionStatus;
    }
    if (message.resourceGroups?.length) {
      obj.resourceGroups = message.resourceGroups;
    }
    if (message.resourceRequestBugId !== undefined) {
      obj.resourceRequestBugId = message.resourceRequestBugId;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceRequest>): ResourceRequest {
    return ResourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceRequest>): ResourceRequest {
    const message = createBaseResourceRequest() as any;
    message.name = object.name ?? "";
    message.rrId = object.rrId ?? "";
    message.resourceDetails = object.resourceDetails ?? "";
    message.procurementTargetStartDate =
      (object.procurementTargetStartDate !== undefined && object.procurementTargetStartDate !== null)
        ? DateOnly.fromPartial(object.procurementTargetStartDate)
        : undefined;
    message.procurementActualStartDate =
      (object.procurementActualStartDate !== undefined && object.procurementActualStartDate !== null)
        ? DateOnly.fromPartial(object.procurementActualStartDate)
        : undefined;
    message.procurementTargetDeliveryDate =
      (object.procurementTargetDeliveryDate !== undefined && object.procurementTargetDeliveryDate !== null)
        ? DateOnly.fromPartial(object.procurementTargetDeliveryDate)
        : undefined;
    message.procurementActualDeliveryDate =
      (object.procurementActualDeliveryDate !== undefined && object.procurementActualDeliveryDate !== null)
        ? DateOnly.fromPartial(object.procurementActualDeliveryDate)
        : undefined;
    message.buildTargetStartDate = (object.buildTargetStartDate !== undefined && object.buildTargetStartDate !== null)
      ? DateOnly.fromPartial(object.buildTargetStartDate)
      : undefined;
    message.buildActualStartDate = (object.buildActualStartDate !== undefined && object.buildActualStartDate !== null)
      ? DateOnly.fromPartial(object.buildActualStartDate)
      : undefined;
    message.buildTargetDeliveryDate =
      (object.buildTargetDeliveryDate !== undefined && object.buildTargetDeliveryDate !== null)
        ? DateOnly.fromPartial(object.buildTargetDeliveryDate)
        : undefined;
    message.buildActualDeliveryDate =
      (object.buildActualDeliveryDate !== undefined && object.buildActualDeliveryDate !== null)
        ? DateOnly.fromPartial(object.buildActualDeliveryDate)
        : undefined;
    message.qaTargetStartDate = (object.qaTargetStartDate !== undefined && object.qaTargetStartDate !== null)
      ? DateOnly.fromPartial(object.qaTargetStartDate)
      : undefined;
    message.qaActualStartDate = (object.qaActualStartDate !== undefined && object.qaActualStartDate !== null)
      ? DateOnly.fromPartial(object.qaActualStartDate)
      : undefined;
    message.qaTargetDeliveryDate = (object.qaTargetDeliveryDate !== undefined && object.qaTargetDeliveryDate !== null)
      ? DateOnly.fromPartial(object.qaTargetDeliveryDate)
      : undefined;
    message.qaActualDeliveryDate = (object.qaActualDeliveryDate !== undefined && object.qaActualDeliveryDate !== null)
      ? DateOnly.fromPartial(object.qaActualDeliveryDate)
      : undefined;
    message.configTargetStartDate =
      (object.configTargetStartDate !== undefined && object.configTargetStartDate !== null)
        ? DateOnly.fromPartial(object.configTargetStartDate)
        : undefined;
    message.configActualStartDate =
      (object.configActualStartDate !== undefined && object.configActualStartDate !== null)
        ? DateOnly.fromPartial(object.configActualStartDate)
        : undefined;
    message.configTargetDeliveryDate =
      (object.configTargetDeliveryDate !== undefined && object.configTargetDeliveryDate !== null)
        ? DateOnly.fromPartial(object.configTargetDeliveryDate)
        : undefined;
    message.configActualDeliveryDate =
      (object.configActualDeliveryDate !== undefined && object.configActualDeliveryDate !== null)
        ? DateOnly.fromPartial(object.configActualDeliveryDate)
        : undefined;
    message.expectedEta = (object.expectedEta !== undefined && object.expectedEta !== null)
      ? DateOnly.fromPartial(object.expectedEta)
      : undefined;
    message.fulfillmentStatus = object.fulfillmentStatus ?? undefined;
    message.materialSourcingStatus = object.materialSourcingStatus ?? undefined;
    message.buildStatus = object.buildStatus ?? undefined;
    message.qaStatus = object.qaStatus ?? undefined;
    message.configStatus = object.configStatus ?? undefined;
    message.customer = object.customer ?? undefined;
    message.resourceGroup = object.resourceGroup ?? undefined;
    message.resourceName = object.resourceName ?? undefined;
    message.acceptedQuantity = object.acceptedQuantity ?? undefined;
    message.criticality = object.criticality ?? undefined;
    message.requestApproval = object.requestApproval ?? undefined;
    message.resourcePm = object.resourcePm ?? undefined;
    message.fulfillmentChannel = object.fulfillmentChannel ?? undefined;
    message.executionStatus = object.executionStatus ?? undefined;
    message.resourceGroups = object.resourceGroups?.map((e) => e) || [];
    message.resourceRequestBugId = object.resourceRequestBugId ?? undefined;
    return message;
  },
};

function createBaseCountResourceRequestsRequest(): CountResourceRequestsRequest {
  return { filter: "" };
}

export const CountResourceRequestsRequest: MessageFns<CountResourceRequestsRequest> = {
  encode(message: CountResourceRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountResourceRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountResourceRequestsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountResourceRequestsRequest {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: CountResourceRequestsRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<CountResourceRequestsRequest>): CountResourceRequestsRequest {
    return CountResourceRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountResourceRequestsRequest>): CountResourceRequestsRequest {
    const message = createBaseCountResourceRequestsRequest() as any;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseCountResourceRequestsResponse(): CountResourceRequestsResponse {
  return { total: 0, inProgress: 0, completed: 0, materialSourcing: 0, build: 0, qa: 0, config: 0 };
}

export const CountResourceRequestsResponse: MessageFns<CountResourceRequestsResponse> = {
  encode(message: CountResourceRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.inProgress !== 0) {
      writer.uint32(16).int32(message.inProgress);
    }
    if (message.completed !== 0) {
      writer.uint32(24).int32(message.completed);
    }
    if (message.materialSourcing !== 0) {
      writer.uint32(32).int32(message.materialSourcing);
    }
    if (message.build !== 0) {
      writer.uint32(40).int32(message.build);
    }
    if (message.qa !== 0) {
      writer.uint32(48).int32(message.qa);
    }
    if (message.config !== 0) {
      writer.uint32(56).int32(message.config);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountResourceRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountResourceRequestsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inProgress = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.completed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.materialSourcing = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.build = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.qa = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.config = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountResourceRequestsResponse {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      inProgress: isSet(object.inProgress) ? globalThis.Number(object.inProgress) : 0,
      completed: isSet(object.completed) ? globalThis.Number(object.completed) : 0,
      materialSourcing: isSet(object.materialSourcing) ? globalThis.Number(object.materialSourcing) : 0,
      build: isSet(object.build) ? globalThis.Number(object.build) : 0,
      qa: isSet(object.qa) ? globalThis.Number(object.qa) : 0,
      config: isSet(object.config) ? globalThis.Number(object.config) : 0,
    };
  },

  toJSON(message: CountResourceRequestsResponse): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.inProgress !== 0) {
      obj.inProgress = Math.round(message.inProgress);
    }
    if (message.completed !== 0) {
      obj.completed = Math.round(message.completed);
    }
    if (message.materialSourcing !== 0) {
      obj.materialSourcing = Math.round(message.materialSourcing);
    }
    if (message.build !== 0) {
      obj.build = Math.round(message.build);
    }
    if (message.qa !== 0) {
      obj.qa = Math.round(message.qa);
    }
    if (message.config !== 0) {
      obj.config = Math.round(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<CountResourceRequestsResponse>): CountResourceRequestsResponse {
    return CountResourceRequestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountResourceRequestsResponse>): CountResourceRequestsResponse {
    const message = createBaseCountResourceRequestsResponse() as any;
    message.total = object.total ?? 0;
    message.inProgress = object.inProgress ?? 0;
    message.completed = object.completed ?? 0;
    message.materialSourcing = object.materialSourcing ?? 0;
    message.build = object.build ?? 0;
    message.qa = object.qa ?? 0;
    message.config = object.config ?? 0;
    return message;
  },
};

function createBaseGetResourceRequestsMultiselectFilterValuesRequest(): GetResourceRequestsMultiselectFilterValuesRequest {
  return {};
}

export const GetResourceRequestsMultiselectFilterValuesRequest: MessageFns<
  GetResourceRequestsMultiselectFilterValuesRequest
> = {
  encode(
    _: GetResourceRequestsMultiselectFilterValuesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceRequestsMultiselectFilterValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceRequestsMultiselectFilterValuesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetResourceRequestsMultiselectFilterValuesRequest {
    return {};
  },

  toJSON(_: GetResourceRequestsMultiselectFilterValuesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<GetResourceRequestsMultiselectFilterValuesRequest>,
  ): GetResourceRequestsMultiselectFilterValuesRequest {
    return GetResourceRequestsMultiselectFilterValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<GetResourceRequestsMultiselectFilterValuesRequest>,
  ): GetResourceRequestsMultiselectFilterValuesRequest {
    const message = createBaseGetResourceRequestsMultiselectFilterValuesRequest() as any;
    return message;
  },
};

function createBaseGetResourceRequestsMultiselectFilterValuesResponse(): GetResourceRequestsMultiselectFilterValuesResponse {
  return {
    rrIds: [],
    resourceDetails: [],
    materialSourcingStatus: [],
    buildStatus: [],
    qaStatus: [],
    configStatus: [],
    customer: [],
    resourceName: [],
    acceptedQuantity: [],
    criticality: [],
    requestApproval: [],
    resourcePm: [],
    fulfillmentChannel: [],
    executionStatus: [],
    resourceGroups: [],
  };
}

export const GetResourceRequestsMultiselectFilterValuesResponse: MessageFns<
  GetResourceRequestsMultiselectFilterValuesResponse
> = {
  encode(
    message: GetResourceRequestsMultiselectFilterValuesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.rrIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.resourceDetails) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.materialSourcingStatus) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.buildStatus) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.qaStatus) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.configStatus) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.customer) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.resourceName) {
      writer.uint32(66).string(v!);
    }
    writer.uint32(74).fork();
    for (const v of message.acceptedQuantity) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.criticality) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.requestApproval) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.resourcePm) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.fulfillmentChannel) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.executionStatus) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.resourceGroups) {
      writer.uint32(122).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResourceRequestsMultiselectFilterValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourceRequestsMultiselectFilterValuesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rrIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceDetails.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.materialSourcingStatus.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buildStatus.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.qaStatus.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.configStatus.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customer.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resourceName.push(reader.string());
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.acceptedQuantity.push(reader.int32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.acceptedQuantity.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.criticality.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.requestApproval.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.resourcePm.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.fulfillmentChannel.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.executionStatus.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.resourceGroups.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResourceRequestsMultiselectFilterValuesResponse {
    return {
      rrIds: globalThis.Array.isArray(object?.rrIds) ? object.rrIds.map((e: any) => globalThis.String(e)) : [],
      resourceDetails: globalThis.Array.isArray(object?.resourceDetails)
        ? object.resourceDetails.map((e: any) => globalThis.String(e))
        : [],
      materialSourcingStatus: globalThis.Array.isArray(object?.materialSourcingStatus)
        ? object.materialSourcingStatus.map((e: any) => globalThis.String(e))
        : [],
      buildStatus: globalThis.Array.isArray(object?.buildStatus)
        ? object.buildStatus.map((e: any) => globalThis.String(e))
        : [],
      qaStatus: globalThis.Array.isArray(object?.qaStatus) ? object.qaStatus.map((e: any) => globalThis.String(e)) : [],
      configStatus: globalThis.Array.isArray(object?.configStatus)
        ? object.configStatus.map((e: any) => globalThis.String(e))
        : [],
      customer: globalThis.Array.isArray(object?.customer) ? object.customer.map((e: any) => globalThis.String(e)) : [],
      resourceName: globalThis.Array.isArray(object?.resourceName)
        ? object.resourceName.map((e: any) => globalThis.String(e))
        : [],
      acceptedQuantity: globalThis.Array.isArray(object?.acceptedQuantity)
        ? object.acceptedQuantity.map((e: any) => globalThis.Number(e))
        : [],
      criticality: globalThis.Array.isArray(object?.criticality)
        ? object.criticality.map((e: any) => globalThis.String(e))
        : [],
      requestApproval: globalThis.Array.isArray(object?.requestApproval)
        ? object.requestApproval.map((e: any) => globalThis.String(e))
        : [],
      resourcePm: globalThis.Array.isArray(object?.resourcePm)
        ? object.resourcePm.map((e: any) => globalThis.String(e))
        : [],
      fulfillmentChannel: globalThis.Array.isArray(object?.fulfillmentChannel)
        ? object.fulfillmentChannel.map((e: any) => globalThis.String(e))
        : [],
      executionStatus: globalThis.Array.isArray(object?.executionStatus)
        ? object.executionStatus.map((e: any) => globalThis.String(e))
        : [],
      resourceGroups: globalThis.Array.isArray(object?.resourceGroups)
        ? object.resourceGroups.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetResourceRequestsMultiselectFilterValuesResponse): unknown {
    const obj: any = {};
    if (message.rrIds?.length) {
      obj.rrIds = message.rrIds;
    }
    if (message.resourceDetails?.length) {
      obj.resourceDetails = message.resourceDetails;
    }
    if (message.materialSourcingStatus?.length) {
      obj.materialSourcingStatus = message.materialSourcingStatus;
    }
    if (message.buildStatus?.length) {
      obj.buildStatus = message.buildStatus;
    }
    if (message.qaStatus?.length) {
      obj.qaStatus = message.qaStatus;
    }
    if (message.configStatus?.length) {
      obj.configStatus = message.configStatus;
    }
    if (message.customer?.length) {
      obj.customer = message.customer;
    }
    if (message.resourceName?.length) {
      obj.resourceName = message.resourceName;
    }
    if (message.acceptedQuantity?.length) {
      obj.acceptedQuantity = message.acceptedQuantity.map((e) => Math.round(e));
    }
    if (message.criticality?.length) {
      obj.criticality = message.criticality;
    }
    if (message.requestApproval?.length) {
      obj.requestApproval = message.requestApproval;
    }
    if (message.resourcePm?.length) {
      obj.resourcePm = message.resourcePm;
    }
    if (message.fulfillmentChannel?.length) {
      obj.fulfillmentChannel = message.fulfillmentChannel;
    }
    if (message.executionStatus?.length) {
      obj.executionStatus = message.executionStatus;
    }
    if (message.resourceGroups?.length) {
      obj.resourceGroups = message.resourceGroups;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetResourceRequestsMultiselectFilterValuesResponse>,
  ): GetResourceRequestsMultiselectFilterValuesResponse {
    return GetResourceRequestsMultiselectFilterValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetResourceRequestsMultiselectFilterValuesResponse>,
  ): GetResourceRequestsMultiselectFilterValuesResponse {
    const message = createBaseGetResourceRequestsMultiselectFilterValuesResponse() as any;
    message.rrIds = object.rrIds?.map((e) => e) || [];
    message.resourceDetails = object.resourceDetails?.map((e) => e) || [];
    message.materialSourcingStatus = object.materialSourcingStatus?.map((e) => e) || [];
    message.buildStatus = object.buildStatus?.map((e) => e) || [];
    message.qaStatus = object.qaStatus?.map((e) => e) || [];
    message.configStatus = object.configStatus?.map((e) => e) || [];
    message.customer = object.customer?.map((e) => e) || [];
    message.resourceName = object.resourceName?.map((e) => e) || [];
    message.acceptedQuantity = object.acceptedQuantity?.map((e) => e) || [];
    message.criticality = object.criticality?.map((e) => e) || [];
    message.requestApproval = object.requestApproval?.map((e) => e) || [];
    message.resourcePm = object.resourcePm?.map((e) => e) || [];
    message.fulfillmentChannel = object.fulfillmentChannel?.map((e) => e) || [];
    message.executionStatus = object.executionStatus?.map((e) => e) || [];
    message.resourceGroups = object.resourceGroups?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateAndroidDevicesRequest(): UpdateAndroidDevicesRequest {
  return { host: undefined };
}

export const UpdateAndroidDevicesRequest: MessageFns<UpdateAndroidDevicesRequest> = {
  encode(message: UpdateAndroidDevicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== undefined) {
      MonitoredRecord.encode(message.host, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAndroidDevicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAndroidDevicesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = MonitoredRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAndroidDevicesRequest {
    return { host: isSet(object.host) ? MonitoredRecord.fromJSON(object.host) : undefined };
  },

  toJSON(message: UpdateAndroidDevicesRequest): unknown {
    const obj: any = {};
    if (message.host !== undefined) {
      obj.host = MonitoredRecord.toJSON(message.host);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAndroidDevicesRequest>): UpdateAndroidDevicesRequest {
    return UpdateAndroidDevicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAndroidDevicesRequest>): UpdateAndroidDevicesRequest {
    const message = createBaseUpdateAndroidDevicesRequest() as any;
    message.host = (object.host !== undefined && object.host !== null)
      ? MonitoredRecord.fromPartial(object.host)
      : undefined;
    return message;
  },
};

function createBaseUpdateAndroidDevicesResponse(): UpdateAndroidDevicesResponse {
  return {};
}

export const UpdateAndroidDevicesResponse: MessageFns<UpdateAndroidDevicesResponse> = {
  encode(_: UpdateAndroidDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAndroidDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAndroidDevicesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateAndroidDevicesResponse {
    return {};
  },

  toJSON(_: UpdateAndroidDevicesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateAndroidDevicesResponse>): UpdateAndroidDevicesResponse {
    return UpdateAndroidDevicesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateAndroidDevicesResponse>): UpdateAndroidDevicesResponse {
    const message = createBaseUpdateAndroidDevicesResponse() as any;
    return message;
  },
};

function createBaseListRepairMetricsRequest(): ListRepairMetricsRequest {
  return { platform: 0, pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListRepairMetricsRequest: MessageFns<ListRepairMetricsRequest> = {
  encode(message: ListRepairMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepairMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepairMetricsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepairMetricsRequest {
    return {
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRepairMetricsRequest): unknown {
    const obj: any = {};
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepairMetricsRequest>): ListRepairMetricsRequest {
    return ListRepairMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepairMetricsRequest>): ListRepairMetricsRequest {
    const message = createBaseListRepairMetricsRequest() as any;
    message.platform = object.platform ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseRepairMetric(): RepairMetric {
  return {
    priority: 0,
    labName: "",
    hostGroup: "",
    runTarget: "",
    minimumRepairs: 0,
    devicesOffline: 0,
    totalDevices: 0,
  };
}

export const RepairMetric: MessageFns<RepairMetric> = {
  encode(message: RepairMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priority !== 0) {
      writer.uint32(8).int32(message.priority);
    }
    if (message.labName !== "") {
      writer.uint32(18).string(message.labName);
    }
    if (message.hostGroup !== "") {
      writer.uint32(26).string(message.hostGroup);
    }
    if (message.runTarget !== "") {
      writer.uint32(34).string(message.runTarget);
    }
    if (message.minimumRepairs !== 0) {
      writer.uint32(40).int32(message.minimumRepairs);
    }
    if (message.devicesOffline !== 0) {
      writer.uint32(48).int32(message.devicesOffline);
    }
    if (message.totalDevices !== 0) {
      writer.uint32(56).int32(message.totalDevices);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairMetric() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hostGroup = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runTarget = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.minimumRepairs = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.devicesOffline = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalDevices = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairMetric {
    return {
      priority: isSet(object.priority) ? repairMetric_PriorityFromJSON(object.priority) : 0,
      labName: isSet(object.labName) ? globalThis.String(object.labName) : "",
      hostGroup: isSet(object.hostGroup) ? globalThis.String(object.hostGroup) : "",
      runTarget: isSet(object.runTarget) ? globalThis.String(object.runTarget) : "",
      minimumRepairs: isSet(object.minimumRepairs) ? globalThis.Number(object.minimumRepairs) : 0,
      devicesOffline: isSet(object.devicesOffline) ? globalThis.Number(object.devicesOffline) : 0,
      totalDevices: isSet(object.totalDevices) ? globalThis.Number(object.totalDevices) : 0,
    };
  },

  toJSON(message: RepairMetric): unknown {
    const obj: any = {};
    if (message.priority !== 0) {
      obj.priority = repairMetric_PriorityToJSON(message.priority);
    }
    if (message.labName !== "") {
      obj.labName = message.labName;
    }
    if (message.hostGroup !== "") {
      obj.hostGroup = message.hostGroup;
    }
    if (message.runTarget !== "") {
      obj.runTarget = message.runTarget;
    }
    if (message.minimumRepairs !== 0) {
      obj.minimumRepairs = Math.round(message.minimumRepairs);
    }
    if (message.devicesOffline !== 0) {
      obj.devicesOffline = Math.round(message.devicesOffline);
    }
    if (message.totalDevices !== 0) {
      obj.totalDevices = Math.round(message.totalDevices);
    }
    return obj;
  },

  create(base?: DeepPartial<RepairMetric>): RepairMetric {
    return RepairMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairMetric>): RepairMetric {
    const message = createBaseRepairMetric() as any;
    message.priority = object.priority ?? 0;
    message.labName = object.labName ?? "";
    message.hostGroup = object.hostGroup ?? "";
    message.runTarget = object.runTarget ?? "";
    message.minimumRepairs = object.minimumRepairs ?? 0;
    message.devicesOffline = object.devicesOffline ?? 0;
    message.totalDevices = object.totalDevices ?? 0;
    return message;
  },
};

function createBaseListRepairMetricsResponse(): ListRepairMetricsResponse {
  return { repairMetrics: [], nextPageToken: "" };
}

export const ListRepairMetricsResponse: MessageFns<ListRepairMetricsResponse> = {
  encode(message: ListRepairMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.repairMetrics) {
      RepairMetric.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRepairMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRepairMetricsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repairMetrics.push(RepairMetric.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRepairMetricsResponse {
    return {
      repairMetrics: globalThis.Array.isArray(object?.repairMetrics)
        ? object.repairMetrics.map((e: any) => RepairMetric.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRepairMetricsResponse): unknown {
    const obj: any = {};
    if (message.repairMetrics?.length) {
      obj.repairMetrics = message.repairMetrics.map((e) => RepairMetric.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRepairMetricsResponse>): ListRepairMetricsResponse {
    return ListRepairMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRepairMetricsResponse>): ListRepairMetricsResponse {
    const message = createBaseListRepairMetricsResponse() as any;
    message.repairMetrics = object.repairMetrics?.map((e) => RepairMetric.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCountRepairMetricsRequest(): CountRepairMetricsRequest {
  return { platform: 0, filter: "" };
}

export const CountRepairMetricsRequest: MessageFns<CountRepairMetricsRequest> = {
  encode(message: CountRepairMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountRepairMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountRepairMetricsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountRepairMetricsRequest {
    return {
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: CountRepairMetricsRequest): unknown {
    const obj: any = {};
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<CountRepairMetricsRequest>): CountRepairMetricsRequest {
    return CountRepairMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountRepairMetricsRequest>): CountRepairMetricsRequest {
    const message = createBaseCountRepairMetricsRequest() as any;
    message.platform = object.platform ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseCountRepairMetricsResponse(): CountRepairMetricsResponse {
  return { totalHosts: 0, offlineHosts: 0, totalDevices: 0, offlineDevices: 0 };
}

export const CountRepairMetricsResponse: MessageFns<CountRepairMetricsResponse> = {
  encode(message: CountRepairMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalHosts !== 0) {
      writer.uint32(8).int32(message.totalHosts);
    }
    if (message.offlineHosts !== 0) {
      writer.uint32(16).int32(message.offlineHosts);
    }
    if (message.totalDevices !== 0) {
      writer.uint32(24).int32(message.totalDevices);
    }
    if (message.offlineDevices !== 0) {
      writer.uint32(32).int32(message.offlineDevices);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountRepairMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountRepairMetricsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalHosts = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offlineHosts = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalDevices = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offlineDevices = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountRepairMetricsResponse {
    return {
      totalHosts: isSet(object.totalHosts) ? globalThis.Number(object.totalHosts) : 0,
      offlineHosts: isSet(object.offlineHosts) ? globalThis.Number(object.offlineHosts) : 0,
      totalDevices: isSet(object.totalDevices) ? globalThis.Number(object.totalDevices) : 0,
      offlineDevices: isSet(object.offlineDevices) ? globalThis.Number(object.offlineDevices) : 0,
    };
  },

  toJSON(message: CountRepairMetricsResponse): unknown {
    const obj: any = {};
    if (message.totalHosts !== 0) {
      obj.totalHosts = Math.round(message.totalHosts);
    }
    if (message.offlineHosts !== 0) {
      obj.offlineHosts = Math.round(message.offlineHosts);
    }
    if (message.totalDevices !== 0) {
      obj.totalDevices = Math.round(message.totalDevices);
    }
    if (message.offlineDevices !== 0) {
      obj.offlineDevices = Math.round(message.offlineDevices);
    }
    return obj;
  },

  create(base?: DeepPartial<CountRepairMetricsResponse>): CountRepairMetricsResponse {
    return CountRepairMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountRepairMetricsResponse>): CountRepairMetricsResponse {
    const message = createBaseCountRepairMetricsResponse() as any;
    message.totalHosts = object.totalHosts ?? 0;
    message.offlineHosts = object.offlineHosts ?? 0;
    message.totalDevices = object.totalDevices ?? 0;
    message.offlineDevices = object.offlineDevices ?? 0;
    return message;
  },
};

function createBaseGetRepairMetricsDimensionsRequest(): GetRepairMetricsDimensionsRequest {
  return { platform: 0 };
}

export const GetRepairMetricsDimensionsRequest: MessageFns<GetRepairMetricsDimensionsRequest> = {
  encode(message: GetRepairMetricsDimensionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepairMetricsDimensionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepairMetricsDimensionsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepairMetricsDimensionsRequest {
    return { platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0 };
  },

  toJSON(message: GetRepairMetricsDimensionsRequest): unknown {
    const obj: any = {};
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRepairMetricsDimensionsRequest>): GetRepairMetricsDimensionsRequest {
    return GetRepairMetricsDimensionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRepairMetricsDimensionsRequest>): GetRepairMetricsDimensionsRequest {
    const message = createBaseGetRepairMetricsDimensionsRequest() as any;
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseGetRepairMetricsDimensionsResponse(): GetRepairMetricsDimensionsResponse {
  return { dimensions: {} };
}

export const GetRepairMetricsDimensionsResponse: MessageFns<GetRepairMetricsDimensionsResponse> = {
  encode(message: GetRepairMetricsDimensionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.dimensions).forEach(([key, value]) => {
      GetRepairMetricsDimensionsResponse_DimensionsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepairMetricsDimensionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepairMetricsDimensionsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetRepairMetricsDimensionsResponse_DimensionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.dimensions[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepairMetricsDimensionsResponse {
    return {
      dimensions: isObject(object.dimensions)
        ? Object.entries(object.dimensions).reduce<{ [key: string]: GetRepairMetricsDimensionsResponse_Values }>(
          (acc, [key, value]) => {
            acc[key] = GetRepairMetricsDimensionsResponse_Values.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetRepairMetricsDimensionsResponse): unknown {
    const obj: any = {};
    if (message.dimensions) {
      const entries = Object.entries(message.dimensions);
      if (entries.length > 0) {
        obj.dimensions = {};
        entries.forEach(([k, v]) => {
          obj.dimensions[k] = GetRepairMetricsDimensionsResponse_Values.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetRepairMetricsDimensionsResponse>): GetRepairMetricsDimensionsResponse {
    return GetRepairMetricsDimensionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRepairMetricsDimensionsResponse>): GetRepairMetricsDimensionsResponse {
    const message = createBaseGetRepairMetricsDimensionsResponse() as any;
    message.dimensions = Object.entries(object.dimensions ?? {}).reduce<
      { [key: string]: GetRepairMetricsDimensionsResponse_Values }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = GetRepairMetricsDimensionsResponse_Values.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetRepairMetricsDimensionsResponse_Values(): GetRepairMetricsDimensionsResponse_Values {
  return { values: [] };
}

export const GetRepairMetricsDimensionsResponse_Values: MessageFns<GetRepairMetricsDimensionsResponse_Values> = {
  encode(message: GetRepairMetricsDimensionsResponse_Values, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepairMetricsDimensionsResponse_Values {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepairMetricsDimensionsResponse_Values() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepairMetricsDimensionsResponse_Values {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetRepairMetricsDimensionsResponse_Values): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRepairMetricsDimensionsResponse_Values>): GetRepairMetricsDimensionsResponse_Values {
    return GetRepairMetricsDimensionsResponse_Values.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetRepairMetricsDimensionsResponse_Values>,
  ): GetRepairMetricsDimensionsResponse_Values {
    const message = createBaseGetRepairMetricsDimensionsResponse_Values() as any;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRepairMetricsDimensionsResponse_DimensionsEntry(): GetRepairMetricsDimensionsResponse_DimensionsEntry {
  return { key: "", value: undefined };
}

export const GetRepairMetricsDimensionsResponse_DimensionsEntry: MessageFns<
  GetRepairMetricsDimensionsResponse_DimensionsEntry
> = {
  encode(
    message: GetRepairMetricsDimensionsResponse_DimensionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GetRepairMetricsDimensionsResponse_Values.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepairMetricsDimensionsResponse_DimensionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepairMetricsDimensionsResponse_DimensionsEntry() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = GetRepairMetricsDimensionsResponse_Values.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepairMetricsDimensionsResponse_DimensionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GetRepairMetricsDimensionsResponse_Values.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetRepairMetricsDimensionsResponse_DimensionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GetRepairMetricsDimensionsResponse_Values.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetRepairMetricsDimensionsResponse_DimensionsEntry>,
  ): GetRepairMetricsDimensionsResponse_DimensionsEntry {
    return GetRepairMetricsDimensionsResponse_DimensionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetRepairMetricsDimensionsResponse_DimensionsEntry>,
  ): GetRepairMetricsDimensionsResponse_DimensionsEntry {
    const message = createBaseGetRepairMetricsDimensionsResponse_DimensionsEntry() as any;
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GetRepairMetricsDimensionsResponse_Values.fromPartial(object.value)
      : undefined;
    return message;
  },
};

export interface FleetConsole {
  /** Ping does not send or receive any information. It just checks that the service is there. */
  Ping(request: PingRequest): Promise<PingResponse>;
  /** PingBigQuery attempts to contact BigQuery service through Fleet Console. Useful for debugging. */
  PingBigQuery(request: PingBigQueryRequest): Promise<PingBigQueryResponse>;
  /** PingDeviceManager attempts to contact DeviceManager through Fleet Console. Useful for debugging. */
  PingDeviceManager(request: PingDeviceManagerRequest): Promise<PingDeviceManagerResponse>;
  /** PingUfs attempts to contact UFS through Fleet Console. Useful for debugging. */
  PingUfs(request: PingUfsRequest): Promise<PingUfsResponse>;
  /** LogFrontend used to collect logs from the frontend */
  LogFrontend(request: LogFrontendRequest): Promise<LogFrontendResponse>;
  /** ListDevices managed by Device Manager. */
  ListDevices(request: ListDevicesRequest): Promise<ListDevicesResponse>;
  /** GetDeviceDimensions provides overview of devices dimensions and their values */
  GetDeviceDimensions(request: Empty): Promise<GetDeviceDimensionsResponse>;
  /** CountDevices provides a count of the devices */
  CountDevices(request: CountDevicesRequest): Promise<CountDevicesResponse>;
  /** RepopulateCache repopulates the cache, meant to be triggered by cron. */
  RepopulateCache(request: RepopulateCacheRequest): Promise<RepopulateCacheResponse>;
  /** PingDB attempts to establish contact with the database and does nothing else. */
  PingDB(request: PingDBRequest): Promise<PingDBResponse>;
  /** CleanExit just exits the current process. */
  CleanExit(request: CleanExitRequest): Promise<CleanExitResponse>;
  /** ExportDevicesToCSV exports the devices in the csv format. */
  ExportDevicesToCSV(request: ExportDevicesToCSVRequest): Promise<ExportDevicesToCSVResponse>;
  /** ListResourceRequests returns Resource Requests provided by BigQuery */
  ListResourceRequests(request: ListResourceRequestsRequest): Promise<ListResourceRequestsResponse>;
  /** CountResourceRequests provides counts for RRI summary header */
  CountResourceRequests(request: CountResourceRequestsRequest): Promise<CountResourceRequestsResponse>;
  /** CountResourceRequests provides counts for RRI summary header */
  GetResourceRequestsMultiselectFilterValues(
    request: GetResourceRequestsMultiselectFilterValuesRequest,
  ): Promise<GetResourceRequestsMultiselectFilterValuesResponse>;
  /**
   * ************* REPAIR METRICS *********************
   * UpdateAndroidDevices updates the android devices in the database.
   * Used to test the pubsub message.
   */
  UpdateAndroidDevices(request: UpdateAndroidDevicesRequest): Promise<UpdateAndroidDevicesResponse>;
  ListRepairMetrics(request: ListRepairMetricsRequest): Promise<ListRepairMetricsResponse>;
  CountRepairMetrics(request: CountRepairMetricsRequest): Promise<CountRepairMetricsResponse>;
  GetRepairMetricsDimensions(request: GetRepairMetricsDimensionsRequest): Promise<GetRepairMetricsDimensionsResponse>;
}

export const FleetConsoleServiceName = "fleetconsole.FleetConsole";
export class FleetConsoleClientImpl implements FleetConsole {
  static readonly DEFAULT_SERVICE = FleetConsoleServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || FleetConsoleServiceName;
    this.rpc = rpc;
    this.Ping = this.Ping.bind(this);
    this.PingBigQuery = this.PingBigQuery.bind(this);
    this.PingDeviceManager = this.PingDeviceManager.bind(this);
    this.PingUfs = this.PingUfs.bind(this);
    this.LogFrontend = this.LogFrontend.bind(this);
    this.ListDevices = this.ListDevices.bind(this);
    this.GetDeviceDimensions = this.GetDeviceDimensions.bind(this);
    this.CountDevices = this.CountDevices.bind(this);
    this.RepopulateCache = this.RepopulateCache.bind(this);
    this.PingDB = this.PingDB.bind(this);
    this.CleanExit = this.CleanExit.bind(this);
    this.ExportDevicesToCSV = this.ExportDevicesToCSV.bind(this);
    this.ListResourceRequests = this.ListResourceRequests.bind(this);
    this.CountResourceRequests = this.CountResourceRequests.bind(this);
    this.GetResourceRequestsMultiselectFilterValues = this.GetResourceRequestsMultiselectFilterValues.bind(this);
    this.UpdateAndroidDevices = this.UpdateAndroidDevices.bind(this);
    this.ListRepairMetrics = this.ListRepairMetrics.bind(this);
    this.CountRepairMetrics = this.CountRepairMetrics.bind(this);
    this.GetRepairMetricsDimensions = this.GetRepairMetricsDimensions.bind(this);
  }
  Ping(request: PingRequest): Promise<PingResponse> {
    const data = PingRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "Ping", data);
    return promise.then((data) => PingResponse.fromJSON(data));
  }

  PingBigQuery(request: PingBigQueryRequest): Promise<PingBigQueryResponse> {
    const data = PingBigQueryRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "PingBigQuery", data);
    return promise.then((data) => PingBigQueryResponse.fromJSON(data));
  }

  PingDeviceManager(request: PingDeviceManagerRequest): Promise<PingDeviceManagerResponse> {
    const data = PingDeviceManagerRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "PingDeviceManager", data);
    return promise.then((data) => PingDeviceManagerResponse.fromJSON(data));
  }

  PingUfs(request: PingUfsRequest): Promise<PingUfsResponse> {
    const data = PingUfsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "PingUfs", data);
    return promise.then((data) => PingUfsResponse.fromJSON(data));
  }

  LogFrontend(request: LogFrontendRequest): Promise<LogFrontendResponse> {
    const data = LogFrontendRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "LogFrontend", data);
    return promise.then((data) => LogFrontendResponse.fromJSON(data));
  }

  ListDevices(request: ListDevicesRequest): Promise<ListDevicesResponse> {
    const data = ListDevicesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListDevices", data);
    return promise.then((data) => ListDevicesResponse.fromJSON(data));
  }

  GetDeviceDimensions(request: Empty): Promise<GetDeviceDimensionsResponse> {
    const data = Empty.toJSON(request);
    const promise = this.rpc.request(this.service, "GetDeviceDimensions", data);
    return promise.then((data) => GetDeviceDimensionsResponse.fromJSON(data));
  }

  CountDevices(request: CountDevicesRequest): Promise<CountDevicesResponse> {
    const data = CountDevicesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CountDevices", data);
    return promise.then((data) => CountDevicesResponse.fromJSON(data));
  }

  RepopulateCache(request: RepopulateCacheRequest): Promise<RepopulateCacheResponse> {
    const data = RepopulateCacheRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "RepopulateCache", data);
    return promise.then((data) => RepopulateCacheResponse.fromJSON(data));
  }

  PingDB(request: PingDBRequest): Promise<PingDBResponse> {
    const data = PingDBRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "PingDB", data);
    return promise.then((data) => PingDBResponse.fromJSON(data));
  }

  CleanExit(request: CleanExitRequest): Promise<CleanExitResponse> {
    const data = CleanExitRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CleanExit", data);
    return promise.then((data) => CleanExitResponse.fromJSON(data));
  }

  ExportDevicesToCSV(request: ExportDevicesToCSVRequest): Promise<ExportDevicesToCSVResponse> {
    const data = ExportDevicesToCSVRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ExportDevicesToCSV", data);
    return promise.then((data) => ExportDevicesToCSVResponse.fromJSON(data));
  }

  ListResourceRequests(request: ListResourceRequestsRequest): Promise<ListResourceRequestsResponse> {
    const data = ListResourceRequestsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListResourceRequests", data);
    return promise.then((data) => ListResourceRequestsResponse.fromJSON(data));
  }

  CountResourceRequests(request: CountResourceRequestsRequest): Promise<CountResourceRequestsResponse> {
    const data = CountResourceRequestsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CountResourceRequests", data);
    return promise.then((data) => CountResourceRequestsResponse.fromJSON(data));
  }

  GetResourceRequestsMultiselectFilterValues(
    request: GetResourceRequestsMultiselectFilterValuesRequest,
  ): Promise<GetResourceRequestsMultiselectFilterValuesResponse> {
    const data = GetResourceRequestsMultiselectFilterValuesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetResourceRequestsMultiselectFilterValues", data);
    return promise.then((data) => GetResourceRequestsMultiselectFilterValuesResponse.fromJSON(data));
  }

  UpdateAndroidDevices(request: UpdateAndroidDevicesRequest): Promise<UpdateAndroidDevicesResponse> {
    const data = UpdateAndroidDevicesRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "UpdateAndroidDevices", data);
    return promise.then((data) => UpdateAndroidDevicesResponse.fromJSON(data));
  }

  ListRepairMetrics(request: ListRepairMetricsRequest): Promise<ListRepairMetricsResponse> {
    const data = ListRepairMetricsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "ListRepairMetrics", data);
    return promise.then((data) => ListRepairMetricsResponse.fromJSON(data));
  }

  CountRepairMetrics(request: CountRepairMetricsRequest): Promise<CountRepairMetricsResponse> {
    const data = CountRepairMetricsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "CountRepairMetrics", data);
    return promise.then((data) => CountRepairMetricsResponse.fromJSON(data));
  }

  GetRepairMetricsDimensions(request: GetRepairMetricsDimensionsRequest): Promise<GetRepairMetricsDimensionsResponse> {
    const data = GetRepairMetricsDimensionsRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "GetRepairMetricsDimensions", data);
    return promise.then((data) => GetRepairMetricsDimensionsResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
