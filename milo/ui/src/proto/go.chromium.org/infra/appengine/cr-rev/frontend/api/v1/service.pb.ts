// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v6.31.1
// source: go.chromium.org/infra/appengine/cr-rev/frontend/api/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "crrev";

export interface RedirectRequest {
  /**
   * query is equal to URL path of crrev main redirect logic. For example, it
   * can be "/3" (redirect to chromium/src commit with position 3) or
   * /{some_commit_hash} (redirect to some repository based on
   * some_commit_hash), etc.
   */
  readonly query: string;
}

export interface RedirectResponse {
  /**
   * git_hash is a full git commit hash of matched commit that is used for
   * redirect.
   */
  readonly gitHash: string;
  /** host is googlesource host (e.g. chromium). */
  readonly host: string;
  /** repository is Git repository (e.g. chromium/src) */
  readonly repository: string;
  /**
   * redirect_url is Gitiles URL of the commit, the same URL that user is
   * redirected to when using crrev's main redirect logic.
   */
  readonly redirectUrl: string;
}

export interface NumberingRequest {
  /** host is googlesource host (e.g. chromium). */
  readonly host: string;
  /** repository is Git repository (e.g. chromium/src) */
  readonly repository: string;
  /**
   * position_ref is name of position defined in value of git-footer git-svn-id
   * or Cr-Commit-Position (e.g. refs/heads/master,
   * svn://svn.chromium.org/chrome/trunk/src)
   */
  readonly positionRef: string;
  /**
   * position_number is sequential identifier of commit in given branch
   * (position_ref).
   */
  readonly positionNumber: string;
}

export interface NumberingResponse {
  /**
   * git_hash is a full git commit hash of matched commit that is used for
   * redirect.
   */
  readonly gitHash: string;
  /**
   * position_number matches NumberingRequest position_number. Probably useless
   * to clients, but kept for backward compatibility.
   */
  readonly positionNumber: string;
  /**
   * host matches NumberingRequest host. Probably useless to clients, but kept
   * for backward compatibility.
   */
  readonly host: string;
  /**
   * repository matches NumberingRequest repository. Probably useless to
   * clients, but kept for backward compatibility.
   */
  readonly repository: string;
}

export interface CommitRequest {
  /** git_hash is a full git commit hash of desired commit. */
  readonly gitHash: string;
}

export interface CommitResponse {
  /**
   * git_hash is a full git commit hash of matched commit that is used for
   * redirect.
   */
  readonly gitHash: string;
  /** host is googlesource host (e.g. chromium). */
  readonly host: string;
  /** repository is Git repository (e.g. chromium/src) */
  readonly repository: string;
  /**
   * position_number is sequential identifier of commit in given branch
   * (position_ref).
   */
  readonly positionNumber: string;
  /**
   * redirect_url is Gitiles URL of the commit, the same URL that user is
   * redirected to when using crrev's main redirect logic.
   */
  readonly redirectUrl: string;
}

function createBaseRedirectRequest(): RedirectRequest {
  return { query: "" };
}

export const RedirectRequest: MessageFns<RedirectRequest> = {
  encode(message: RedirectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: RedirectRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create(base?: DeepPartial<RedirectRequest>): RedirectRequest {
    return RedirectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RedirectRequest>): RedirectRequest {
    const message = createBaseRedirectRequest() as any;
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseRedirectResponse(): RedirectResponse {
  return { gitHash: "", host: "", repository: "", redirectUrl: "" };
}

export const RedirectResponse: MessageFns<RedirectResponse> = {
  encode(message: RedirectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitHash !== "") {
      writer.uint32(10).string(message.gitHash);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.repository !== "") {
      writer.uint32(26).string(message.repository);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(34).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectResponse {
    return {
      gitHash: isSet(object.git_sha) ? globalThis.String(object.git_sha) : "",
      host: isSet(object.project) ? globalThis.String(object.project) : "",
      repository: isSet(object.repo) ? globalThis.String(object.repo) : "",
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : "",
    };
  },

  toJSON(message: RedirectResponse): unknown {
    const obj: any = {};
    if (message.gitHash !== "") {
      obj.git_sha = message.gitHash;
    }
    if (message.host !== "") {
      obj.project = message.host;
    }
    if (message.repository !== "") {
      obj.repo = message.repository;
    }
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<RedirectResponse>): RedirectResponse {
    return RedirectResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RedirectResponse>): RedirectResponse {
    const message = createBaseRedirectResponse() as any;
    message.gitHash = object.gitHash ?? "";
    message.host = object.host ?? "";
    message.repository = object.repository ?? "";
    message.redirectUrl = object.redirectUrl ?? "";
    return message;
  },
};

function createBaseNumberingRequest(): NumberingRequest {
  return { host: "", repository: "", positionRef: "", positionNumber: "0" };
}

export const NumberingRequest: MessageFns<NumberingRequest> = {
  encode(message: NumberingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.repository !== "") {
      writer.uint32(18).string(message.repository);
    }
    if (message.positionRef !== "") {
      writer.uint32(26).string(message.positionRef);
    }
    if (message.positionNumber !== "0") {
      writer.uint32(32).int64(message.positionNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumberingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberingRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.positionRef = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.positionNumber = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberingRequest {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      positionRef: isSet(object.positionRef) ? globalThis.String(object.positionRef) : "",
      positionNumber: isSet(object.positionNumber) ? globalThis.String(object.positionNumber) : "0",
    };
  },

  toJSON(message: NumberingRequest): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.positionRef !== "") {
      obj.positionRef = message.positionRef;
    }
    if (message.positionNumber !== "0") {
      obj.positionNumber = message.positionNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<NumberingRequest>): NumberingRequest {
    return NumberingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumberingRequest>): NumberingRequest {
    const message = createBaseNumberingRequest() as any;
    message.host = object.host ?? "";
    message.repository = object.repository ?? "";
    message.positionRef = object.positionRef ?? "";
    message.positionNumber = object.positionNumber ?? "0";
    return message;
  },
};

function createBaseNumberingResponse(): NumberingResponse {
  return { gitHash: "", positionNumber: "0", host: "", repository: "" };
}

export const NumberingResponse: MessageFns<NumberingResponse> = {
  encode(message: NumberingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitHash !== "") {
      writer.uint32(10).string(message.gitHash);
    }
    if (message.positionNumber !== "0") {
      writer.uint32(16).int64(message.positionNumber);
    }
    if (message.host !== "") {
      writer.uint32(26).string(message.host);
    }
    if (message.repository !== "") {
      writer.uint32(34).string(message.repository);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumberingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberingResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.positionNumber = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberingResponse {
    return {
      gitHash: isSet(object.git_sha) ? globalThis.String(object.git_sha) : "",
      positionNumber: isSet(object.number) ? globalThis.String(object.number) : "0",
      host: isSet(object.project) ? globalThis.String(object.project) : "",
      repository: isSet(object.repo) ? globalThis.String(object.repo) : "",
    };
  },

  toJSON(message: NumberingResponse): unknown {
    const obj: any = {};
    if (message.gitHash !== "") {
      obj.git_sha = message.gitHash;
    }
    if (message.positionNumber !== "0") {
      obj.number = message.positionNumber;
    }
    if (message.host !== "") {
      obj.project = message.host;
    }
    if (message.repository !== "") {
      obj.repo = message.repository;
    }
    return obj;
  },

  create(base?: DeepPartial<NumberingResponse>): NumberingResponse {
    return NumberingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumberingResponse>): NumberingResponse {
    const message = createBaseNumberingResponse() as any;
    message.gitHash = object.gitHash ?? "";
    message.positionNumber = object.positionNumber ?? "0";
    message.host = object.host ?? "";
    message.repository = object.repository ?? "";
    return message;
  },
};

function createBaseCommitRequest(): CommitRequest {
  return { gitHash: "" };
}

export const CommitRequest: MessageFns<CommitRequest> = {
  encode(message: CommitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitHash !== "") {
      writer.uint32(10).string(message.gitHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitRequest {
    return { gitHash: isSet(object.gitHash) ? globalThis.String(object.gitHash) : "" };
  },

  toJSON(message: CommitRequest): unknown {
    const obj: any = {};
    if (message.gitHash !== "") {
      obj.gitHash = message.gitHash;
    }
    return obj;
  },

  create(base?: DeepPartial<CommitRequest>): CommitRequest {
    return CommitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitRequest>): CommitRequest {
    const message = createBaseCommitRequest() as any;
    message.gitHash = object.gitHash ?? "";
    return message;
  },
};

function createBaseCommitResponse(): CommitResponse {
  return { gitHash: "", host: "", repository: "", positionNumber: "0", redirectUrl: "" };
}

export const CommitResponse: MessageFns<CommitResponse> = {
  encode(message: CommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gitHash !== "") {
      writer.uint32(10).string(message.gitHash);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.repository !== "") {
      writer.uint32(26).string(message.repository);
    }
    if (message.positionNumber !== "0") {
      writer.uint32(32).int64(message.positionNumber);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(42).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gitHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.positionNumber = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitResponse {
    return {
      gitHash: isSet(object.git_sha) ? globalThis.String(object.git_sha) : "",
      host: isSet(object.project) ? globalThis.String(object.project) : "",
      repository: isSet(object.repo) ? globalThis.String(object.repo) : "",
      positionNumber: isSet(object.number) ? globalThis.String(object.number) : "0",
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : "",
    };
  },

  toJSON(message: CommitResponse): unknown {
    const obj: any = {};
    if (message.gitHash !== "") {
      obj.git_sha = message.gitHash;
    }
    if (message.host !== "") {
      obj.project = message.host;
    }
    if (message.repository !== "") {
      obj.repo = message.repository;
    }
    if (message.positionNumber !== "0") {
      obj.number = message.positionNumber;
    }
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CommitResponse>): CommitResponse {
    return CommitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitResponse>): CommitResponse {
    const message = createBaseCommitResponse() as any;
    message.gitHash = object.gitHash ?? "";
    message.host = object.host ?? "";
    message.repository = object.repository ?? "";
    message.positionNumber = object.positionNumber ?? "0";
    message.redirectUrl = object.redirectUrl ?? "";
    return message;
  },
};

export interface Crrev {
  /**
   * Redirect implements the same logic as the main crrev redirect, but returns
   * redirect and commit information in body instead of HTTP redirect.
   */
  Redirect(request: RedirectRequest): Promise<RedirectResponse>;
  /**
   * Numbering returns commit that matches desired position of commit, based on
   * NumberingRequest parameters. Commit position is based on git-footer
   * git-svn-id or Cr-Commit-Position.
   */
  Numbering(request: NumberingRequest): Promise<NumberingResponse>;
  /**
   * Commit returns commit with desired commit hash. If there are multiple
   * commits with the same commit hash (which happens with forks and mirrors),
   * it checks priorities based on config. It is possible that priorities are
   * the same. In such case, there is no guarantee which one will be returned.
   */
  Commit(request: CommitRequest): Promise<CommitResponse>;
}

export const CrrevServiceName = "crrev.Crrev";
export class CrrevClientImpl implements Crrev {
  static readonly DEFAULT_SERVICE = CrrevServiceName;
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || CrrevServiceName;
    this.rpc = rpc;
    this.Redirect = this.Redirect.bind(this);
    this.Numbering = this.Numbering.bind(this);
    this.Commit = this.Commit.bind(this);
  }
  Redirect(request: RedirectRequest): Promise<RedirectResponse> {
    const data = RedirectRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "Redirect", data);
    return promise.then((data) => RedirectResponse.fromJSON(data));
  }

  Numbering(request: NumberingRequest): Promise<NumberingResponse> {
    const data = NumberingRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "Numbering", data);
    return promise.then((data) => NumberingResponse.fromJSON(data));
  }

  Commit(request: CommitRequest): Promise<CommitResponse> {
    const data = CommitRequest.toJSON(request);
    const promise = this.rpc.request(this.service, "Commit", data);
    return promise.then((data) => CommitResponse.fromJSON(data));
  }
}

interface Rpc {
  request(service: string, method: string, data: unknown): Promise<unknown>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
